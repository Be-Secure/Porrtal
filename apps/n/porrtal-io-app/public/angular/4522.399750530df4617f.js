/*
Copyright 2022 Comcast Cable Communications Management, LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
"use strict";(self.webpackChunka_porrtal_io_app=self.webpackChunka_porrtal_io_app||[]).push([[4522],{58774:(Et,nt,V)=>{V.d(nt,{b:()=>s,j:()=>w});var E=V(15861),p=V(54346),G=V(8314);let O=null,H=null;function w(){return S.apply(this,arguments)}function S(){return(S=(0,E.Z)(function*(){return O||(O=k()),O})).apply(this,arguments)}function k(){return t.apply(this,arguments)}function t(){return(t=(0,E.Z)(function*(){H=yield((0,G.Z)("esri-csp-restrictions")?yield V.e(71).then(V.bind(V,10071)).then(r=>r.l):yield V.e(9507).then(V.bind(V,99507)).then(r=>r.l)).load({locateFile:r=>(0,p.V)(`esri/core/libs/libtess/${r}`)})})).apply(this,arguments)}function s(h,r){const n=Math.max(h.length,128e3);return H.triangulate(h,r,n)}},43289:(Et,nt,V)=>{function n(u){return function h(u,f){return(u%=f)>=0?u:u+f}(.7111111111111111*u,256)}function o(u,f,c){return u>=f&&u<=c||u>=c&&u<=f}V.d(nt,{s5:()=>n,vX:()=>o}),Math,Math},47018:(Et,nt,V)=>{V.d(nt,{I:()=>H,b:()=>O});var w,k,E=V(39351),p=V(97938),G=V(43289);class Y{constructor(t,s,h){this.ratio=t,this.x=s,this.y=h}}class O{constructor(t,s,h,r=8,n=8){this._lines=[],this._starts=[],this.validateTessellation=!0,this._pixelRatio=r,this._pixelMargin=n,this._tileSize=E.I_*r,this._dz=t,this._yPos=s,this._xPos=h}setPixelMargin(t){t!==this._pixelMargin&&(this._pixelMargin=t,this.setExtent(this._extent))}setExtent(t){this._extent=t,this._finalRatio=this._tileSize/t*(1<<this._dz);let s=this._pixelRatio*this._pixelMargin;s/=this._finalRatio;const h=t>>this._dz;s>h&&(s=h),this._margin=s,this._xmin=h*this._xPos-s,this._ymin=h*this._yPos-s,this._xmax=this._xmin+h+2*s,this._ymax=this._ymin+h+2*s}reset(t){this._type=t,this._lines=[],this._starts=[],this._line=null,this._start=0}moveTo(t,s){this._pushLine(),this._prevIsIn=this._isIn(t,s),this._moveTo(t,s,this._prevIsIn),this._prevPt=new p.E(t,s),this._firstPt=new p.E(t,s),this._dist=0}lineTo(t,s){const h=this._isIn(t,s),r=new p.E(t,s),n=p.E.distance(this._prevPt,r);let i,x,l,o,u,f,c,g;if(h)this._prevIsIn?this._lineTo(t,s,!0):(i=this._prevPt,x=r,l=this._intersect(x,i),this._start=this._dist+n*(1-this._r),this._lineTo(l.x,l.y,!0),this._lineTo(x.x,x.y,!0));else if(this._prevIsIn)x=this._prevPt,i=r,l=this._intersect(x,i),this._lineTo(l.x,l.y,!0),this._lineTo(i.x,i.y,!1);else{const y=this._prevPt,a=r;if(y.x<=this._xmin&&a.x<=this._xmin||y.x>=this._xmax&&a.x>=this._xmax||y.y<=this._ymin&&a.y<=this._ymin||y.y>=this._ymax&&a.y>=this._ymax)this._lineTo(a.x,a.y,!1);else{const d=[];if((y.x<this._xmin&&a.x>this._xmin||y.x>this._xmin&&a.x<this._xmin)&&(o=(this._xmin-y.x)/(a.x-y.x),g=y.y+o*(a.y-y.y),g<=this._ymin?f=!1:g>=this._ymax?f=!0:d.push(new Y(o,this._xmin,g))),(y.x<this._xmax&&a.x>this._xmax||y.x>this._xmax&&a.x<this._xmax)&&(o=(this._xmax-y.x)/(a.x-y.x),g=y.y+o*(a.y-y.y),g<=this._ymin?f=!1:g>=this._ymax?f=!0:d.push(new Y(o,this._xmax,g))),(y.y<this._ymin&&a.y>this._ymin||y.y>this._ymin&&a.y<this._ymin)&&(o=(this._ymin-y.y)/(a.y-y.y),c=y.x+o*(a.x-y.x),c<=this._xmin?u=!1:c>=this._xmax?u=!0:d.push(new Y(o,c,this._ymin))),(y.y<this._ymax&&a.y>this._ymax||y.y>this._ymax&&a.y<this._ymax)&&(o=(this._ymax-y.y)/(a.y-y.y),c=y.x+o*(a.x-y.x),c<=this._xmin?u=!1:c>=this._xmax?u=!0:d.push(new Y(o,c,this._ymax))),0===d.length)this._lineTo(u?this._xmax:this._xmin,f?this._ymax:this._ymin,!0);else if(d.length>1&&d[0].ratio>d[1].ratio)this._start=this._dist+n*d[1].ratio,this._lineTo(d[1].x,d[1].y,!0),this._lineTo(d[0].x,d[0].y,!0);else{this._start=this._dist+n*d[0].ratio;for(let m=0;m<d.length;m++)this._lineTo(d[m].x,d[m].y,!0)}this._lineTo(a.x,a.y,!1)}}this._dist+=n,this._prevIsIn=h,this._prevPt=r}close(){if(this._line.length>2){const t=this._firstPt,s=this._prevPt;t.x===s.x&&t.y===s.y||this.lineTo(t.x,t.y);const h=this._line;let r=h.length;for(;r>=4&&(h[0].x===h[1].x&&h[0].x===h[r-2].x||h[0].y===h[1].y&&h[0].y===h[r-2].y);)h.pop(),h[0].x=h[r-2].x,h[0].y=h[r-2].y,--r}}result(t=!0){return this._pushLine(),0===this._lines.length?null:(this._type===p.V.Polygon&&t&&S.simplify(this._tileSize,this._margin*this._finalRatio,this._lines),this._lines)}resultWithStarts(){if(this._type!==p.V.LineString)throw new Error("Only valid for lines");this._pushLine();const t=this._lines,s=t.length;if(0===s)return null;const h=[];for(let r=0;r<s;r++)h.push({line:t[r],start:this._starts[r]||0});return h}_isIn(t,s){return t>=this._xmin&&t<=this._xmax&&s>=this._ymin&&s<=this._ymax}_intersect(t,s){let h,r,n;if(s.x>=this._xmin&&s.x<=this._xmax)r=s.y<=this._ymin?this._ymin:this._ymax,n=(r-t.y)/(s.y-t.y),h=t.x+n*(s.x-t.x);else if(s.y>=this._ymin&&s.y<=this._ymax)h=s.x<=this._xmin?this._xmin:this._xmax,n=(h-t.x)/(s.x-t.x),r=t.y+n*(s.y-t.y);else{r=s.y<=this._ymin?this._ymin:this._ymax,h=s.x<=this._xmin?this._xmin:this._xmax;const i=(h-t.x)/(s.x-t.x),x=(r-t.y)/(s.y-t.y);i<x?(n=i,r=t.y+i*(s.y-t.y)):(n=x,h=t.x+x*(s.x-t.x))}return this._r=n,new p.E(h,r)}_pushLine(){this._line&&(this._type===p.V.Point?this._line.length>0&&(this._lines.push(this._line),this._starts.push(this._start)):this._type===p.V.LineString?this._line.length>1&&(this._lines.push(this._line),this._starts.push(this._start)):this._type===p.V.Polygon&&this._line.length>3&&(this._lines.push(this._line),this._starts.push(this._start))),this._line=[],this._start=0}_moveTo(t,s,h){this._type!==p.V.Polygon?h&&(t=Math.round((t-(this._xmin+this._margin))*this._finalRatio),s=Math.round((s-(this._ymin+this._margin))*this._finalRatio),this._line.push(new p.E(t,s))):(h||(t<this._xmin&&(t=this._xmin),t>this._xmax&&(t=this._xmax),s<this._ymin&&(s=this._ymin),s>this._ymax&&(s=this._ymax)),t=Math.round((t-(this._xmin+this._margin))*this._finalRatio),s=Math.round((s-(this._ymin+this._margin))*this._finalRatio),this._line.push(new p.E(t,s)),this._isH=!1,this._isV=!1)}_lineTo(t,s,h){let r,n;if(this._type!==p.V.Polygon)if(h){if(t=Math.round((t-(this._xmin+this._margin))*this._finalRatio),s=Math.round((s-(this._ymin+this._margin))*this._finalRatio),this._line.length>0&&(r=this._line[this._line.length-1],r.equals(t,s)))return;this._line.push(new p.E(t,s))}else this._line&&this._line.length>0&&this._pushLine();else if(h||(t<this._xmin&&(t=this._xmin),t>this._xmax&&(t=this._xmax),s<this._ymin&&(s=this._ymin),s>this._ymax&&(s=this._ymax)),t=Math.round((t-(this._xmin+this._margin))*this._finalRatio),s=Math.round((s-(this._ymin+this._margin))*this._finalRatio),this._line&&this._line.length>0){r=this._line[this._line.length-1];const i=r.x===t,x=r.y===s;if(i&&x)return;this._isH&&i||this._isV&&x?(r.x=t,r.y=s,n=this._line[this._line.length-2],n.x===t&&n.y===s?(this._line.pop(),this._line.length<=1?(this._isH=!1,this._isV=!1):(n=this._line[this._line.length-2],this._isH=n.x===t,this._isV=n.y===s)):(this._isH=n.x===t,this._isV=n.y===s)):(this._line.push(new p.E(t,s)),this._isH=i,this._isV=x)}else this._line.push(new p.E(t,s))}}class H{setExtent(t){this._ratio=4096===t?1:4096/t}get validateTessellation(){return this._ratio<1}reset(t){this._lines=[],this._line=null}moveTo(t,s){this._line&&this._lines.push(this._line),this._line=[];const h=this._ratio;this._line.push(new p.E(t*h,s*h))}lineTo(t,s){const h=this._ratio;this._line.push(new p.E(t*h,s*h))}close(){const t=this._line;t&&!t[0].isEqual(t[t.length-1])&&t.push(t[0])}result(){return this._line&&this._lines.push(this._line),0===this._lines.length?null:this._lines}}(k=w||(w={}))[k.sideLeft=0]="sideLeft",k[k.sideRight=1]="sideRight",k[k.sideTop=2]="sideTop",k[k.sideBottom=3]="sideBottom";class S{static simplify(t,s,h){if(!h)return;const r=-s,n=t+s,i=-s,x=t+s,l=[],o=[],u=h.length;for(let c=0;c<u;++c){const g=h[c];if(!g||g.length<2)continue;let y,a=g[0];const d=g.length;for(let m=1;m<d;++m)y=g[m],a.x===y.x&&(a.x<=r&&(a.y>y.y?(l.push(c),l.push(m),l.push(w.sideLeft),l.push(-1)):(o.push(c),o.push(m),o.push(w.sideLeft),o.push(-1))),a.x>=n&&(a.y<y.y?(l.push(c),l.push(m),l.push(w.sideRight),l.push(-1)):(o.push(c),o.push(m),o.push(w.sideRight),o.push(-1)))),a.y===y.y&&(a.y<=i&&(a.x<y.x?(l.push(c),l.push(m),l.push(w.sideTop),l.push(-1)):(o.push(c),o.push(m),o.push(w.sideTop),o.push(-1))),a.y>=x&&(a.x>y.x?(l.push(c),l.push(m),l.push(w.sideBottom),l.push(-1)):(o.push(c),o.push(m),o.push(w.sideBottom),o.push(-1)))),a=y}if(0===l.length||0===o.length)return;S.fillParent(h,o,l),S.fillParent(h,l,o);const f=[];S.calcDeltas(f,o,l),S.calcDeltas(f,l,o),S.addDeltas(f,h)}static fillParent(t,s,h){const r=h.length,n=s.length;for(let i=0;i<n;i+=4){const x=s[i],l=s[i+1],o=s[i+2],u=t[x][l-1],f=t[x][l];let c=8092,g=-1;for(let y=0;y<r;y+=4){if(h[y+2]!==o)continue;const a=h[y],d=h[y+1],m=t[a][d-1],R=t[a][d];switch(o){case w.sideLeft:case w.sideRight:if((0,G.vX)(u.y,m.y,R.y)&&(0,G.vX)(f.y,m.y,R.y)){const M=Math.abs(R.y-m.y);M<c&&(c=M,g=y)}break;case w.sideTop:case w.sideBottom:if((0,G.vX)(u.x,m.x,R.x)&&(0,G.vX)(f.x,m.x,R.x)){const M=Math.abs(R.x-m.x);M<c&&(c=M,g=y)}}}s[i+3]=g}}static calcDeltas(t,s,h){const r=s.length;for(let n=0;n<r;n+=4){const x=S.calcDelta(n,s,h,[]);t.push(s[n]),t.push(s[n+1]),t.push(s[n+2]),t.push(x)}}static calcDelta(t,s,h,r){const n=s[t+3];if(-1===n)return 0;const i=r.length;return i>1&&r[i-2]===n?0:(r.push(n),S.calcDelta(n,h,s,r)+1)}static addDeltas(t,s){const h=t.length;let r=0;for(let n=0;n<h;n+=4){const i=t[n+3];i>r&&(r=i)}for(let n=0;n<h;n+=4){const i=s[t[n]],x=t[n+1],l=r-t[n+3];switch(t[n+2]){case w.sideLeft:i[x-1].x-=l,i[x].x-=l,1===x&&(i[i.length-1].x-=l),x===i.length-1&&(i[0].x-=l);break;case w.sideRight:i[x-1].x+=l,i[x].x+=l,1===x&&(i[i.length-1].x+=l),x===i.length-1&&(i[0].x+=l);break;case w.sideTop:i[x-1].y-=l,i[x].y-=l,1===x&&(i[i.length-1].y-=l),x===i.length-1&&(i[0].y-=l);break;case w.sideBottom:i[x-1].y+=l,i[x].y+=l,1===x&&(i[i.length-1].y+=l),x===i.length-1&&(i[0].y+=l)}}}}},46519:(Et,nt,V)=>{V.d(nt,{z:()=>r});var E=V(7547),p=V(39351);function G(n,i){return n.x===i.x&&n.y===i.y}function O(n,i){return n.x=i.y,n.y=-i.x,n}function H(n,i){return n.x=-i.y,n.y=i.x,n}function w(n,i){return n.x=i.x,n.y=i.y,n}function S(n,i){return n.x=-i.x,n.y=-i.y,n}function k(n){return Math.sqrt(n.x*n.x+n.y*n.y)}function t(n,i){return n.x*i.y-n.y*i.x}function s(n,i){return n.x*i.x+n.y*i.y}function h(n,i,x,l){return n.x=i.x*x+i.y*l,n.y=i.x*l-i.y*x,n}class r{constructor(i,x,l){this._writeVertex=i,this._writeTriangle=x,this._canUseThinTessellation=l,this._prevNormal={x:void 0,y:void 0},this._nextNormal={x:void 0,y:void 0},this._textureNormalLeft={x:0,y:1},this._textureNormalRight={x:0,y:-1},this._textureNormal={x:void 0,y:void 0},this._joinNormal={x:void 0,y:void 0},this._inner={x:void 0,y:void 0},this._outer={x:void 0,y:void 0},this._roundStart={x:void 0,y:void 0},this._roundEnd={x:void 0,y:void 0},this._startBreak={x:void 0,y:void 0},this._endBreak={x:void 0,y:void 0},this._innerPrev={x:void 0,y:void 0},this._innerNext={x:void 0,y:void 0},this._bevelStart={x:void 0,y:void 0},this._bevelEnd={x:void 0,y:void 0},this._bevelMiddle={x:void 0,y:void 0}}tessellate(i,x){(function Y(n){if(!n)return;const i=n.length;if(i<=1)return;let x=0;for(let l=1;l<i;l++)G(n[l],n[x])||++x===l||(n[x]=n[l]);n.length=x+1})(i),this._canUseThinTessellation&&x.halfWidth<p.tQ&&!x.offset?this._tessellateThin(i,x):this._tessellate(i,x)}_tessellateThin(i,x){if(i.length<2)return;const l=x.wrapDistance||65535;let o=x.initialDistance||0,u=!1,f=i[0].x,c=i[0].y;const g=i.length;for(let y=1;y<g;++y){u&&(u=!1,o=0);let a=i[y].x,d=i[y].y,m=a-f,R=d-c,M=Math.sqrt(m*m+R*R);if(m/=M,R/=M,o+M>l){u=!0;const e=(l-o)/M;M=l-o,a=(1-e)*f+e*a,d=(1-e)*c+e*d,--y}const L=this._writeVertex(f,c,0,0,m,R,R,-m,0,-1,o),P=this._writeVertex(f,c,0,0,m,R,-R,m,0,1,o);o+=M;const ht=this._writeVertex(a,d,0,0,m,R,R,-m,0,-1,o),_=this._writeVertex(a,d,0,0,m,R,-R,m,0,1,o);this._writeTriangle(L,P,ht),this._writeTriangle(P,ht,_),f=a,c=d}}_tessellate(i,x){const o=i[i.length-1],u=G(i[0],o);if(i.length<(u?3:2))return;const c=x.pixelCoordRatio,g=null!=x.capType?x.capType:E.RL.BUTT,y=null!=x.joinType?x.joinType:E.AH.MITER,a=null!=x.miterLimit?Math.min(x.miterLimit,4):2,d=null!=x.roundLimit?Math.min(x.roundLimit,1.05):1.05,m=null!=x.halfWidth?x.halfWidth:2,R=!!x.textured;let M,L,P,ht=null;const _=this._prevNormal,e=this._nextNormal;let lt=-1,it=-1;const v=this._joinNormal;let N,B;const ct=this._textureNormalLeft,mt=this._textureNormalRight,j=this._textureNormal;let U=-1,I=-1;const wt=x.wrapDistance||65535;let D=x.initialDistance||0;const Pt=this._writeVertex,Vt=this._writeTriangle,A=(K,dt,_t,C,Z,$)=>{const J=Pt(L,P,N,B,_t,C,K,dt,Z,$,D);return U>=0&&I>=0&&J>=0&&Vt(U,I,J),U=I,I=J,J};u&&(M=i[i.length-2],e.x=o.x-M.x,e.y=o.y-M.y,it=k(e),e.x/=it,e.y/=it);let rt=!1;for(let K=0;K<i.length;++K){if(rt&&(rt=!1,D=0),M&&(_.x=-e.x,_.y=-e.y,lt=it,D+lt>wt&&(rt=!0)),rt){const T=(wt-D)/lt;lt=wt-D,M={x:(1-T)*M.x+T*i[K].x,y:(1-T)*M.y+T*i[K].y},--K}else M=i[K];L=M.x,P=M.y;const dt=K<=0&&!rt,_t=K===i.length-1;if(dt||(D+=lt),ht=_t?u?i[1]:null:i[K+1],ht?(e.x=ht.x-L,e.y=ht.y-P,it=k(e),e.x/=it,e.y/=it):(e.x=void 0,e.y=void 0),!u){if(dt){H(v,e),N=v.x,B=v.y,g===E.RL.SQUARE&&(A(-e.y-e.x,e.x-e.y,e.x,e.y,0,-1),A(e.y-e.x,-e.x-e.y,e.x,e.y,0,1)),g===E.RL.ROUND&&(A(-e.y-e.x,e.x-e.y,e.x,e.y,-1,-1),A(e.y-e.x,-e.x-e.y,e.x,e.y,-1,1)),g!==E.RL.ROUND&&g!==E.RL.BUTT||(A(-e.y,e.x,e.x,e.y,0,-1),A(e.y,-e.x,e.x,e.y,0,1));continue}if(_t){O(v,_),N=v.x,B=v.y,g!==E.RL.ROUND&&g!==E.RL.BUTT||(A(_.y,-_.x,-_.x,-_.y,0,-1),A(-_.y,_.x,-_.x,-_.y,0,1)),g===E.RL.SQUARE&&(A(_.y-_.x,-_.x-_.y,-_.x,-_.y,0,-1),A(-_.y-_.x,_.x-_.y,-_.x,-_.y,0,1)),g===E.RL.ROUND&&(A(_.y-_.x,-_.x-_.y,-_.x,-_.y,1,-1),A(-_.y-_.x,_.x-_.y,-_.x,-_.y,1,1));continue}}let C,Z,$=-t(_,e);if(Math.abs($)<.01)s(_,e)>0?(v.x=_.x,v.y=_.y,$=1,C=Number.MAX_VALUE,Z=!0):(H(v,e),$=1,C=1,Z=!1);else{v.x=(_.x+e.x)/$,v.y=(_.y+e.y)/$,C=k(v);const T=(C-1)*m*c;Z=C>4||T>lt&&T>it}N=v.x,B=v.y;let J=y;switch(y){case E.AH.BEVEL:C<1.05&&(J=E.AH.MITER);break;case E.AH.ROUND:C<d&&(J=E.AH.MITER);break;case E.AH.MITER:C>a&&(J=E.AH.BEVEL)}switch(J){case E.AH.MITER:if(A(v.x,v.y,-_.x,-_.y,0,-1),A(-v.x,-v.y,-_.x,-_.y,0,1),_t)break;if(R){const T=rt?0:D;U=this._writeVertex(L,P,N,B,e.x,e.y,v.x,v.y,0,-1,T),I=this._writeVertex(L,P,N,B,e.x,e.y,-v.x,-v.y,0,1,T)}break;case E.AH.BEVEL:{const T=$<0;let W,X,st,Q;if(T){const b=U;U=I,I=b,W=ct,X=mt}else W=mt,X=ct;if(Z)st=T?H(this._innerPrev,_):O(this._innerPrev,_),Q=T?O(this._innerNext,e):H(this._innerNext,e);else{const b=T?S(this._inner,v):w(this._inner,v);st=b,Q=b}const F=T?O(this._bevelStart,_):H(this._bevelStart,_);A(st.x,st.y,-_.x,-_.y,W.x,W.y);const pt=A(F.x,F.y,-_.x,-_.y,X.x,X.y);if(_t)break;const q=T?H(this._bevelEnd,e):O(this._bevelEnd,e);if(Z){const b=this._writeVertex(L,P,N,B,-_.x,-_.y,0,0,0,0,D);U=this._writeVertex(L,P,N,B,e.x,e.y,Q.x,Q.y,W.x,W.y,D),I=this._writeVertex(L,P,N,B,e.x,e.y,q.x,q.y,X.x,X.y,D),this._writeTriangle(pt,b,I)}else{if(R){const b=this._bevelMiddle;b.x=(F.x+q.x)/2,b.y=(F.y+q.y)/2,h(j,b,-_.x,-_.y),A(b.x,b.y,-_.x,-_.y,j.x,j.y),h(j,b,e.x,e.y),U=this._writeVertex(L,P,N,B,e.x,e.y,b.x,b.y,j.x,j.y,D),I=this._writeVertex(L,P,N,B,e.x,e.y,Q.x,Q.y,W.x,W.y,D)}else{const b=U;U=I,I=b}A(q.x,q.y,e.x,e.y,X.x,X.y)}if(T){const b=U;U=I,I=b}break}case E.AH.ROUND:{const T=$<0;let W,X;if(T){const z=U;U=I,I=z,W=ct,X=mt}else W=mt,X=ct;const st=T?S(this._inner,v):w(this._inner,v);let Q,F;Z?(Q=T?H(this._innerPrev,_):O(this._innerPrev,_),F=T?O(this._innerNext,e):H(this._innerNext,e)):(Q=st,F=st);const pt=T?O(this._roundStart,_):H(this._roundStart,_),q=T?H(this._roundEnd,e):O(this._roundEnd,e),b=A(Q.x,Q.y,-_.x,-_.y,W.x,W.y),ft=A(pt.x,pt.y,-_.x,-_.y,X.x,X.y);if(_t)break;const et=this._writeVertex(L,P,N,B,-_.x,-_.y,0,0,0,0,D);Z||this._writeTriangle(U,I,et);const tt=S(this._outer,st),xt=this._writeVertex(L,P,N,B,e.x,e.y,q.x,q.y,X.x,X.y,D);let yt,ot;const gt=C>2;if(gt){let z;C!==Number.MAX_VALUE?(tt.x/=C,tt.y/=C,z=s(_,tt),z=(C*(z*z-1)+1)/z):z=-1,yt=T?O(this._startBreak,_):H(this._startBreak,_),yt.x+=_.x*z,yt.y+=_.y*z,ot=T?H(this._endBreak,e):O(this._endBreak,e),ot.x+=e.x*z,ot.y+=e.y*z}h(j,tt,-_.x,-_.y);const Tt=this._writeVertex(L,P,N,B,-_.x,-_.y,tt.x,tt.y,j.x,j.y,D);h(j,tt,e.x,e.y);const Rt=R?this._writeVertex(L,P,N,B,e.x,e.y,tt.x,tt.y,j.x,j.y,D):Tt,Mt=et,vt=R?this._writeVertex(L,P,N,B,e.x,e.y,0,0,0,0,D):et;let at=-1,ut=-1;if(gt&&(h(j,yt,-_.x,-_.y),at=this._writeVertex(L,P,N,B,-_.x,-_.y,yt.x,yt.y,j.x,j.y,D),h(j,ot,e.x,e.y),ut=this._writeVertex(L,P,N,B,e.x,e.y,ot.x,ot.y,j.x,j.y,D)),R?gt?(this._writeTriangle(Mt,ft,at),this._writeTriangle(Mt,at,Tt),this._writeTriangle(vt,Rt,ut),this._writeTriangle(vt,ut,xt)):(this._writeTriangle(Mt,ft,Tt),this._writeTriangle(vt,Rt,xt)):gt?(this._writeTriangle(et,ft,at),this._writeTriangle(et,at,ut),this._writeTriangle(et,ut,xt)):(this._writeTriangle(et,ft,Tt),this._writeTriangle(et,Rt,xt)),Z?(U=this._writeVertex(L,P,N,B,e.x,e.y,F.x,F.y,W.x,W.y,D),I=xt):(U=R?this._writeVertex(L,P,N,B,e.x,e.y,F.x,F.y,W.x,W.y,D):b,this._writeTriangle(U,vt,xt),I=xt),T){const z=U;U=I,I=z}break}}}}}}}]);