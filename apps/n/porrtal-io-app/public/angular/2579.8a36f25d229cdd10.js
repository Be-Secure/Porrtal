/*
Copyright 2022 Comcast Cable Communications Management, LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
"use strict";(self.webpackChunka_porrtal_io_app=self.webpackChunka_porrtal_io_app||[]).push([[2579],{42579:(Ue,dt,l)=>{l.r(dt),l.d(dt,{meshFeatureSetFromJSON:()=>Pe});var zt=l(88879),p=l(62208),st=l(2004),U=l(15861),M=l(17626),it=l(26584),Dt=l(80542),Nt=l(47996),V=l(63290),jt=l(60330),j=l(10699),Gt=l(32917),Z=l(77712),$t=(l(85931),l(8314),l(90912),l(76898)),d=l(28093),Bt=l(21674),S=l(49672),Wt=l(37118),A=l(89586),G=l(61751),q=l(99746),_=l(92529),Ht=l(85334),I=l(55915),tt=l(92545),at=l(60853);const lt=V.Z.getLogger("esri.geometry.support.meshUtils.centerAt");const Vt=(0,d.c)(),kt=(0,d.c)();var xt=l(21726);function ct(){return(ct=(0,U.Z)(function*(t,n,e){const{loadGLTFMesh:r}=yield(0,j.Hl)(l.e(9185).then(l.bind(l,29185)),e),o=yield vt(n,e),s=r(new S.Z({x:0,y:0,z:0,spatialReference:t.spatialReference}),o.url,{resolveFile:_t(o),useTransform:!0,signal:(0,p.pC)(e)?e.signal:null});s.then(()=>o.dispose(),()=>o.dispose());const{vertexAttributes:i,components:a}=yield s;t.vertexAttributes=i,t.components=a})).apply(this,arguments)}function _t(t){const n=(0,xt.Yd)(t.url);return e=>{const r=(0,xt.PF)(e,n,n),o=r?r.replace(/^ *\.\//,""):null;return t.files.get(o)??e}}function vt(t,n){return ft.apply(this,arguments)}function ft(){return(ft=(0,U.Z)(function*(t,n){return t instanceof Blob?$.fromBlob(t):"string"==typeof t?new $(t):Array.isArray(t)?te(t,n):ee(t,n)})).apply(this,arguments)}function te(t,n){return pt.apply(this,arguments)}function pt(){return pt=(0,U.Z)(function*(t,n){const e=new Map;let r=null;const o=yield(0,j.WW)(t.map(function(){var i=(0,U.Z)(function*(a){return{name:a.name,source:yield vt(a instanceof Blob?a:a.source,n)}});return function(a){return i.apply(this,arguments)}}())),s=[];for(const i of o)i&&((0,j.Hc)(n)?i.source.dispose():s.push(i));(0,j.k_)(n);for(const{name:i,source:a}of s)((0,p.Wi)(r)||/\.(gltf|glb)/i.test(i))&&(r=a.url),e.set(i,a.url),a.files&&a.files.forEach((f,c)=>e.set(c,f));if((0,p.Wi)(r))throw new it.Z("mesh-load-external:missing-files","Missing files to load external mesh source");return new $(r,()=>s.forEach(({source:i})=>i.dispose()),e)}),pt.apply(this,arguments)}function ee(t,n){return ut.apply(this,arguments)}function ut(){return ut=(0,U.Z)(function*(t,n){const{default:e}=yield(0,j.Hl)(Promise.resolve().then(l.bind(l,84792)),n),r="string"==typeof t.multipart[0]?yield Promise.all(t.multipart.map(function(){var o=(0,U.Z)(function*(s){return(yield e(s,{responseType:"array-buffer"})).data});return function(s){return o.apply(this,arguments)}}())):t.multipart;return $.fromBlob(new Blob(r))}),ut.apply(this,arguments)}class ${constructor(n,e=(()=>{}),r=new Map){this.url=n,this.dispose=e,this.files=r}static fromBlob(n){const e=URL.createObjectURL(n);return new $(e,()=>URL.revokeObjectURL(e))}}var yt=l(30217),ht=l(550),At=l(43703),y=l(84161),mt=l(12080),v=l(65231);const ne=V.Z.getLogger("esri.geometry.support.meshUtils.offset");function Ct(t,n){if(t)for(let e=0;e<t.length;e+=3)for(let r=0;r<3;r++)t[e+r]+=n[r]}const ae=(0,d.c)(),bt=(0,At.c)(),wt=(0,ht.c)(),k={position:[-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0],normal:[0,0,1,0,0,1,0,0,1,0,0,1],uv:[0,1,1,1,1,0,0,0],faces:[0,1,2,0,2,3],facingAxisOrderSwap:{east:[3,1,2],west:[-3,-1,2],north:[-1,3,2],south:[1,-3,2],up:[1,2,3],down:[1,-2,-3]}};function et(t,n,e){t.isPlane||function me(t){for(let n=0;n<t.position.length;n+=3)t.position[n+2]+=.5}(t),function ge(t,n){if(null==n)return;const e="number"==typeof n?[n,n,n]:[null!=n.width?n.width:1,null!=n.depth?n.depth:1,null!=n.height?n.height:1];T[0]=e[0],T[4]=e[1],T[8]=e[2];for(let r=0;r<t.position.length;r+=3){for(let o=0;o<3;o++)x[o]=t.position[r+o];(0,y.t)(x,x,T);for(let o=0;o<3;o++)t.position[r+o]=x[o]}if(e[0]!==e[1]||e[1]!==e[2]){T[0]=1/e[0],T[4]=1/e[1],T[8]=1/e[2];for(let r=0;r<t.normal.length;r+=3){for(let o=0;o<3;o++)x[o]=t.normal[r+o];(0,y.t)(x,x,T),(0,y.n)(x,x);for(let o=0;o<3;o++)t.normal[r+o]=x[o]}}}(t,e&&e.size);const{vertexAttributes:r,transform:o}=(0,at.w1)(t,n,e);return{vertexAttributes:new _.Q({...r,uv:t.uv}),transform:o,components:[new G.Z({faces:t.faces,material:e&&e.material||null})],spatialReference:n.spatialReference}}const de={faceDescriptions:[{axis:[0,-1,0],uvOrigin:[0,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[1,0,0],uvOrigin:[.25,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,1,0],uvOrigin:[.5,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[-1,0,0],uvOrigin:[.75,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[0,0,1],uvOrigin:[0,.375],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,0,-1],uvOrigin:[0,.875],corners:[[-1,1],[1,1],[1,-1],[-1,-1]]}],uvScales:[[0,0],[1,0],[1,1],[0,1]],faceVertexOffsets:[0,1,2,0,2,3]},xe={south:0,east:1,north:2,west:3,up:4,down:5},x=(0,d.c)(),T=(0,ht.c)();var ve=l(28347);const Ft=V.Z.getLogger("esri.geometry.support.meshUtils.rotate");function Y(t,n,e,r=d.Z){if(!(0,p.Wi)(t)){(0,ve.d)(nt,(0,A.WH)(n),(0,A.ZZ)(n));for(let o=0;o<t.length;o+=e){for(let s=0;s<3;s++)K[s]=t[o+s]-r[s];(0,y.m)(K,K,nt);for(let s=0;s<3;s++)t[o+s]=K[s]+r[s]}}}const K=(0,d.c)(),Mt=(0,d.c)(),Rt=(0,A.Ue)(),nt=(0,At.c)(),Zt=(0,ht.c)(),Pt=(0,d.c)(),Et=V.Z.getLogger("esri.geometry.support.meshUtils.scale");function Ot(t,n,e=d.Z){if(t)for(let r=0;r<t.length;r+=3){for(let o=0;o<3;o++)X[o]=t[r+o]-e[o];(0,y.g)(X,X,n);for(let o=0;o<3;o++)t[r+o]=X[o]+e[o]}}const X=(0,d.c)(),St=(0,d.c)(),It=(0,d.c)();var P;const R=V.Z.getLogger("esri.geometry.Mesh");let b=P=class extends((0,Dt.p)(Nt.Z.LoadableMixin((0,jt.v)(Bt.Z)))){constructor(t){super(t),this.components=null,this.transform=null,this.external=null,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new _.Q,this.type="mesh"}initialize(){((0,p.Wi)(this.external)||this.vertexAttributes.position.length)&&(this.loadStatus="loaded"),this.when(()=>{this.handles.add((0,Gt.YP)(()=>({vertexAttributes:this.vertexAttributes,components:this.components?.map(t=>t.clone()),transform:(0,p.pC)(this.transform)?this.transform.clone():null}),()=>this._set("external",null),{once:!0,sync:!0}))})}get hasExtent(){return!this.loaded&&(0,p.pC)(this.external)&&(0,p.pC)(this.external.extent)||this.loaded&&this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0)}get boundingInfo(){const t=this.vertexAttributes.position,n=this.spatialReference;if(0===t.length||this.components&&0===this.components.length)return{extent:new st.Z({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0,spatialReference:n}),center:new S.Z({x:0,y:0,z:0,spatialReference:n})};const e=(0,p.pC)(this.transform)?this.transform.project(t,n):t;let r=1/0,o=1/0,s=1/0,i=-1/0,a=-1/0,f=-1/0,c=0,u=0,g=0;const m=e.length,h=1/(m/3);let w=0;for(;w<m;){const L=e[w++],C=e[w++],E=e[w++];r=Math.min(r,L),o=Math.min(o,C),s=Math.min(s,E),i=Math.max(i,L),a=Math.max(a,C),f=Math.max(f,E),c+=h*L,u+=h*C,g+=h*E}return{extent:new st.Z({xmin:r,ymin:o,zmin:s,xmax:i,ymax:a,zmax:f,spatialReference:n}),center:new S.Z({x:c,y:u,z:g,spatialReference:n})}}get anchor(){if((0,p.pC)(this.transform))return this.transform.getOriginPoint(this.spatialReference);const t=this.boundingInfo;return new S.Z({x:t.center.x,y:t.center.y,z:t.extent.zmin,spatialReference:this.spatialReference})}get origin(){return(0,p.pC)(this.transform)?this.transform.getOriginPoint(this.spatialReference):this.boundingInfo.center}get extent(){return!this.loaded&&(0,p.pC)(this.external)&&(0,p.pC)(this.external.extent)?this.external.extent.clone():this.boundingInfo.extent}addComponent(t){this.loaded?(this.components||(this.components=[]),this.components.push(G.Z.from(t)),this.notifyChange("components")):R.error("addComponent()","Mesh must be loaded before applying operations")}removeComponent(t){if(this.loaded){if(this.components){const n=this.components.indexOf(t);if(-1!==n)return this.components.splice(n,1),void this.notifyChange("components")}R.error("removeComponent()","Provided component is not part of the list of components")}else R.error("removeComponent()","Mesh must be loaded before applying operations")}rotate(t,n,e,r){return(0,A.uT)(gt.x,t,J),(0,A.uT)(gt.y,n,Lt),(0,A.uT)(gt.z,e,Ut),(0,A.qC)(J,Lt,J),(0,A.qC)(J,Ut,J),function ye(t,n,e){if(!t.vertexAttributes||!t.vertexAttributes.position||0===n[3])return;const r=t.spatialReference;if((0,p.pC)(t.transform)){null!=e?.geographic&&e.geographic!==t.transform.geographic&&Ft.warn(`Specifying the 'geographic' parameter (${e.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`);const o=e?.origin??t.transform.getOriginPoint(r);!function Ae(t,n,e){const r=(0,y.s)(K,e.x,e.y,e.z),o=(0,y.b)(K,r,t.origin);t.applyLocalInverse(o,Mt),t.rotation=(0,A.qC)(t.rotation,n,(0,A.Ue)()),t.applyLocalInverse(o,o),(0,y.b)(o,o,Mt),t.translation=(0,y.a)((0,d.c)(),t.translation,o)}(t.transform,n,o)}else{const o=e?.origin??t.origin;(0,tt.h)(t.spatialReference,e)?function Ce(t,n,e){const r=t.spatialReference,o=(0,mt.rS)(r),s=Pt;(0,I.KC)(e,s,o)||(0,I.KC)(t.origin,s,o);const i=t.vertexAttributes.position,a=t.vertexAttributes.normal,f=t.vertexAttributes.tangent,c=new Float64Array(i.length),u=(0,p.pC)(a)?new Float32Array(a.length):null,g=(0,p.pC)(f)?new Float32Array(f.length):null;(0,I.Bm)(o,s,nt,o),(0,yt.f)(Zt,nt);const m=Rt;(0,y.t)((0,A.ZZ)(Rt),(0,A.ZZ)(n),Zt),m[3]=n[3],(0,v.XO)(i,r,c),(0,p.pC)(a)&&(0,v.Iz)(a,i,c,r,u),(0,p.pC)(f)&&(0,v.wi)(f,i,c,r,g),Y(c,m,3,s),(0,v.To)(c,i,r),(0,p.pC)(a)&&(Y(u,m,3),(0,v.Yk)(u,i,c,r,a)),(0,p.pC)(f)&&(Y(g,m,4),(0,v.M2)(g,i,c,r,f)),t.vertexAttributesChanged()}(t,n,o):function be(t,n,e){const r=Pt;if(!(0,I.KC)(e,r,t.spatialReference)){const o=t.origin;r[0]=o.x,r[1]=o.y,r[2]=o.z,Ft.error(`Failed to project specified origin (wkid:${e.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}).`)}Y(t.vertexAttributes.position,n,3,r),Y(t.vertexAttributes.normal,n,3),Y(t.vertexAttributes.tangent,n,4),t.vertexAttributesChanged()}(t,n,o)}}(this,J,r),this}offset(t,n,e,r){return this.loaded?(rt[0]=t,rt[1]=n,rt[2]=e,function re(t,n,e){t.vertexAttributes&&t.vertexAttributes.position&&((0,p.pC)(t.transform)?(null!=e?.geographic&&e.geographic!==t.transform.geographic&&ne.warn(`Specifying the 'geographic' parameter (${e.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`),function oe(t,n){const e=t.origin;t.origin=(0,y.a)((0,d.c)(),e,n)}(t.transform,n)):(0,tt.h)(t.spatialReference,e)?function se(t,n){const e=t.spatialReference,r=t.vertexAttributes.position,o=t.vertexAttributes.normal,s=t.vertexAttributes.tangent,i=new Float64Array(r.length),a=(0,p.pC)(o)?new Float32Array(o.length):null,f=(0,p.pC)(s)?new Float32Array(s.length):null,c=t.extent.center,u=ae;(0,I.Bm)(e,[c.x,c.y,c.z],bt,(0,mt.rS)(e)),(0,yt.f)(wt,bt),(0,y.t)(u,n,wt),(0,v.XO)(r,e,i),(0,p.pC)(o)&&(0,v.Iz)(o,r,i,e,a),(0,p.pC)(s)&&(0,v.wi)(s,r,i,e,f),Ct(i,u),(0,v.To)(i,r,e),(0,p.pC)(o)&&(0,v.Yk)(a,r,i,e,o),(0,p.pC)(s)&&(0,v.M2)(f,r,i,e,s),t.vertexAttributesChanged()}(t,n):function ie(t,n){Ct(t.vertexAttributes.position,n),t.vertexAttributesChanged()}(t,n))}(this,rt,r),this):(R.error("offset()","Mesh must be loaded before applying operations"),this)}scale(t,n){return this.loaded?(function we(t,n,e){if(!t.vertexAttributes||!t.vertexAttributes.position)return;const r=t.spatialReference;if((0,p.pC)(t.transform)){null!=e?.geographic&&e.geographic!==t.transform.geographic&&Et.warn(`Specifying the 'geographic' parameter (${e.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`);const o=e?.origin??t.transform.getOriginPoint(r);!function Fe(t,n,e){const r=(0,y.s)(X,e.x,e.y,e.z),o=(0,y.b)(X,r,t.origin);t.applyLocalInverse(o,St);const s=(0,y.g)((0,d.c)(),t.scale,n);t.scale=s,t.applyLocalInverse(o,o),(0,y.b)(o,o,St),t.translation=(0,y.a)((0,d.c)(),t.translation,o)}(t.transform,n,o)}else{const o=(0,tt.h)(t.spatialReference,e),s=e&&e.origin||t.origin;o?function Me(t,n,e){const r=t.spatialReference,o=(0,mt.rS)(r),s=It;(0,I.KC)(e,s,o)||(0,I.KC)(t.origin,s,o);const i=t.vertexAttributes.position,a=t.vertexAttributes.normal,f=t.vertexAttributes.tangent,c=new Float64Array(i.length),u=(0,p.pC)(a)?new Float32Array(a.length):null,g=(0,p.pC)(f)?new Float32Array(f.length):null;(0,v.XO)(i,r,c),(0,p.pC)(a)&&(0,v.Iz)(a,i,c,r,u),(0,p.pC)(f)&&(0,v.wi)(f,i,c,r,g),Ot(c,n,s),(0,v.To)(c,i,r),(0,p.pC)(a)&&(0,v.Yk)(u,i,c,r,a),(0,p.pC)(f)&&(0,v.M2)(g,i,c,r,f),t.vertexAttributesChanged()}(t,n,s):function Re(t,n,e){const r=It;if(!(0,I.KC)(e,r,t.spatialReference)){const o=t.origin;r[0]=o.x,r[1]=o.y,r[2]=o.z,Et.error(`Failed to project specified origin (wkid:${e.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}).`)}Ot(t.vertexAttributes.position,n,r),t.vertexAttributesChanged()}(t,n,s)}}(this,t,n),this):(R.error("scale()","Mesh must be loaded before applying operations"),this)}centerAt(t,n){return this.loaded?(function Yt(t,n,e){if(!t.vertexAttributes||!t.vertexAttributes.position)return;const r=e?.origin??t.origin;(0,p.pC)(t.transform)?(null!=e?.geographic&&e.geographic!==t.transform.geographic&&lt.warn(`Specifying the 'geographic' parameter (${e.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`),function Kt(t,n,e){const i=t.origin;t.origin=[i[0]+(n.x-e.x),i[1]+(n.y-e.y),i[2]+(n.hasZ&&e.hasZ?n.z-e.z:0)]}(t.transform,n,r)):(0,tt.h)(t.spatialReference,e)?function Xt(t,n,e){const r=(0,at.FF)(t.vertexAttributes,e,{geographic:!0}),{position:o,normal:s,tangent:i}=(0,at.iv)(r,n,{geographic:!0});t.vertexAttributes.position=o,t.vertexAttributes.normal=s,t.vertexAttributes.tangent=i,t.vertexAttributesChanged()}(t,n,r):function Jt(t,n,e){const r=kt,o=Vt;if((0,I.KC)(n,o,t.spatialReference)){if(!(0,I.KC)(e,r,t.spatialReference)){const s=t.origin;r[0]=s.x,r[1]=s.y,r[2]=s.z,lt.error(`Failed to project specified origin (wkid:${e.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}).`)}(function Qt(t,n,e){if(t)for(let r=0;r<t.length;r+=3)for(let o=0;o<3;o++)t[r+o]+=n[o]-e[o]})(t.vertexAttributes.position,o,r),t.vertexAttributesChanged()}else lt.error(`Failed to project centerAt location (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid})`)}(t,n,r)}(this,t,n),this):(R.error("centerAt()","Mesh must be loaded before applying operations"),this)}load(t){return(0,p.pC)(this.external)&&this.addResolvingPromise(function qt(t,n,e){return ct.apply(this,arguments)}(this,this.external.source,t)),Promise.resolve(this)}clone(){const t=this.components?new Map:null,n=this.components?new Map:null,e={components:this.components?this.components.map(r=>r.cloneWithDeduplication(t,n)):null,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes.clone(),transform:(0,p.pC)(this.transform)?this.transform.clone():null,external:(0,p.pC)(this.external)?{source:this.external.source,extent:(0,p.pC)(this.external.extent)?this.external.extent.clone():null}:null};return new P(e)}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}toBinaryGLTF(t){var n=this;return(0,U.Z)(function*(){const{toBinaryGLTF:e}=yield l.e(7627).then(l.bind(l,57627));return e(n,t)})()}static createBox(t,n){if(!(t instanceof S.Z))return R.error(".createBox()","expected location to be a Point instance"),null;const e=new P(et(function le(){const{faceDescriptions:t,faceVertexOffsets:n,uvScales:e}=de,r=4*t.length,o=new Float64Array(3*r),s=new Float32Array(3*r),i=new Float32Array(2*r),a=new Uint32Array(2*t.length*3);let f=0,c=0,u=0,g=0;for(let m=0;m<t.length;m++){const h=t[m],w=f/3;for(const C of n)a[g++]=w+C;const L=h.corners;for(let C=0;C<4;C++){const E=L[C];let F=0;i[u++]=.25*e[C][0]+h.uvOrigin[0],i[u++]=h.uvOrigin[1]-.25*e[C][1];for(let O=0;O<3;O++)0!==h.axis[O]?(o[f++]=.5*h.axis[O],s[c++]=h.axis[O]):(o[f++]=.5*E[F++],s[c++]=0)}}return{position:o,normal:s,uv:i,faces:a}}(),t,n));return n&&n.imageFace&&"all"!==n.imageFace?function ce(t,n){const e=t.components[0],r=e.faces,o=xe[n],s=6*o,i=new Uint32Array(6),a=new Uint32Array(r.length-6);let f=0,c=0;for(let u=0;u<r.length;u++)u>=s&&u<s+6?i[f++]=r[u]:a[c++]=r[u];if((0,p.pC)(t.vertexAttributes.uv)){const u=new Float32Array(t.vertexAttributes.uv),g=4*o*2,m=[0,1,1,1,1,0,0,0];for(let h=0;h<m.length;h++)u[g+h]=m[h];t.vertexAttributes.uv=u}return t.components=[new G.Z({faces:i,material:e.material}),new G.Z({faces:a})],t}(e,n.imageFace):e}static createSphere(t,n){return t instanceof S.Z?new P(et(function fe(t=0){const n=Math.round(8*2**t),e=2*n,r=(n-1)*(e+1)+2*e,o=new Float64Array(3*r),s=new Float32Array(3*r),i=new Float32Array(2*r),a=new Uint32Array((n-1)*e*2*3);let f=0,c=0,u=0,g=0;for(let m=0;m<=n;m++){const h=m/n*Math.PI+.5*Math.PI,w=Math.cos(h),L=Math.sin(h);x[2]=L;const C=0===m||m===n,E=C?e-1:e;for(let F=0;F<=E;F++){const O=F/E*2*Math.PI;x[0]=-Math.sin(O)*w,x[1]=Math.cos(O)*w;for(let D=0;D<3;D++)o[f]=.5*x[D],s[f]=x[D],++f;i[c++]=(F+(C?.5:0))/e,i[c++]=m/n,0!==m&&F!==e&&(m!==n&&(a[u++]=g,a[u++]=g+1,a[u++]=g-e),1!==m&&(a[u++]=g,a[u++]=g-e,a[u++]=g-e-1)),g++}}return{position:o,normal:s,uv:i,faces:a}}(n&&n.densificationFactor||0),t,n)):(R.error(".createSphere()","expected location to be a Point instance"),null)}static createCylinder(t,n){return t instanceof S.Z?new P(et(function pe(t=0){const e=Math.round(16*2**t),r=4*(e+1)+2*e,o=new Float64Array(3*r),s=new Float32Array(3*r),i=new Float32Array(2*r),a=new Uint32Array(4*e*3);let f=0,c=0,u=0,g=0,m=0;for(let h=0;h<=5;h++){const w=0===h||5===h,L=h<=1||h>=4,C=2===h||4===h,E=w?e-1:e;for(let F=0;F<=E;F++){const O=F/E*2*Math.PI,D=w?0:.5;x[0]=D*Math.sin(O),x[1]=D*-Math.cos(O),x[2]=h<=2?.5:-.5;for(let Q=0;Q<3;Q++)o[f++]=x[Q],s[c++]=L?2===Q?h<=1?1:-1:0:2===Q?0:x[Q]/D;i[u++]=(F+(w?.5:0))/e,i[u++]=h<=1?1*h/3:h<=3?1*(h-2)/3+1/3:1*(h-4)/3+2/3,C||0===h||F===e||(5!==h&&(a[g++]=m,a[g++]=m+1,a[g++]=m-e),1!==h&&(a[g++]=m,a[g++]=m-e,a[g++]=m-e-1)),m++}}return{position:o,normal:s,uv:i,faces:a}}(n&&n.densificationFactor||0),t,n)):(R.error(".createCylinder()","expected location to be a Point instance"),null)}static createPlane(t,n){if(!(t instanceof S.Z))return R.error(".createPlane()","expected location to be a Point instance"),null;const e=n?.facing??"up",r=function ue(t,n){const e="number"==typeof n?n:null!=n?n.width:1,r="number"==typeof n?n:null!=n?n.height:1;switch(t){case"up":case"down":return{width:e,depth:r};case"north":case"south":return{width:e,height:r};case"east":case"west":return{depth:e,height:r}}}(e,n?.size);return new P(et(function he(t){const n=k.facingAxisOrderSwap[t],e=k.position,r=k.normal,o=new Float64Array(e.length),s=new Float32Array(r.length);let i=0;for(let a=0;a<4;a++){const f=i;for(let c=0;c<3;c++){const u=n[c],g=Math.abs(u)-1,m=u>=0?1:-1;o[i]=e[f+g]*m,s[i]=r[f+g]*m,i++}}return{position:o,normal:s,uv:new Float32Array(k.uv),faces:new Uint32Array(k.faces),isPlane:!0}}(e),t,{...n,size:r}))}static createFromPolygon(t,n){if(!(t instanceof Wt.Z))return R.error(".createFromPolygon()","expected polygon to be a Polygon instance"),null;const e=(0,Ht.bT)(t);return new P({vertexAttributes:new _.Q({position:e.position}),components:[new G.Z({faces:e.faces,shading:"flat",material:n&&n.material||null})],spatialReference:t.spatialReference})}static createFromGLTF(t,n,e){return(0,U.Z)(function*(){if(!(t instanceof S.Z))throw R.error(".createfromGLTF()","expected location to be a Point instance"),new it.Z("invalid-input","Expected location to be a Point instance");const{loadGLTFMesh:r}=yield(0,j.Hl)(l.e(9185).then(l.bind(l,29185)),e);return new P(yield r(t,n,e))})()}static createWithExternalSource(t,n,e){const r=e?.extent??null,o=e?.transform.clone()??new q.Z;return o.origin=[t.x,t.y,t.z??0],new P({external:{source:n,extent:r},transform:o,spatialReference:t.spatialReference})}static createIncomplete(t,n){const e=n?.transform.clone()??new q.Z;e.origin=[t.x,t.y,t.z??0];const o=new P({transform:e,spatialReference:t.spatialReference});return o.addResolvingPromise(Promise.reject(new it.Z("mesh-incomplete","Mesh resources are not complete"))),o}};(0,M._)([(0,Z.Cb)({type:[G.Z],json:{write:!0}})],b.prototype,"components",void 0),(0,M._)([(0,Z.Cb)({type:q.Z,json:{write:!0}})],b.prototype,"transform",void 0),(0,M._)([(0,Z.Cb)({constructOnly:!0})],b.prototype,"external",void 0),(0,M._)([(0,Z.Cb)({readOnly:!0})],b.prototype,"hasExtent",null),(0,M._)([(0,Z.Cb)({readOnly:!0})],b.prototype,"boundingInfo",null),(0,M._)([(0,Z.Cb)({readOnly:!0})],b.prototype,"anchor",null),(0,M._)([(0,Z.Cb)({readOnly:!0})],b.prototype,"origin",null),(0,M._)([(0,Z.Cb)({readOnly:!0,json:{read:!1}})],b.prototype,"extent",null),(0,M._)([(0,Z.Cb)({readOnly:!0,json:{read:!1,write:!0,default:!0}})],b.prototype,"hasZ",void 0),(0,M._)([(0,Z.Cb)({readOnly:!0,json:{read:!1,write:!0,default:!1}})],b.prototype,"hasM",void 0),(0,M._)([(0,Z.Cb)({type:_.Q,nonNullable:!0,json:{write:!0}})],b.prototype,"vertexAttributes",void 0),b=P=(0,M._)([(0,$t.j)("esri.geometry.Mesh")],b);const gt={x:(0,d.f)(1,0,0),y:(0,d.f)(0,1,0),z:(0,d.f)(0,0,1)},J=(0,A.Ue)(),Lt=(0,A.Ue)(),Ut=(0,A.Ue)(),rt=(0,d.c)(),Tt=b;var N,ot,t;(t=N||(N={})).featureGUID="featureGUID",t.assetName="assetName",t.hash="hash",t.type="type",t.conversionStatus="conversionStatus",t.flags="flags",t.complexity="complexity",t.size="size",t.seqNo="seqNo",t.sourceHash="sourceHash",t.assetURL="assetURL",function(t){t.SUBMITTED="SUBMITTED",t.INPROGRESS="INPROGRESS",t.FAILED="FAILED",t.COMPLETED="COMPLETED"}(ot||(ot={}));var z,Ze=l(17253);function Pe(t,n,e){const r=e.features;e.features=[],delete e.geometryType;const o=Ze.default.fromJSON(e);o.geometryType="mesh";const s=o.spatialReference,i=(0,p.Wi)(t.outFields)||!t.outFields.length?()=>({}):function Ee(t){return({attributes:n})=>{if(!n)return{};if(!t)return n;for(const e in n)t.has(e)||delete n[e];return n}}(t.outFields.includes("*")?null:new Set(t.outFields));for(const a of r){const f=Oe(a,s,n);(0,p.pC)(f)&&o.features.push(new zt.Z({geometry:f,attributes:i(a)}))}return o}function Oe(t,n,e){const{status:r,source:o}=function Le(t){if(!t.assetMappings)return{status:z.FAILED};const n=[],e=new Map;for(const r of t.assetMappings){const o=r[N.seqNo],s=r[N.assetName],i=r[N.assetURL],a=r[N.conversionStatus];if(a===ot.FAILED)return{status:z.FAILED};if(a!==ot.COMPLETED)return{status:z.PENDING};if(null==o)n.push({name:s,source:i});else{const f=e.get(s);let c;f?c=f.multipart:(c=[],n.push({name:s,source:{multipart:c}}),e.set(s,{multipart:c})),c[o]=i}}return{status:z.COMPLETED,source:n}}(t);if(r===z.FAILED)return null;const s=function Se({attributes:t},n,{transformFieldRoles:e}){return new S.Z({x:t[e.originX],y:t[e.originY],z:t[e.originZ],spatialReference:n})}(t,n,e),i=st.Z.fromJSON(t.geometry);i.spatialReference=n;const a=function Ie({attributes:t,assetMappings:n},{transformFieldRoles:e}){return new q.Z({translation:[t[e.translationX],t[e.translationY],t[e.translationZ]],rotation:(0,A.uT)([t[e.rotationX],t[e.rotationY],t[e.rotationZ]],t[e.rotationDeg]),scale:[t[e.scaleX],t[e.scaleY],t[e.scaleZ]],geographic:!n[N.flags]?.includes("PROJECT_VERTICES")})}(t,e);return r===z.PENDING?Tt.createIncomplete(s,{extent:i,transform:a}):Tt.createWithExternalSource(s,o,{extent:i,transform:a})}!function(t){t[t.FAILED=0]="FAILED",t[t.PENDING=1]="PENDING",t[t.COMPLETED=2]="COMPLETED"}(z||(z={}))}}]);