/*
Copyright 2022 Comcast Cable Communications Management, LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
"use strict";(self.webpackChunka_porrtal_io_app=self.webpackChunka_porrtal_io_app||[]).push([[3678],{986:(ve,fe,at)=>{at.d(fe,{E:()=>Dt});const yt=new(at(6879).Z);function Dt(Bt){if(!yt.hasBidiChar(Bt))return[Bt,!1];let se;return se="rtl"===yt.checkContextual(Bt)?"IDNNN":"ICNNN",[yt.bidiTransform(Bt,se,"VLYSN"),!0]}},17002:(ve,fe,at)=>{at.d(fe,{BN:()=>Lt,mx:()=>zt});var At=at(15861),yt=at(59318);const $=new Map;function zt(et){return pt.apply(this,arguments)}function pt(){return(pt=(0,At.Z)(function*(et){const _t=dt(et);let Nt=$.get(_t);if(Nt)return Nt;const nt=new FontFace(et.family,`url('${yt.Z.fontsUrl}/woff2/${_t}.woff2') format('woff2')`),Ut=document.fonts;return Ut.has(nt)&&"loading"===nt.status?nt.loaded:(Nt=nt.load(),$.set(_t,Nt),Ut.add(nt),Nt)})).apply(this,arguments)}function Lt(et){if(!et)return"arial-unicode-ms";const _t=et.toLowerCase().split(" ").join("-");switch(_t){case"serif":return"noto-serif";case"sans-serif":return"arial-unicode-ms";case"monospace":return"ubuntu-mono";case"fantasy":return"cabin-sketch";case"cursive":return"redressed";default:return _t}}function dt(et){const _t=function Kt(et){if(!et.weight)return"";switch(et.weight.toLowerCase()){case"bold":case"bolder":return"-bold"}return""}(et)+function Zt(et){if(!et.style)return"";switch(et.style.toLowerCase()){case"italic":case"oblique":return"-italic"}return""}(et);return Lt(et.family)+(_t.length>0?_t:"-regular")}},72283:(ve,fe,at)=>{at.d(fe,{GP:()=>Bt,QK:()=>nt,XV:()=>Nt,hh:()=>_t,ov:()=>et,qh:()=>Xt,v1:()=>jt,wp:()=>Zt,zY:()=>Wt,zv:()=>Ut});var At=at(58817),yt=at(91179),Dt=at(97373);function Bt(Q){const Pt=(0,At.d9)(Q);return function Kt(Q){Q&&((0,yt.oU)(Q)?Tt(Q.rings):(0,yt.l9)(Q)?Tt(Q.paths):(0,yt.aW)(Q)&&dt(Q.points),se(Q))}(Pt),Pt}function se(Q){Q&&((0,yt.wp)(Q)?Q.y=-Q.y:(0,yt.oU)(Q)?zt(Q.rings):(0,yt.l9)(Q)?zt(Q.paths):(0,yt.aW)(Q)&&$(Q.points))}function $(Q){if(Q){const Pt=Q.length;for(let bt=0;bt<Pt;bt++)Q[bt][1]=-Q[bt][1]}}function zt(Q){if(Q)for(const Pt of Q)$(Pt)}function pt(Q){if(Q)for(let Pt=Q.length-1;Pt>0;--Pt)Q[Pt][0]-=Q[Pt-1][0],Q[Pt][1]-=Q[Pt-1][1]}function Lt(Q){if(Q)for(const Pt of Q)pt(Pt)}function dt(Q){if(Q){const Pt=Q.length;for(let bt=1;bt<Pt;++bt)Q[bt][0]+=Q[bt-1][0],Q[bt][1]+=Q[bt-1][1]}}function Tt(Q){if(Q)for(const Pt of Q)dt(Pt)}function Zt(Q){Q&&(se(Q),(0,yt.oU)(Q)?Lt(Q.rings):(0,yt.l9)(Q)?Lt(Q.paths):(0,yt.aW)(Q)&&pt(Q.points))}function et(Q){if(Q)for(const Pt of Q)_t(Pt)}function _t(Q){Q&&Q.reverse()}function Nt(Q,Pt,bt){return[Q[0]+(Pt[0]-Q[0])*bt,Q[1]+(Pt[1]-Q[1])*bt]}function nt(Q){return!(!Q||0===Q.length)&&Q[0][0]===Q[Q.length-1][0]&&Q[0][1]===Q[Q.length-1][1]}function Ut(Q){return Q[4]}function Xt(Q,Pt){Q[4]=Pt}class jt{constructor(Pt,bt,rt,ut=0){this.isClosed=!1,this.multiPath=null,this.acceptPolygon=bt,this.acceptPolyline=rt,this.geomUnitsPerPoint=ut,this.pathCount=-1,this.pathIndex=-1,this.iteratePath=!1,Pt&&((0,yt.oU)(Pt)?bt&&(this.multiPath=Pt.rings,this.isClosed=!0):(0,yt.l9)(Pt)?rt&&(this.multiPath=Pt.paths,this.isClosed=!1):(0,yt.YX)(Pt)&&bt&&(this.multiPath=te(Pt).rings,this.isClosed=!0),this.multiPath&&(this.pathCount=this.multiPath.length)),this.internalPlacement=new Dt.u}next(){if(!this.multiPath)return null;for(;this.iteratePath||this.pathIndex<this.pathCount-1;){this.iteratePath||this.pathIndex++;const Pt=this.processPath(this.multiPath[this.pathIndex]);if(Pt)return Pt}return this.pathCount=-1,this.pathIndex=-1,this.multiPath=null,null}}class Wt{constructor(Pt,bt,rt,ut=0){this.isClosed=!1,this.multiPath=null,this.inputGeometries=Pt,this.acceptPolygon=bt,this.acceptPolyline=rt,this.geomUnitsPerPoint=ut,this.pathCount=-1,this.pathIndex=-1,this.iteratePath=!1}next(){for(;;){if(!this.multiPath){let Pt=this.inputGeometries.next();for(;Pt;){if((0,yt.oU)(Pt)?this.acceptPolygon&&(this.multiPath=Pt.rings,this.isClosed=!0):(0,yt.l9)(Pt)?this.acceptPolyline&&(this.multiPath=Pt.paths,this.isClosed=!1):(0,yt.YX)(Pt)&&this.acceptPolygon&&(this.multiPath=te(Pt).rings,this.isClosed=!0),this.multiPath){this.pathCount=this.multiPath.length,this.pathIndex=-1;break}Pt=this.inputGeometries.next()}if(!this.multiPath)return null}for(;this.iteratePath||this.pathIndex<this.pathCount-1;){this.iteratePath||this.pathIndex++;const Pt=this.processPath(this.multiPath[this.pathIndex]);if(Pt)return Pt}this.pathCount=-1,this.pathIndex=-1,this.multiPath=null}}}function te(Q){return{rings:[[[Q.xmin,Q.ymin],[Q.xmin,Q.ymax],[Q.xmax,Q.ymax],[Q.xmax,Q.ymin],[Q.xmin,Q.ymin]]]}}},29214:(ve,fe,at)=>{at.d(fe,{M:()=>yt}),at(58817);class yt{constructor(se){this._geometry=se}next(){const se=this._geometry;return this._geometry=null,se}}},95727:(ve,fe,at)=>{at.d(fe,{h:()=>Ae,W:()=>Ie});var At=at(58817),yt=at(91179),Dt=at(72283);let Bt=(()=>{class S{static local(){return null===S.instance&&(S.instance=new S),S.instance}execute(i,r,x,y){return new se(i,r,x)}}return S.instance=null,S})();class se{constructor(e,i,r){this._inputGeometries=e,this._angleTolerance=void 0!==i.angleTolerance?i.angleTolerance:120,this._maxCosAngle=Math.cos((1-Math.abs(this._angleTolerance)/180)*Math.PI)}next(){let e=this._inputGeometries.next();for(;e;){if((0,yt.oU)(e)){this._isClosed=!0;const i=(0,At.d9)(e);return this._processMultipath(i.rings),i}if((0,yt.l9)(e)){this._isClosed=!1;const i=(0,At.d9)(e);return this._processMultipath(i.paths),i}if((0,yt.YX)(e)){if(this._maxCosAngle)return e;this._isClosed=!0;const i=[[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]];return this._processPath(i),{rings:[i]}}e=this._inputGeometries.next()}return null}_processMultipath(e){if(e)for(const i of e)this._processPath(i)}_processPath(e){if(e){let i,r,x,y,a,P,b=e.length,w=e[0];this._isClosed&&++b;for(let L=1;L<b;++L){let A;A=this._isClosed&&L===b-1?e[0]:e[L];const ot=A[0]-w[0],lt=A[1]-w[1],gt=Math.sqrt(ot*ot+lt*lt);L>1&&gt>0&&x>0&&(i*ot+r*lt)/gt/x<=this._maxCosAngle&&(0,Dt.qh)(w,1),1===L&&(y=ot,a=lt,P=gt),gt>0&&(w=A,i=ot,r=lt,x=gt)}this._isClosed&&x>0&&P>0&&(i*y+r*a)/P/x<=this._maxCosAngle&&(0,Dt.qh)(e[0],1)}}}var $=at(7547);const zt=.03;class pt{constructor(){this._path=[]}path(){return this._path}addPath(e,i){i||e.reverse(),Array.prototype.push.apply(this._path,e),i||e.reverse()}static mergePath(e,i){i&&Array.prototype.push.apply(e,i)}startPath(e){this._path.push(e)}lineTo(e){this._path.push(e)}close(){const e=this._path;e.length>1&&(e[0][0]===e[e.length-1][0]&&e[0][1]===e[e.length-1][1]||e.push([e[0][0],e[0][1]]))}}class Lt{constructor(e=0,i=!1){}normalize(e){const i=Math.sqrt(e[0]*e[0]+e[1]*e[1]);0!==i&&(e[0]/=i,e[1]/=i)}calculateLength(e,i){const r=i[0]-e[0],x=i[1]-e[1];return Math.sqrt(r*r+x*x)}calculateSegLength(e,i){return this.calculateLength(e[i],e[i+1])}calculatePathLength(e){let i=0;const r=e?e.length:0;for(let x=0;x<r-1;++x)i+=this.calculateSegLength(e,x);return i}calculatePathArea(e){let i=0;const r=e?e.length:0;for(let x=0;x<r-1;++x)i+=(e[x+1][0]-e[x][0])*(e[x+1][1]+e[x][1]);return i/2}getCoord2D(e,i,r){return[e[0]+(i[0]-e[0])*r,e[1]+(i[1]-e[1])*r]}getSegCoord2D(e,i,r){return this.getCoord2D(e[i],e[i+1],r)}getAngle(e,i,r){return Math.atan2(i[1]-e[1],i[0]-e[0])}getSegAngle(e,i,r){return this.getAngle(e[i],e[i+1],r)}getAngleCS(e,i,r){const x=i[0]-e[0],y=i[1]-e[1],a=Math.sqrt(x*x+y*y);return a>0?[x/a,y/a]:[1,0]}getSegAngleCS(e,i,r){return this.getAngleCS(e[i],e[i+1],r)}cut(e,i,r,x){return[r<=0?e[i]:this.getSegCoord2D(e,i,r),x>=1?e[i+1]:this.getSegCoord2D(e,i,x)]}addSegment(e,i,r){r&&e.push(i[0]),e.push(i[1])}getSubCurve(e,i,r){const x=[];return this.appendSubCurve(x,e,i,r)?x:null}appendSubCurve(e,i,r,x){const y=i?i.length-1:0;let a=0,P=!0,b=0;for(;b<y;){const w=this.calculateSegLength(i,b);if(0!==w){if(P){if(a+w>r){let A=1,ot=!1;a+w>=x&&(A=(x-a)/w,ot=!0);const lt=this.cut(i,b,(r-a)/w,A);if(lt&&this.addSegment(e,lt,P),ot)break;P=!1}}else{if(a+w>x){const L=this.cut(i,b,0,(x-a)/w);L&&this.addSegment(e,L,P);break}this.addSegment(e,[i[b],i[b+1]],P)}a+=w,++b}else++b}return!0}getCIMPointAlong(e,i){const r=e?e.length-1:0;let x=0,y=-1;for(;y<r;){++y;const a=this.calculateSegLength(e,y);if(0!==a){if(x+a>i)return this.getCoord2D(e[y],e[y+1],(i-x)/a);x+=a}}return null}isEmpty(e,i){if(!e||e.length<=1)return!0;const r=e?e.length-1:0;let x=-1;for(;x<r;)if(++x,e[x+1][0]!==e[x][0]||e[x+1][1]!==e[x][1]||i&&e[x+1][2]!==e[x][2])return!1;return!0}offset(e,i,r,x,y){if(!e||e.length<2)return null;let a=0,P=e[a++],b=a;for(;a<e.length;){const ot=e[a];ot[0]===P[0]&&ot[1]===P[1]||(a!==b&&(e[b]=e[a]),P=e[b++]),a++}const w=e[0][0]===e[b-1][0]&&e[0][1]===e[b-1][1];if(w&&--b,b<(w?3:2))return null;const L=[];P=w?e[b-1]:null;let A=e[0];for(let ot=0;ot<b;ot++){const lt=ot===b-1?w?e[0]:null:e[ot+1];if(P)if(lt){const gt=[lt[0]-A[0],lt[1]-A[1]];this.normalize(gt);const xt=[A[0]-P[0],A[1]-P[1]];this.normalize(xt);const Et=xt[0]*gt[1]-xt[1]*gt[0],Yt=xt[0]*gt[0]+xt[1]*gt[1];if(0===Et&&1===Yt){A=lt;continue}if(Et>=0==i<=0){if(Yt<1){const ae=[gt[0]-xt[0],gt[1]-xt[1]];this.normalize(ae);const ce=Math.sqrt((1+Yt)/2);if(ce>1/x){const qt=-Math.abs(i)/ce;L.push([A[0]-ae[0]*qt,A[1]-ae[1]*qt])}}}else switch(r){case $.id.Mitered:{const ae=Math.sqrt((1+Yt)/2);if(ae>0&&1/ae<x){const ce=[gt[0]-xt[0],gt[1]-xt[1]];this.normalize(ce);const qt=Math.abs(i)/ae;L.push([A[0]-ce[0]*qt,A[1]-ce[1]*qt]);break}}case $.id.Bevelled:L.push([A[0]+xt[1]*i,A[1]-xt[0]*i]),L.push([A[0]+gt[1]*i,A[1]-gt[0]*i]);break;case $.id.Rounded:if(Yt<1){L.push([A[0]+xt[1]*i,A[1]-xt[0]*i]);const ae=Math.floor(2.5*(1-Yt));if(ae>0){const ce=1/ae;let qt=ce;for(let Oe=1;Oe<ae;Oe++,qt+=ce){const ze=[xt[1]*(1-qt)+gt[1]*qt,-xt[0]*(1-qt)-gt[0]*qt];this.normalize(ze),L.push([A[0]+ze[0]*i,A[1]+ze[1]*i])}}L.push([A[0]+gt[1]*i,A[1]-gt[0]*i])}break;default:if(Et<0)L.push([A[0]+(xt[1]+xt[0])*i,A[1]+(xt[1]-xt[0])*i]),L.push([A[0]+(gt[1]-gt[0])*i,A[1]-(gt[0]+gt[1])*i]);else{const ae=Math.sqrt((1+Math.abs(Yt))/2),ce=[gt[0]-xt[0],gt[1]-xt[1]];this.normalize(ce);const qt=i/ae;L.push([A[0]-ce[0]*qt,A[1]-ce[1]*qt])}}}else{const gt=[A[0]-P[0],A[1]-P[1]];this.normalize(gt),L.push([A[0]+gt[1]*i,A[1]-gt[0]*i])}else{const gt=[lt[0]-A[0],lt[1]-A[1]];this.normalize(gt),L.push([A[0]+gt[1]*i,A[1]-gt[0]*i])}P=A,A=lt}return L.length<(w?3:2)?null:(w&&L.push([L[0][0],L[0][1]]),L)}}const dt=1.7320508075688772,Kt=$.TF.OpenEnded;let Zt=(()=>{class S{static local(){return null===S.instance&&(S.instance=new S),S.instance}execute(i,r,x,y){return new et(i,r,x)}}return S.instance=null,S})();class et extends Dt.zY{constructor(e,i,r){super(e,!1,!0),this._curveHelper=new Lt,this._width=(void 0!==i.width?i.width:5)*r,this._arrowType=void 0!==i.geometricEffectArrowType?i.geometricEffectArrowType:void 0!==i.arrowType?i.arrowType:Kt,this._offsetFlattenError=zt*r}processPath(e){switch(this._arrowType){case $.TF.OpenEnded:default:return this._constructSimpleArrow(e,!0);case $.TF.Block:return this._constructSimpleArrow(e,!1);case $.TF.Crossed:return this._constructCrossedArrow(e)}}_constructSimpleArrow(e,i){const r=this._curveHelper.calculatePathLength(e);let x=this._width;r<2*x&&(x=r/2);const y=this._curveHelper.getSubCurve(e,0,r-x);if(!y)return null;const a=x/2;if(this._curveHelper.isEmpty(y,!1))return null;const P=this._constructOffset(y,-a);if(!P)return null;const b=this._constructOffset(y,a);if(!b)return null;const w=this._constructArrowBasePoint(P,-a/2);if(!w)return null;const L=this._constructArrowBasePoint(b,a/2);if(!L)return null;const A=e[e.length-1];i||(this._makeControlPoint(b,!0),this._makeControlPoint(P,!0));const ot=new pt;return ot.addPath(b,!0),ot.lineTo(L),this._makeControlPoint(ot.path()),ot.lineTo(A),this._makeControlPoint(ot.path()),ot.lineTo(w),this._makeControlPoint(ot.path()),ot.addPath(P,!1),i?{paths:[ot.path()]}:(ot.close(),{rings:[ot.path()]})}_constructCrossedArrow(e){const i=this._curveHelper.calculatePathLength(e);let r=this._width;i<r*(1+dt+1)&&(r=i/(1+dt+1));const x=this._curveHelper.getSubCurve(e,0,i-r*(1+dt));if(!x)return null;const y=r/2;if(this._curveHelper.isEmpty(x,!1))return null;const a=this._constructOffset(x,y);if(!a)return null;const P=this._constructOffset(x,-y);if(!P)return null;const b=this._curveHelper.getSubCurve(e,0,i-r);if(!b||this._curveHelper.isEmpty(b,!1))return null;const w=this._constructOffset(b,y);if(!w)return null;const L=this._constructOffset(b,-y);if(!L)return null;const A=w[w.length-1],ot=this._constructArrowBasePoint(w,y/2);if(!ot)return null;const lt=L[L.length-1],gt=this._constructArrowBasePoint(L,-y/2);if(!gt)return null;const xt=e[e.length-1];this._makeControlPoint(a,!1),this._makeControlPoint(P,!1);const Et=new pt;return Et.addPath(a,!0),this._makeControlPoint(Et.path()),Et.lineTo(lt),Et.lineTo(gt),this._makeControlPoint(Et.path()),Et.lineTo(xt),this._makeControlPoint(Et.path()),Et.lineTo(ot),this._makeControlPoint(Et.path()),Et.lineTo(A),this._makeControlPoint(Et.path()),Et.addPath(P,!1),{paths:[Et.path()]}}_constructOffset(e,i){return this._curveHelper.offset(e,i,$.id.Rounded,4,this._offsetFlattenError)}_constructArrowBasePoint(e,i){if(!e||e.length<2)return null;const r=e[e.length-2],x=e[e.length-1],y=[x[0]-r[0],x[1]-r[1]];return this._curveHelper.normalize(y),[x[0]+y[1]*i,x[1]-y[0]*i]}_makeControlPoint(e,i=!1){(0,Dt.qh)(i?e[0]:e[e.length-1],1)}}let _t=(()=>{class S{static local(){return null===S.instance&&(S.instance=new S),S.instance}execute(i,r,x,y){return new Nt(i,r,x,y)}}return S.instance=null,S})();class Nt{constructor(e,i,r,x){this._inputGeometries=e,this._curveHelper=new Lt,this._size=(void 0!==i.size?i.size:1)*r,this._offsetFlattenError=zt*r}next(){let e=this._inputGeometries.next();for(;e;){if((0,yt.YX)(e))if(this._size>0){const r=this._curveHelper.offset([[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]],this._size,$.id.Rounded,4,this._offsetFlattenError);if(r)return{rings:[r]}}else{if(!(this._size<0))return e;if(Math.min(e.xmax-e.xmin,e.ymax-e.ymin)+2*this._size>0)return{xmin:e.xmin-this._size,xmax:e.xmax+this._size,ymin:e.ymin-this._size,ymax:e.ymax+this._size}}if((0,yt.oU)(e)){if(0===this._size)return e;const i=[];for(const r of e.rings){const x=this._curveHelper.offset(r,this._size,$.id.Rounded,4,this._offsetFlattenError);x&&i.push(x)}if(i.length)return{rings:i}}if((0,yt.l9)(e)&&this._size>0){const i=[];for(const r of e.paths)if(r&&r.length>1){const x=this._curveHelper.offset(r,this._size,$.id.Rounded,4,this._offsetFlattenError),y=this._curveHelper.offset(r,-this._size,$.id.Rounded,4,this._offsetFlattenError);if(x&&y){for(let a=y.length-1;a>=0;a--)x.push(y[a]);x.push([x[0][0],x[0][1]]),i.push(x)}}if(i.length)return{rings:i}}(0,yt.wp)(e),e=this._inputGeometries.next()}return null}}let nt=(()=>{class S{static local(){return null===S.instance&&(S.instance=new S),S.instance}execute(i,r,x,y){return new Ut(i,r,x)}}return S.instance=null,S})();class Ut{constructor(e,i,r){this._defaultPointSize=20,this._inputGeometries=e,this._geomUnitsPerPoint=r,this._rule=i.rule??$.Em.FullGeometry,this._defaultSize=this._defaultPointSize*r}next(){let e;for(;e=this._inputGeometries.next();){let i;if((0,yt.wp)(e)?i=this._processGeom([[[e.x,e.y]]]):(0,yt.aW)(e)?i=this._processGeom([e.points]):(0,yt.l9)(e)?i=this._processGeom(e.paths):(0,yt.oU)(e)&&(i=this._processGeom(e.rings)),i&&i.length)return{paths:i}}return null}_clone(e){return[e[0],e[1]]}_mid(e,i){return[(e[0]+i[0])/2,(e[1]+i[1])/2]}_mix(e,i,r,x){return[e[0]*i+r[0]*x,e[1]*i+r[1]*x]}_add(e,i){return[e[0]+i[0],e[1]+i[1]]}_add2(e,i,r){return[e[0]+i,e[1]+r]}_sub(e,i){return[e[0]-i[0],e[1]-i[1]]}_dist(e,i){return Math.sqrt((e[0]-i[0])*(e[0]-i[0])+(e[1]-i[1])*(e[1]-i[1]))}_norm(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1])}_normalize(e,i=1){const r=i/this._norm(e);e[0]*=r,e[1]*=r}_leftPerpendicular(e){const r=e[0];e[0]=-e[1],e[1]=r}_leftPerp(e){return[-e[1],e[0]]}_rightPerpendicular(e){const r=-e[0];e[0]=e[1],e[1]=r}_rightPerp(e){return[e[1],-e[0]]}_dotProduct(e,i){return e[0]*i[0]+e[1]*i[1]}_crossProduct(e,i){return e[0]*i[1]-e[1]*i[0]}_rotateDirect(e,i,r){const y=e[0]*r+e[1]*i;e[0]=e[0]*i-e[1]*r,e[1]=y}_makeCtrlPt(e){const i=[e[0],e[1]];return(0,Dt.qh)(i,1),i}_addAngledTicks(e,i,r,x){const y=this._sub(r,i);this._normalize(y);const a=this._crossProduct(y,this._sub(x,i));let P;P=a>0?this._rightPerp(y):this._leftPerp(y);const b=Math.abs(a)/2,w=[];w.push([i[0]+(P[0]-y[0])*b,i[1]+(P[1]-y[1])*b]),w.push(i),w.push(r),w.push([r[0]+(P[0]+y[0])*b,r[1]+(P[1]+y[1])*b]),e.push(w)}_addBezier2(e,i,r,x,y){if(0==y--)return void e.push(x);const a=this._mid(i,r),P=this._mid(r,x),b=this._mid(a,P);this._addBezier2(e,i,a,b,y),this._addBezier2(e,b,P,x,y)}_addBezier3(e,i,r,x,y,a){if(0==a--)return void e.push(y);const P=this._mid(i,r),b=this._mid(r,x),w=this._mid(x,y),L=this._mid(P,b),A=this._mid(b,w),ot=this._mid(L,A);this._addBezier3(e,i,P,L,ot,a),this._addBezier3(e,ot,A,w,y,a)}_add90DegArc(e,i,r,x,y){const a=y??this._crossProduct(this._sub(r,i),this._sub(x,i))>0,P=this._mid(i,r),b=this._sub(P,i);a?this._leftPerpendicular(b):this._rightPerpendicular(b),P[0]+=b[0],P[1]+=b[1],this._addBezier3(e,i,this._mix(i,.33333,P,.66667),this._mix(r,.33333,P,.66667),r,4)}_addArrow(e,i,r){const x=i[0],y=i[1],a=i[i.length-1],P=this._sub(x,y);this._normalize(P);const b=this._crossProduct(P,this._sub(a,y)),w=.5*b,L=this._leftPerp(P),A=[a[0]-L[0]*b,a[1]-L[1]*b],ot=i.length-1,lt=[];lt.push(r?[-L[0],-L[1]]:L);let gt=[-P[0],-P[1]];for(let xt=1;xt<ot-1;xt++){const Et=this._sub(i[xt+1],i[xt]);this._normalize(Et);const Yt=this._dotProduct(Et,gt),ae=this._crossProduct(Et,gt),ce=Math.sqrt((1+Yt)/2),qt=this._sub(Et,gt);this._normalize(qt),qt[0]/=ce,qt[1]/=ce,lt.push(ae<0?[-qt[0],-qt[1]]:qt),gt=Et}lt.push(this._rightPerp(gt));for(let xt=lt.length-1;xt>0;xt--)e.push([i[xt][0]+lt[xt][0]*w,i[xt][1]+lt[xt][1]*w]);e.push([A[0]+lt[0][0]*w,A[1]+lt[0][1]*w]),e.push([A[0]+lt[0][0]*b,A[1]+lt[0][1]*b]),e.push(x),e.push([A[0]-lt[0][0]*b,A[1]-lt[0][1]*b]),e.push([A[0]-lt[0][0]*w,A[1]-lt[0][1]*w]);for(let xt=1;xt<lt.length;xt++)e.push([i[xt][0]-lt[xt][0]*w,i[xt][1]-lt[xt][1]*w])}_cp2(e,i,r){return e.length>=2?e[1]:this._add2(e[0],i*this._defaultSize,r*this._defaultSize)}_cp3(e,i,r,x){if(e.length>=3)return e[2];const y=this._mix(e[0],1-r,i,r),a=this._sub(i,e[0]);return this._normalize(a),this._rightPerpendicular(a),[y[0]+a[0]*x*this._defaultSize,y[1]+a[1]*x*this._defaultSize]}_arrowPath(e){if(e.length>2)return e;const i=e[0],r=this._cp2(e,-4,0),x=this._sub(i,r);this._normalize(x);const y=this._rightPerp(x);return[i,r,[i[0]+(y[0]-x[0])*this._defaultSize,i[1]+(y[1]-x[1])*this._defaultSize]]}_arrowLastSeg(e){const i=e[0],r=this._cp2(e,-4,0);let x;if(e.length>=3)x=e[e.length-1];else{const y=this._sub(i,r);this._normalize(y);const a=this._rightPerp(y);x=[i[0]+(a[0]-y[0])*this._defaultSize,i[1]+(a[1]-y[1])*this._defaultSize]}return[r,x]}_processGeom(e){if(!e)return null;const i=[];for(const r of e){if(!r||0===r.length)continue;const x=r.length;let y=r[0];switch(this._rule){case $.Em.PerpendicularFromFirstSegment:{const a=this._cp2(r,0,-1),P=this._cp3(r,a,.5,4),b=[];b.push(P),b.push(this._mid(y,a)),i.push(b);break}case $.Em.ReversedFirstSegment:{const a=this._cp2(r,0,-1);i.push([a,y]);break}case $.Em.PerpendicularToSecondSegment:{const a=this._cp2(r,-4,1),P=this._cp3(r,a,.882353,-1.94),b=[];b.push(this._mid(a,P)),b.push(y),i.push(b);break}case $.Em.SecondSegmentWithTicks:{const a=this._cp2(r,-4,1),P=this._cp3(r,a,.882353,-1.94),b=this._sub(P,a);let w;w=this._crossProduct(b,this._sub(y,a))>0?this._rightPerp(w):this._leftPerp(b);const L=[];L.push([a[0]+(w[0]-b[0])/3,a[1]+(w[1]-b[1])/3]),L.push(a),L.push(P),L.push([P[0]+(w[0]+b[0])/3,P[1]+(w[1]+b[1])/3]),i.push(L);break}case $.Em.DoublePerpendicular:{const a=this._cp2(r,0,-1),P=this._cp3(r,a,.5,3),b=this._mid(y,a),w=this._sub(b,P);this._normalize(w);const L=this._crossProduct(w,this._sub(y,P));this._leftPerpendicular(w);const A=[];A.push(y),A.push([P[0]+w[0]*L,P[1]+w[1]*L]),i.push(A);const ot=[];ot.push([P[0]-w[0]*L,P[1]-w[1]*L]),ot.push(a),i.push(ot);break}case $.Em.OppositeToFirstSegment:{const a=this._cp2(r,0,-1),P=this._cp3(r,a,.5,3),b=this._mid(y,a),w=this._sub(b,P);this._normalize(w);const L=this._crossProduct(w,this._sub(y,P));this._leftPerpendicular(w);const A=[];A.push([P[0]+w[0]*L,P[1]+w[1]*L]),A.push([P[0]-w[0]*L,P[1]-w[1]*L]),i.push(A);break}case $.Em.TriplePerpendicular:{const a=this._cp2(r,0,-1),P=this._cp3(r,a,.5,4),b=this._mid(y,a),w=this._sub(b,P);this._normalize(w);const L=this._crossProduct(w,this._sub(y,P));this._leftPerpendicular(w);const A=[];A.push([P[0]+w[0]*L*.8,P[1]+w[1]*L*.8]),A.push([b[0]+.8*(y[0]-b[0]),b[1]+.8*(y[1]-b[1])]),i.push(A),i.push([P,b]);const ot=[];ot.push([P[0]-w[0]*L*.8,P[1]-w[1]*L*.8]),ot.push([b[0]+.8*(a[0]-b[0]),b[1]+.8*(a[1]-b[1])]),i.push(ot);break}case $.Em.HalfCircleFirstSegment:{const a=this._cp2(r,0,-1),P=this._cp3(r,a,.5,4),b=this._mid(y,a);let w=this._sub(a,y);const L=Math.cos(Math.PI/18),A=Math.sin(Math.PI/18),ot=Math.sqrt((1+L)/2),lt=Math.sqrt((1-L)/2),gt=[];let xt;this._crossProduct(w,this._sub(P,y))>0?(gt.push(y),w=this._sub(y,b),xt=a):(gt.push(a),w=this._sub(a,b),xt=y),this._rotateDirect(w,ot,lt),w[0]/=ot,w[1]/=ot;for(let Et=1;Et<=18;Et++)gt.push(this._add(b,w)),this._rotateDirect(w,L,A);gt.push(xt),i.push(gt);break}case $.Em.HalfCircleSecondSegment:{const a=this._cp2(r,0,-1),P=this._cp3(r,a,1,-1);let b=this._sub(y,a);this._normalize(b);const w=this._crossProduct(b,this._sub(P,a))/2;this._leftPerpendicular(b);const L=[a[0]+b[0]*w,a[1]+b[1]*w];b=this._sub(a,L);const A=Math.cos(Math.PI/18);let ot=Math.sin(Math.PI/18);w>0&&(ot=-ot);const lt=[a];for(let gt=1;gt<=18;gt++)this._rotateDirect(b,A,ot),lt.push(this._add(L,b));i.push(lt);break}case $.Em.HalfCircleExtended:{const a=this._cp2(r,0,-2),P=this._cp3(r,a,1,-1);let b;if(x>=4)b=r[3];else{const gt=this._sub(y,a);b=this._add(P,gt)}const w=this._dist(a,P)/2/.75,L=this._sub(a,y);this._normalize(L,w);const A=this._sub(P,b);this._normalize(A,w),i.push([b,P]);const lt=[this._clone(P)];this._addBezier3(lt,P,this._add(P,A),this._add(a,L),a,4),lt.push(y),i.push(lt);break}case $.Em.OpenCircle:{const a=this._cp2(r,-2,0),P=this._sub(a,y),b=Math.cos(Math.PI/18),w=-Math.sin(Math.PI/18),L=[a];for(let A=1;A<=33;A++)this._rotateDirect(P,b,w),L.push(this._add(y,P));i.push(L);break}case $.Em.CoverageEdgesWithTicks:{const a=this._cp2(r,0,-1);let P,b;if(x>=3)P=r[2];else{const ot=this._sub(a,y),lt=this._leftPerp(ot);P=[y[0]+lt[0]-.25*ot[0],y[1]+lt[1]-.25*ot[1]]}if(x>=4)b=r[3];else{const ot=this._mid(y,a),lt=this._sub(y,a);this._normalize(lt),this._leftPerpendicular(lt);const gt=this._crossProduct(lt,this._sub(P,ot));this._rightPerpendicular(lt),b=[P[0]+lt[0]*gt*2,P[1]+lt[1]*gt*2]}const w=this._sub(a,y);let L,A;L=this._crossProduct(w,this._sub(P,y))>0?this._rightPerp(w):this._leftPerp(w),A=[],A.push(P),A.push(y),A.push([y[0]+(L[0]-w[0])/3,y[1]+(L[1]-w[1])/3]),i.push(A),L=this._crossProduct(w,this._sub(b,a))>0?this._rightPerp(L):this._leftPerp(w),A=[],A.push([a[0]+(L[0]+w[0])/3,a[1]+(L[1]+w[1])/3]),A.push(a),A.push(b),i.push(A);break}case $.Em.GapExtentWithDoubleTicks:{const a=this._cp2(r,0,2),P=this._cp3(r,a,0,1);let b;if(x>=4)b=r[3];else{const w=this._sub(a,y);b=this._add(P,w)}this._addAngledTicks(i,y,a,this._mid(P,b)),this._addAngledTicks(i,P,b,this._mid(y,a));break}case $.Em.GapExtentMidline:{const a=this._cp2(r,2,0),P=this._cp3(r,a,0,1);let b;if(x>=4)b=r[3];else{const L=this._sub(a,y);b=this._add(P,L)}const w=[];w.push(this._mid(y,P)),w.push(this._mid(a,b)),i.push(w);break}case $.Em.Chevron:{const a=this._cp2(r,-1,-1);let P;if(x>=3)P=r[2];else{const b=this._sub(a,y);this._leftPerpendicular(b),P=this._add(y,b)}i.push([a,this._makeCtrlPt(y),P]);break}case $.Em.PerpendicularWithArc:{const a=this._cp2(r,0,-2),P=this._cp3(r,a,.5,-1);let b=this._sub(a,y);const w=this._norm(b);b[0]/=w,b[1]/=w;const L=this._crossProduct(b,this._sub(P,y));let A=this._dotProduct(b,this._sub(P,y));A<.05*w?A=.05*w:A>.95*w&&(A=.95*w);const ot=[y[0]+b[0]*A,y[1]+b[1]*A];this._leftPerpendicular(b);let lt=[];lt.push([ot[0]-b[0]*L,ot[1]-b[1]*L]),lt.push([ot[0]+b[0]*L,ot[1]+b[1]*L]),i.push(lt);const gt=[a[0]+b[0]*L,a[1]+b[1]*L];b=this._sub(a,gt);const xt=Math.cos(Math.PI/18);let Et=Math.sin(Math.PI/18);L<0&&(Et=-Et),lt=[y,a];for(let Yt=1;Yt<=9;Yt++)this._rotateDirect(b,xt,Et),lt.push(this._add(gt,b));i.push(lt);break}case $.Em.ClosedHalfCircle:{const a=this._cp2(r,2,0),P=this._mid(y,a),b=this._sub(a,P),w=Math.cos(Math.PI/18),L=Math.sin(Math.PI/18),A=[y,a];for(let ot=1;ot<=18;ot++)this._rotateDirect(b,w,L),A.push(this._add(P,b));i.push(A);break}case $.Em.TripleParallelExtended:{const a=this._cp2(r,0,-2),P=this._cp3(r,a,1,-2),b=this._mid(y,a),w=this._sub(P,a);this._normalize(w);const L=Math.abs(this._crossProduct(w,this._sub(b,a)))/2,A=this._dist(a,P),ot=[a,y];ot.push([y[0]+w[0]*A*.5,y[1]+w[1]*A*.5]),i.push(ot);const lt=[];lt.push([b[0]-w[0]*L,b[1]-w[1]*L]),lt.push([b[0]+w[0]*A*.375,b[1]+w[1]*A*.375]),(0,Dt.qh)(lt[lt.length-1],1),lt.push([b[0]+w[0]*A*.75,b[1]+w[1]*A*.75]),i.push(lt),i.push([a,P]);break}case $.Em.ParallelWithTicks:{const a=this._cp2(r,3,0),P=this._cp3(r,a,.5,-1),b=this._sub(P,a);this._normalize(b);const w=this._crossProduct(b,this._sub(P,y));this._leftPerpendicular(b),this._addAngledTicks(i,y,a,P),this._addAngledTicks(i,this._mix(y,1,b,w),this._mix(a,1,b,w),this._mid(y,a));break}case $.Em.Parallel:{const a=this._cp2(r,3,0),P=this._cp3(r,a,.5,-1),b=this._sub(a,y);this._normalize(b);const w=this._leftPerp(b),L=this._crossProduct(b,this._sub(P,y));let A=[y,a];i.push(A),A=[],A.push([y[0]+w[0]*L,y[1]+w[1]*L]),A.push([a[0]+w[0]*L,a[1]+w[1]*L]),i.push(A);break}case $.Em.PerpendicularToFirstSegment:{const a=this._cp2(r,3,0),P=this._cp3(r,a,.5,-1),b=this._mid(y,a),w=this._sub(a,y);this._normalize(w);const L=this._crossProduct(w,this._sub(P,y));this._leftPerpendicular(w);const A=[];A.push([b[0]-w[0]*L*.25,b[1]-w[1]*L*.25]),A.push([b[0]+w[0]*L*1.25,b[1]+w[1]*L*1.25]),i.push(A);break}case $.Em.ParallelOffset:{const a=this._cp2(r,3,0),P=this._cp3(r,a,.5,-1),b=this._sub(a,y);this._normalize(b);const w=this._crossProduct(b,this._sub(P,y));this._leftPerpendicular(b);const L=[];L.push([y[0]-b[0]*w,y[1]-b[1]*w]),L.push([a[0]-b[0]*w,a[1]-b[1]*w]),i.push(L);const A=[];A.push([y[0]+b[0]*w,y[1]+b[1]*w]),A.push([a[0]+b[0]*w,a[1]+b[1]*w]),i.push(A);break}case $.Em.OffsetOpposite:{const a=this._cp2(r,3,0),P=this._cp3(r,a,.5,-1),b=this._sub(a,y);this._normalize(b);const w=this._crossProduct(b,this._sub(P,y));this._leftPerpendicular(b);const L=[];L.push([y[0]-b[0]*w,y[1]-b[1]*w]),L.push([a[0]-b[0]*w,a[1]-b[1]*w]),i.push(L);break}case $.Em.OffsetSame:{const a=this._cp2(r,3,0),P=this._cp3(r,a,.5,-1),b=this._sub(a,y);this._normalize(b);const w=this._crossProduct(b,this._sub(P,y));this._leftPerpendicular(b);const L=[];L.push([y[0]+b[0]*w,y[1]+b[1]*w]),L.push([a[0]+b[0]*w,a[1]+b[1]*w]),i.push(L);break}case $.Em.CircleWithArc:{let a=this._cp2(r,3,0);const P=this._cp3(r,a,.5,-1);let b,w;if(x>=4)b=r[3],w=this._crossProduct(this._sub(b,a),this._sub(P,a))>0;else{b=a,w=this._crossProduct(this._sub(b,y),this._sub(P,y))>0;const gt=24*this._geomUnitsPerPoint,xt=this._sub(b,y);this._normalize(xt,gt);const Et=Math.sqrt(2)/2;this._rotateDirect(xt,Et,w?Et:-Et),a=this._add(y,xt)}const L=this._sub(a,y),A=Math.cos(Math.PI/18),ot=Math.sin(Math.PI/18),lt=[a];for(let gt=1;gt<=36;gt++)this._rotateDirect(L,A,ot),lt.push(this._add(y,L));this._add90DegArc(lt,a,b,P,w),(0,Dt.qh)(lt[lt.length-8],1),i.push(lt);break}case $.Em.DoubleJog:{let a,P,b=this._cp2(r,-3,1);if(a=x>=3?r[2]:this._add(y,this._sub(y,b)),x>=4)P=r[3];else{const Yt=y;y=b,P=a;const ae=this._dist(y,Yt),ce=this._dist(P,Yt);let qt=30*this._geomUnitsPerPoint;.5*ae<qt&&(qt=.5*ae),.5*ce<qt&&(qt=.5*ce),b=this._mix(y,qt/ae,Yt,(ae-qt)/ae),a=this._mix(P,qt/ce,Yt,(ce-qt)/ce)}const w=this._mid(y,b),L=this._mid(P,a),A=this._dist(y,b),ot=this._dist(a,P);let lt=Math.min(A,ot)/8;lt=Math.min(lt,24*this._geomUnitsPerPoint);const gt=Math.cos(Math.PI/4);let xt=this._sub(y,b);this._normalize(xt,lt),this._crossProduct(xt,this._sub(P,b))>0?this._rotateDirect(xt,gt,-gt):this._rotateDirect(xt,gt,gt);let Et=[];Et.push(b),Et.push(this._add(w,xt)),Et.push(this._sub(w,xt)),Et.push(y),i.push(Et),xt=this._sub(P,a),this._normalize(xt,lt),this._crossProduct(xt,this._sub(y,a))<0?this._rotateDirect(xt,gt,gt):this._rotateDirect(xt,gt,-gt),Et=[],Et.push(a),Et.push(this._add(L,xt)),Et.push(this._sub(L,xt)),Et.push(P),i.push(Et);break}case $.Em.PerpendicularOffset:{const a=this._cp2(r,-4,1),P=this._cp3(r,a,.882353,-1.94),b=this._sub(P,a);this._crossProduct(b,this._sub(y,a))>0?this._rightPerpendicular(b):this._leftPerpendicular(b);const w=[b[0]/8,b[1]/8],L=this._sub(this._mid(a,P),w);i.push([L,y]);break}case $.Em.LineExcludingLastSegment:{const a=this._arrowPath(r),P=[];let b=a.length-2;for(;b--;)P.push(a[b]);i.push(P);break}case $.Em.MultivertexArrow:{const a=this._arrowPath(r),P=[];this._addArrow(P,a,!1),i.push(P);break}case $.Em.CrossedArrow:{const a=this._arrowPath(r),P=[];this._addArrow(P,a,!0),i.push(P);break}case $.Em.ChevronArrow:{const[a,P]=this._arrowLastSeg(r),b=10*this._geomUnitsPerPoint,w=this._sub(y,a);this._normalize(w);const L=this._crossProduct(w,this._sub(P,a)),A=this._leftPerp(w),ot=[P[0]-A[0]*L*2,P[1]-A[1]*L*2],lt=[];lt.push([P[0]+w[0]*b,P[1]+w[1]*b]),lt.push(y),lt.push([ot[0]+w[0]*b,ot[1]+w[1]*b]),i.push(lt);break}case $.Em.ChevronArrowOffset:{const[a,P]=this._arrowLastSeg(r),b=this._sub(y,a);this._normalize(b);const w=this._crossProduct(b,this._sub(P,a));this._leftPerpendicular(b);const L=[P[0]-b[0]*w,P[1]-b[1]*w],A=[];A.push([L[0]+b[0]*w*.5,L[1]+b[1]*w*.5]),A.push(this._mid(L,y)),A.push([L[0]-b[0]*w*.5,L[1]-b[1]*w*.5]),i.push(A);break}case $.Em.PartialFirstSegment:{const[a,P]=this._arrowLastSeg(r),b=this._sub(y,a);this._normalize(b);const w=this._crossProduct(b,this._sub(P,a));this._leftPerpendicular(b),i.push([a,[P[0]-b[0]*w,P[1]-b[1]*w]]);break}case $.Em.Arch:{const a=this._cp2(r,0,-1),P=this._cp3(r,a,.5,1),b=this._sub(y,a),w=this._mix(P,1,b,.55),L=this._mix(P,1,b,-.55),A=[y];this._addBezier2(A,y,w,P,4),this._addBezier2(A,P,L,a,4),i.push(A);break}case $.Em.CurvedParallelTicks:{const a=this._cp2(r,-4,1),P=this._cp3(r,a,.882353,-1.94),b=this._sub(P,a);this._crossProduct(b,this._sub(y,a))>0?this._rightPerpendicular(b):this._leftPerpendicular(b);const w=[b[0]/8,b[1]/8],L=this._sub(this._mid(a,P),w),A=this._sub(this._mix(a,.75,P,.25),w),ot=this._sub(this._mix(a,.25,P,.75),w),lt=[a];this._addBezier2(lt,a,A,L,3),this._addBezier2(lt,L,ot,P,3),i.push(lt);for(let gt=0;gt<8;gt++){const xt=lt[2*gt+1],Et=[this._clone(xt)];Et.push(this._add(xt,[b[0]/4,b[1]/4])),i.push(Et)}break}case $.Em.Arc90Degrees:{const a=this._cp2(r,0,-1),P=this._cp3(r,a,.5,1),b=[a];this._add90DegArc(b,a,y,P),i.push(b);break}default:i.push(r)}}return i}}let Xt=(()=>{class S{static local(){return null===S.instance&&(S.instance=new S),S.instance}execute(i,r,x,y){return new jt(i,r,x)}}return S.instance=null,S})();class jt extends Dt.zY{constructor(e,i,r){super(e,!0,!0),this._curveHelper=new Lt,this._beginCut=(void 0!==i.beginCut?i.beginCut:1)*r,this._endCut=(void 0!==i.endCut?i.endCut:1)*r,this._middleCut=(void 0!==i.middleCut?i.middleCut:0)*r,this._invert=void 0!==i.invert&&i.invert,this._beginCut<0&&(this._beginCut=0),this._endCut<0&&(this._endCut=0),this._middleCut<0&&(this._middleCut=0)}processPath(e){const i=this._beginCut,r=this._endCut,x=this._middleCut,y=this._curveHelper.calculatePathLength(e),a=[];if(this._invert){if(0!==i||0!==r||0!==x)if(i+r+x>=y)a.push(e);else{let P=this._curveHelper.getSubCurve(e,0,i);P&&a.push(P),P=this._curveHelper.getSubCurve(e,.5*(y-x),.5*(y+x)),P&&a.push(P),P=this._curveHelper.getSubCurve(e,y-r,r),P&&a.push(P)}}else if(0===i&&0===r&&0===x)a.push(e);else if(!(i+r+x>=y))if(0===x){const P=this._curveHelper.getSubCurve(e,i,y-r);P&&a.push(P)}else{let P=this._curveHelper.getSubCurve(e,i,.5*(y-x));P&&a.push(P),P=this._curveHelper.getSubCurve(e,.5*(y+x),y-r),P&&a.push(P)}return 0===a.length?null:{paths:a}}}class te{constructor(){this._values=[],this.extPtGap=0,this.ctrlPtGap=0,this._length=0,this._currentValue=0}isEmpty(){return 0===this._values.length}size(){return this._values.length}init(e,i,r=!0){if(this._setEmpty(),!e||0===e.length)return!1;for(let x=0;x<e.length;x++){let y=Math.abs(e[x]);r&&y<1e-7&&(y=1e-7),this._values.push(y),this._length+=y}return i&&1&e.length&&(this._length*=2),0!==this._length&&(this.ctrlPtGap=this.extPtGap=0,this._currentValue=-1,!0)}scale(e){const i=this._values?this._values.length:0;for(let r=0;r<i;++r)this._values[r]*=e;this._length*=e,this.extPtGap*=e,this.ctrlPtGap*=e}addValue(e){this._length+=e,this._values.push(e)}firstValue(){return this._values[0]}lastValue(){return this._values[this._values.length-1]}nextValue(){return this._currentValue++,this._currentValue===this._values.length&&(this._currentValue=0),this._values[this._currentValue]}reset(){this._currentValue=-1}length(){return this._length}_setEmpty(){this.extPtGap=this.ctrlPtGap=this._length=0,this._currentValue=-1,this._values.length=0}}class Q{constructor(){this.pt=null,this.ca=0,this.sa=0}}var Pt,S;(S=Pt||(Pt={}))[S.FAIL=0]="FAIL",S[S.END=1]="END",S[S.CONTINUE=2]="CONTINUE";class bt{constructor(){this.reset()}reset(){this.segment=-1,this.segmentLength=0,this.abscissa=0,this.isPathEnd=!1,this.isPartEnd=!1}isValid(){return-1!==this.segment}copyTo(e){e.segment=this.segment,e.segmentLength=this.segmentLength,e.abscissa=this.abscissa,e.isPathEnd=this.isPathEnd,e.isPartEnd=this.isPartEnd}}class rt extends Lt{constructor(e=0,i=!1){super(e,i),this._tolerance=zt,this._currentPosition=new bt}updateTolerance(e){this._tolerance=zt*e}init(e,i,r=!0){return r?(this._patternLength=i.length(),this._partExtPtGap=i.extPtGap,this._partCtrlPtGap=i.ctrlPtGap):(this._patternLength=0,this._partExtPtGap=0,this._partCtrlPtGap=0),this._currentPosition.reset(),this._partSegCount=0,this._path=e,this._seg=-1,this._setPosAtNextPart()}curPositionIsValid(){return this._currentPosition.isValid()}nextPosition(e,i=Pt.FAIL){const r=new bt;return!!this._nextPosition(e,r,null,i)&&(r.copyTo(this._currentPosition),!0)}curPointAndAngle(e){e.pt=this._getPoint(this._currentPosition);const[i,r]=this._getAngle(this._currentPosition);e.ca=i,e.sa=r}nextPointAndAngle(e,i,r=Pt.FAIL){const x=new bt;if(!this._nextPosition(e,x,null,r))return!1;x.copyTo(this._currentPosition),i.pt=this._getPoint(x);const[y,a]=this._getAngle(x);return i.ca=y,i.sa=a,!0}nextCurve(e){if(0===e)return null;const i=[],r=new bt;return this._nextPosition(e,r,i,Pt.END)?(r.copyTo(this._currentPosition),i):null}isPathEnd(){return this._currentPosition.isPathEnd}getPathEnd(){if(-1===this._currentPosition.segment)throw new Error("missing segment");return this._path[this._currentPosition.segment+1]}_nextPosition(e,i,r,x){if(this._currentPosition.isPathEnd)return!1;let y=this._currentPosition.abscissa;for(this._currentPosition.segmentLength>0&&(y/=this._currentPosition.segmentLength),this._currentPosition.copyTo(i);i.abscissa+e*this._partLengthRatio>i.segmentLength+this._tolerance;){if(r){if(0===r.length)if(0===y){const P=this._path[i.segment];r.push([P[0],P[1]])}else r.push(this.getSegCoord2D(this._path,i.segment,y));const a=this._path[i.segment+1];r.push([a[0],a[1]])}if(y=0,e-=(i.segmentLength-i.abscissa)/this._partLengthRatio,this._partSegCount)i.segment=this._nextSegment(),i.segmentLength=this.calculateSegLength(this._path,i.segment),i.abscissa=0,this._partSegCount--;else{if(!this._setPosAtNextPart())return x!==Pt.FAIL&&(i.segmentLength=this.calculateSegLength(this._path,i.segment),i.isPartEnd=!0,x===Pt.END?(i.abscissa=i.segmentLength,i.isPathEnd=!0):i.abscissa=i.segmentLength+e,!0);this._currentPosition.copyTo(i)}}if(i.abscissa+=e*this._partLengthRatio,r){if(0===r.length)if(0===y){const P=this._path[i.segment];r.push([P[0],P[1]])}else r.push(this.getSegCoord2D(this._path,i.segment,y));const a=i.abscissa/i.segmentLength;if(1===a){const P=this._path[i.segment+1];r.push([P[0],P[1]])}else r.push(this.getSegCoord2D(this._path,i.segment,a))}return this._partSegCount||Math.abs(i.abscissa-i.segmentLength)<this._tolerance&&(i.isPathEnd=this._partIsLast,i.isPartEnd=!0),!0}_getPoint(e){if(-1===e.segment)throw new Error("missing segment");return this.getSegCoord2D(this._path,e.segment,e.segmentLength<=0?0:e.abscissa/e.segmentLength)}_getAngle(e){if(-1===e.segment)throw new Error("missing segment");return this.getSegAngleCS(this._path,e.segment,e.segmentLength<=0?0:e.abscissa/e.segmentLength)}_setPosAtNextPart(){for(;this._partSegCount;)this._hasNextSegment()&&this._nextSegment(),this._partSegCount--;if(!this._hasNextSegment())return!1;for(this._partLength=0,this._partIsLast=!0,this._partSegCount=0;this._hasNextSegment();)if(this._partLength+=this.calculateSegLength(this._path,this._nextSegment()),this._partSegCount++,1===(0,Dt.zv)(this._path[this._getEndPointIndex()])){this._partIsLast=!this._hasNextSegment();break}let e=this._partSegCount;for(;e;)this._previousSegment(),--e;this._currentPosition.segment=this._nextSegment(),this._currentPosition.segmentLength=this.calculateSegLength(this._path,this._currentPosition.segment),this._currentPosition.abscissa=0,this._currentPosition.isPathEnd=this._currentPosition.isPartEnd=!1,--this._partSegCount;const i=this._getStartPointIndex();this._ctrlPtBegin=1===(0,Dt.zv)(this._path[i]);let r=i+this._partSegCount+1;if(r>=this._path.length&&(r=0),this._ctrlPtEnd=1===(0,Dt.zv)(this._path[r]),this._patternLength>0){const x=this._ctrlPtBegin?this._partCtrlPtGap:this._partExtPtGap,y=this._ctrlPtEnd?this._partCtrlPtGap:this._partExtPtGap;let a=Math.round((this._partLength-(x+y))/this._patternLength);a<=0&&(a=x+y>0?0:1),this._partLengthRatio=this._partLength/(x+y+a*this._patternLength),this._partLengthRatio<.01&&(this._partLengthRatio=1)}else this._partLengthRatio=1;return!0}_hasNextSegment(){return this._seg<this._path.length-2}_previousSegment(){return--this._seg}_nextSegment(){return++this._seg}_getStartPointIndex(){return this._seg}_getEndPointIndex(){return this._seg+1}}let ut=(()=>{class S{static local(){return null===S.instance&&(S.instance=new S),S.instance}execute(i,r,x,y){return new ht(i,r,x)}}return S.instance=null,S})();class ht extends Dt.zY{constructor(e,i,r){super(e,!0,!0),this._firstCurve=null,this._walker=new rt,this._walker.updateTolerance(r),this._endings=i.lineDashEnding,this._customDashPos=-(i.offsetAlongLine??0)*r,this._offsetAtEnd=(i.customEndingOffset??0)*r,this._pattern=new te,this._pattern.init(i.dashTemplate,!0),this._pattern.scale(r)}processPath(e){if(0===this._pattern.length())return this.iteratePath=!1,{paths:[e]};if(!this.iteratePath){let x=!0;switch(this._endings){case $.sj.HalfPattern:case $.sj.HalfGap:default:this._pattern.extPtGap=0;break;case $.sj.FullPattern:this.isClosed||(this._pattern.extPtGap=.5*this._pattern.firstValue());break;case $.sj.FullGap:this.isClosed||(this._pattern.extPtGap=.5*this._pattern.lastValue());break;case $.sj.NoConstraint:this.isClosed||(x=!1);break;case $.sj.Custom:this.isClosed||(this._pattern.extPtGap=.5*this._offsetAtEnd)}const y=this._walker.calculatePathLength(e);if(this._pattern.isEmpty()||y<.1*this._pattern.length())return{paths:[e]};if(!this._walker.init(e,this._pattern,x))return{paths:[e]}}let i;if(this.iteratePath)i=this._pattern.nextValue();else{let x;switch(this._endings){case $.sj.HalfPattern:default:x=.5*this._pattern.firstValue();break;case $.sj.HalfGap:x=.5*-this._pattern.lastValue();break;case $.sj.FullGap:x=-this._pattern.lastValue();break;case $.sj.FullPattern:x=0;break;case $.sj.NoConstraint:case $.sj.Custom:x=-this._customDashPos}let y=x/this._pattern.length();y-=Math.floor(y),x=y*this._pattern.length(),this._pattern.reset(),i=this._pattern.nextValue();let a=!1;for(;x>=i;)x-=i,i=this._pattern.nextValue(),a=!a;i-=x,a?(this._walker.nextPosition(i),i=this._pattern.nextValue()):this.isClosed&&(this._firstCurve=this._walker.nextCurve(i),i=this._pattern.nextValue(),this._walker.nextPosition(i),i=this._pattern.nextValue())}let r=this._walker.nextCurve(i);return r?this._walker.isPathEnd()?(this.iteratePath=!1,this._firstCurve&&(this._firstCurve.splice(0,1),pt.mergePath(r,this._firstCurve),this._firstCurve=null)):(i=this._pattern.nextValue(),!this._walker.nextPosition(i)||this._walker.isPathEnd()?(this.iteratePath=!1,this._firstCurve&&(r=this._firstCurve,this._firstCurve=null)):this.iteratePath=!0):(this.iteratePath=!1,r=this._firstCurve,this._firstCurve=null),{paths:[r]}}}let St=(()=>{class S{static local(){return null===S.instance&&(S.instance=new S),S.instance}execute(i,r,x,y){return new kt(i,r,x)}}return S.instance=null,S})();class kt{constructor(e,i,r){switch(this._inputGeometries=e,this._curveHelper=new Lt,this._width=(void 0!==i.width?i.width:2)*r,i.method){case $.$y.Mitered:default:this._method=$.id.Mitered;break;case $.$y.Bevelled:this._method=$.id.Bevelled;break;case $.$y.Rounded:case $.$y.TrueBuffer:this._method=$.id.Rounded;break;case $.$y.Square:this._method=$.id.Square}this._option=i.option,this._offsetFlattenError=zt*r}next(){let e=this._inputGeometries.next();for(;e;){if((0,yt.YX)(e)&&this._width>0){if(Math.min(e.xmax-e.xmin,e.ymax-e.ymin)-2*this._width<0)return e;const i=[];return i.push([[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]]),i.push([[e.xmin+this._width,e.ymin+this._width],[e.xmax-this._width,e.ymin+this._width],[e.xmax-this._width,e.ymax-this._width],[e.xmin+this._width,e.ymax-this._width],[e.xmin+this._width,e.ymin+this._width]]),{rings:i}}if((0,yt.oU)(e)&&this._width>0){const i=[];for(const r of e.rings){const x=this._curveHelper.calculatePathLength(r),y=this._curveHelper.offset(r,this._width,this._method,4,this._offsetFlattenError);y&&(x<0&&y.reverse(),i.push(y))}if(i.length)return{rings:i}}e=this._inputGeometries.next()}return null}}let Ht=(()=>{class S{static local(){return null===S.instance&&(S.instance=new S),S.instance}execute(i,r,x,y){return new Vt(i,r,x)}}return S.instance=null,S})();class Vt extends Dt.zY{constructor(e,i,r){super(e,!1,!0),this._curveHelper=new Lt,this._length=(void 0!==i.length?i.length:20)*r,this._angle=void 0!==i.angle?i.angle:225,this._position=void 0!==i.position?i.position:50,this._length<0&&(this._length=-this._length),this._position<20&&(this._position=20),this._position>80&&(this._position=80),this._mirror=!1}processPath(e){if(this._curveHelper.isEmpty(e,!1))return null;const i=e[0],r=e[e.length-1];this._curveHelper.normalize([r[0]-i[0],r[1]-i[1]]);const y=[i[0]+(r[0]-i[0])*this._position/100,i[1]+(r[1]-i[1])*this._position/100],a=Math.cos((90-this._angle)/180*Math.PI);let P=Math.sin((90-this._angle)/180*Math.PI);return this._mirror&&(P=-P),this._mirror=!this._mirror,{paths:[[i,[y[0]-this._length/2*a,y[1]-this._length/2*P],[y[0]+this._length/2*a,y[1]+this._length/2*P],r]]}}}let Gt=(()=>{class S{static local(){return null===S.instance&&(S.instance=new S),S.instance}execute(i,r,x,y){return new wt(i,r,x)}}return S.instance=null,S})();class wt{constructor(e,i,r){this._inputGeometries=e,this._offsetX=void 0!==i.offsetX?i.offsetX*r:0,this._offsetY=void 0!==i.offsetY?-i.offsetY*r:0}next(){let e=this._inputGeometries.next();for(;e;){if((0,yt.YX)(e))return{xmin:e.xmin+this._offsetX,xmax:e.xmax+this._offsetX,ymin:e.ymin+this._offsetY,ymax:e.ymax+this._offsetY};if((0,yt.oU)(e)){const i=(0,At.d9)(e);return this._moveMultipath(i.rings,this._offsetX,this._offsetY),i}if((0,yt.l9)(e)){const i=(0,At.d9)(e);return this._moveMultipath(i.paths,this._offsetX,this._offsetY),i}if((0,yt.aW)(e)){const i=(0,At.d9)(e);return this._movePath(i.points,this._offsetX,this._offsetY),i}if((0,yt.wp)(e))return{x:e.x+this._offsetX,y:e.y+this._offsetY};e=this._inputGeometries.next()}return null}_moveMultipath(e,i,r){if(e)for(const x of e)this._movePath(x,i,r)}_movePath(e,i,r){if(e)for(const x of e)x[0]+=i,x[1]+=r}}let re=(()=>{class S{static local(){return null===S.instance&&(S.instance=new S),S.instance}execute(i,r,x,y){return new me(i,r,x)}}return S.instance=null,S})();class me{constructor(e,i,r){this._inputGeometries=e,this._curveHelper=new Lt,this._offset=(i.offset??1)*r,this._method=i.method,this._option=i.option,this._offsetFlattenError=zt*r}next(){let e=this._inputGeometries.next();for(;e;){if(0===this._offset)return e;if((0,yt.YX)(e)){if(this._method===$.id.Rounded&&this._offset>0){const r=this._curveHelper.offset([[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]],-this._offset,this._method,4,this._offsetFlattenError);return r?{rings:[r]}:null}if(Math.min(e.xmax-e.xmin,e.ymax-e.ymin)+2*this._offset>0)return{xmin:e.xmin-this._offset,xmax:e.xmax+this._offset,ymin:e.ymin-this._offset,ymax:e.ymax+this._offset}}if((0,yt.oU)(e)){const i=[];for(const r of e.rings){const x=this._curveHelper.offset(r,-this._offset,this._method,4,this._offsetFlattenError);x&&i.push(x)}if(i.length)return{rings:i}}if((0,yt.l9)(e)){const i=[];for(const r of e.paths){const x=this._curveHelper.offset(r,-this._offset,this._method,4,this._offsetFlattenError);x&&i.push(x)}if(i.length)return{paths:i}}e=this._inputGeometries.next()}return null}}let oe=(()=>{class S{static local(){return null===S.instance&&(S.instance=new S),S.instance}execute(i,r,x,y){return new pe(i,r,x)}}return S.instance=null,S})();class pe{constructor(e,i,r){this._inputGeometries=e,this._reverse=void 0===i.reverse||i.reverse}next(){let e=this._inputGeometries.next();for(;e;){if(!this._reverse)return e;if((0,yt.l9)(e)){const i=(0,At.d9)(e);return(0,Dt.ov)(i.paths),i}e=this._inputGeometries.next()}return null}}var ie=at(65401),ne=at(32442);let It=(()=>{class S{static local(){return null===S.instance&&(S.instance=new S),S.instance}execute(i,r,x,y){return new h(i,r,x)}}return S.instance=null,S})();class h{constructor(e,i,r){this._inputGeometries=e,this._rotateAngle=void 0!==i.angle?i.angle*Math.PI/180:0}next(){let e=this._inputGeometries.next();for(;e;){if(0===this._rotateAngle)return e;const i=(0,ie.Ue)();(0,ne.$P)(i,e);const r=(i[2]+i[0])/2,x=(i[3]+i[1])/2;if((0,yt.YX)(e)){const y={rings:[[[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]]]};return this._rotateMultipath(y.rings,r,x),y}if((0,yt.oU)(e)){const y=(0,At.d9)(e);return this._rotateMultipath(y.rings,r,x),y}if((0,yt.l9)(e)){const y=(0,At.d9)(e);return this._rotateMultipath(y.paths,r,x),y}if((0,yt.aW)(e)){const y=(0,At.d9)(e);return this._rotatePath(y.points,r,x),y}if((0,yt.wp)(e))return e;e=this._inputGeometries.next()}return null}_rotateMultipath(e,i,r){if(e)for(const x of e)this._rotatePath(x,i,r)}_rotatePath(e,i,r){if(e){const x=Math.cos(this._rotateAngle),y=Math.sin(this._rotateAngle);for(const a of e){const P=a[0]-i,b=a[1]-r;a[0]=i+P*x-b*y,a[1]=r+P*y+b*x}}}}let I=(()=>{class S{static local(){return null===S.instance&&(S.instance=new S),S.instance}execute(i,r,x,y){return new Y(i,r,x)}}return S.instance=null,S})();class Y{constructor(e,i,r){this._inputGeometries=e,this._xFactor=void 0!==i.xScaleFactor?i.xScaleFactor:1.15,this._yFactor=void 0!==i.yScaleFactor?i.yScaleFactor:1.15}next(){let e=this._inputGeometries.next();for(;e;){if(1===this._xFactor&&1===this._yFactor)return e;const i=(0,ie.Ue)();(0,ne.$P)(i,e);const r=(i[2]+i[0])/2,x=(i[3]+i[1])/2;if((0,yt.YX)(e)){const y={rings:[[[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]]]};return this._scaleMultipath(y.rings,r,x),y}if((0,yt.oU)(e)){const y=(0,At.d9)(e);return this._scaleMultipath(y.rings,r,x),y}if((0,yt.l9)(e)){const y=(0,At.d9)(e);return this._scaleMultipath(y.paths,r,x),y}if((0,yt.aW)(e)){const y=(0,At.d9)(e);return this._scalePath(y.points,r,x),y}if((0,yt.wp)(e))return e;e=this._inputGeometries.next()}return null}_scaleMultipath(e,i,r){if(e)for(const x of e)this._scalePath(x,i,r)}_scalePath(e,i,r){if(e)for(const x of e){const a=(x[1]-r)*this._yFactor;x[0]=i+(x[0]-i)*this._xFactor,x[1]=r+a}}}let R=(()=>{class S{static local(){return null===S.instance&&(S.instance=new S),S.instance}execute(i,r,x,y){return new Z(i,r,x)}}return S.instance=null,S})();class Z{constructor(e,i,r){this._inputGeometries=e,this._height=(void 0!==i.amplitude?i.amplitude:2)*r,this._period=(void 0!==i.period?i.period:3)*r,this._style=i.waveform,this._height<=0&&(this._height=Math.abs(this._height)),this._period<=0&&(this._period=Math.abs(this._period)),this._pattern=new te,this._pattern.addValue(this._period),this._pattern.addValue(this._period),this._walker=new rt,this._walker.updateTolerance(r)}next(){let e=this._inputGeometries.next();for(;e;){if(0===this._height||0===this._period)return e;if((0,yt.l9)(e)){const i=this._processGeom(e.paths);if(i.length)return{paths:i}}if((0,yt.oU)(e)){const i=this._processGeom(e.rings);if(i.length)return{rings:i}}e=this._inputGeometries.next()}return null}_processGeom(e){const i=[];for(const r of e)if(this._walker.init(r,this._pattern))switch(this._style){case $.zQ.Sinus:default:i.push(this._constructCurve(r,!1));break;case $.zQ.Square:i.push(this._constructSquare(r));break;case $.zQ.Triangle:i.push(this._constructTriangle(r));break;case $.zQ.Random:i.push(this._constructCurve(r,!0))}else i.push(r);return i}_constructCurve(e,i){const r=new pt,x=this._walker.calculatePathLength(e);let y=Math.round(x/this._period);0===y&&(y=1);const b=this._period/16,w=1/(16*y+1),L=2*Math.PI*x/(x/y),A=2*Math.PI*Math.random(),ot=2*Math.PI*Math.random(),lt=2*Math.PI*Math.random(),gt=.75-Math.random()/2,xt=.75-Math.random()/2,Et=new Q;this._walker.curPointAndAngle(Et),r.startPath(Et.pt);let Yt=0;for(;;){if(!this._walker.nextPointAndAngle(b,Et)){r.lineTo(e[e.length-1]);break}{const ae=Yt;let ce;if(Yt+=w,i){const qt=this._height/2*(1+.3*Math.sin(gt*L*ae+A));ce=qt*Math.sin(L*ae+ot),ce+=qt*Math.sin(xt*L*ae+lt),ce/=2}else ce=.5*this._height*Math.sin(.5*L*ae);r.lineTo([Et.pt[0]-ce*Et.sa,Et.pt[1]+ce*Et.ca])}}return r.path()}_constructSquare(e){const i=new pt,r=this._walker.calculatePathLength(e);Math.round(r/this._period);let x=!0;for(;;){let y=!1;if(this._walker.curPositionIsValid()){const a=new Q;this._walker.curPointAndAngle(a);const P=new Q;if(this._walker.nextPointAndAngle(this._period,P)){const b=new Q;this._walker.nextPointAndAngle(this._period,b)&&(x?(i.startPath(a.pt),x=!1):i.lineTo(a.pt),i.lineTo([a.pt[0]-this._height/2*a.sa,a.pt[1]+this._height/2*a.ca]),i.lineTo([P.pt[0]-this._height/2*P.sa,P.pt[1]+this._height/2*P.ca]),i.lineTo([P.pt[0]+this._height/2*P.sa,P.pt[1]-this._height/2*P.ca]),i.lineTo([b.pt[0]+this._height/2*b.sa,b.pt[1]-this._height/2*b.ca]),y=!0)}}if(!y){i.lineTo(this._walker.getPathEnd());break}}return i.path()}_constructTriangle(e){const i=new pt,r=this._walker.calculatePathLength(e);Math.round(r/this._period);let x=!0;for(;;){let y=!1;if(this._walker.curPositionIsValid()){const a=new Q;this._walker.curPointAndAngle(a);const P=new Q;if(this._walker.nextPointAndAngle(this._period/2,P)){const b=new Q;this._walker.nextPointAndAngle(this._period,b)&&(this._walker.nextPosition(this._period/2)&&(x?(i.startPath(a.pt),x=!1):i.lineTo(a.pt),i.lineTo([P.pt[0]-this._height/2*P.sa,P.pt[1]+this._height/2*P.ca]),i.lineTo([b.pt[0]+this._height/2*b.sa,b.pt[1]-this._height/2*b.ca])),y=!0)}}if(!y){i.lineTo(this._walker.getPathEnd());break}}return i.path()}}let ft=(()=>{class S{static local(){return null===S.instance&&(S.instance=new S),S.instance}execute(i,r,x,y){return new q(i,r,x)}}return S.instance=null,S})();class q extends Dt.v1{constructor(e,i,r){super(e,!0,!0),this._geometryWalker=new rt,this._geometryWalker.updateTolerance(r),this._angleToLine=i.angleToLine??!0,this._offset=(i.offset?i.offset:0)*r,this._originalEndings=i.endings,this._offsetAtEnd=(i.customEndingOffset?i.customEndingOffset:0)*r,this._position=-(i.offsetAlongLine?i.offsetAlongLine:0)*r,this._pattern=new te,this._pattern.init(i.placementTemplate,!1),this._pattern.scale(r),this._endings=this._originalEndings}processPath(e){if(this._pattern.isEmpty())return null;let i;if(this.iteratePath)i=this._pattern.nextValue();else{this._endings=this._originalEndings===$.JS.WithFullGap&&this.isClosed?$.JS.WithMarkers:this._originalEndings,this._pattern.extPtGap=0;let x,y=!0;switch(this._endings){case $.JS.NoConstraint:x=-this._position,x=this._adjustPosition(x),y=!1;break;case $.JS.WithHalfGap:default:x=-this._pattern.lastValue()/2;break;case $.JS.WithFullGap:x=-this._pattern.lastValue(),this._pattern.extPtGap=this._pattern.lastValue();break;case $.JS.WithMarkers:x=0;break;case $.JS.Custom:x=-this._position,x=this._adjustPosition(x),this._pattern.extPtGap=.5*this._offsetAtEnd}if(!this._geometryWalker.init(e,this._pattern,y))return null;this._pattern.reset();let a=0;for(;x>a;)x-=a,a=this._pattern.nextValue();a-=x,i=a,this.iteratePath=!0}const r=new Q;return this._geometryWalker.nextPointAndAngle(i,r)?this._endings===$.JS.WithFullGap&&this._geometryWalker.isPathEnd()?(this.iteratePath=!1,null):this._endings===$.JS.WithMarkers&&this._geometryWalker.isPathEnd()&&(this.iteratePath=!1,this.isClosed)?null:(this.internalPlacement.setTranslate(r.pt[0]-this._offset*r.sa,r.pt[1]+this._offset*r.ca),this._angleToLine&&this.internalPlacement.setRotateCS(r.ca,r.sa),this.internalPlacement):(this.iteratePath=!1,null)}_adjustPosition(e){let i=e/this._pattern.length();return i-=Math.floor(i),i*this._pattern.length()}}let Ct=(()=>{class S{static local(){return null===S.instance&&(S.instance=new S),S.instance}execute(i,r,x,y){return new N(i,r,x)}}return S.instance=null,S})();class N extends Dt.v1{constructor(e,i,r){super(e,!1,!0),this._curveHelper=new Lt,this._angleToLine=void 0===i.angleToLine||i.angleToLine,this._offset=void 0!==i.offset?i.offset*r:0,this._type=i.extremityPlacement,this._position=void 0!==i.offsetAlongLine?i.offsetAlongLine*r:0,this._beginProcessed=!1}processPath(e){let i;switch(this._type){case $.Tx.Both:default:this._beginProcessed?(i=this._atExtremities(e,this._position,!1),this._beginProcessed=!1,this.iteratePath=!1):(i=this._atExtremities(e,this._position,!0),this._beginProcessed=!0,this.iteratePath=!0);break;case $.Tx.JustBegin:i=this._atExtremities(e,this._position,!0);break;case $.Tx.JustEnd:i=this._atExtremities(e,this._position,!1);case $.Tx.None:}return i}_atExtremities(e,i,r){const x=e.length;if(x<2)return null;const a=r?x:-1,P=r?1:-1;let b,w=0,L=r?e[0]:e[x-1];for(let A=r?1:x-2;A!==a;A+=P){b=L,L=e[A];const ot=this._curveHelper.calculateLength(b,L);if(w+ot>i){const lt=(i-w)/ot,[gt,xt]=this._curveHelper.getAngleCS(b,L,lt),Et=(0,Dt.XV)(b,L,lt);return this.internalPlacement.setTranslate(Et[0]-this._offset*xt,Et[1]+this._offset*gt),this._angleToLine&&this.internalPlacement.setRotateCS(-gt,-xt),this.internalPlacement}w+=ot}return null}}let v=(()=>{class S{static local(){return null===S.instance&&(S.instance=new S),S.instance}execute(i,r,x,y){return new k(i,r,x)}}return S.instance=null,S})();class k extends Dt.v1{constructor(e,i,r){super(e,!0,!0),this._walker=new rt,this._walker.updateTolerance(r),this._angleToLine=void 0===i.angleToLine||i.angleToLine,this._offset=void 0!==i.offset?i.offset*r:0,this._beginGap=void 0!==i.beginPosition?i.beginPosition*r:0,this._endGap=void 0!==i.endPosition?i.endPosition*r:0,this._flipFirst=void 0===i.flipFirst||i.flipFirst,this._pattern=new te,this._pattern.init(i.positionArray,!1,!1),this._subPathLen=0,this._posCount=this._pattern.size(),this._isFirst=!0,this._prevPos=0}processPath(e){if(this._pattern.isEmpty())return null;let i;if(this.iteratePath){const P=this._pattern.nextValue()*this._subPathLen,b=this._beginGap+P;i=b-this._prevPos,this._prevPos=b}else{if(this._posCount=this._pattern.size(),this._isFirst=!0,this._prevPos=0,this._subPathLen=this._walker.calculatePathLength(e)-this._beginGap-this._endGap,this._subPathLen<0)return this.iteratePath=!1,null;if(!this._walker.init(e,this._pattern,!1))return null;this._pattern.reset();const P=this._pattern.nextValue()*this._subPathLen,b=this._beginGap+P;i=b-this._prevPos,this._prevPos=b,this.iteratePath=!0}const r=new Q;if(!this._walker.nextPointAndAngle(i,r,Pt.END))return this.iteratePath=!1,null;let y,a;return this.internalPlacement.setTranslate(r.pt[0]-this._offset*r.sa,r.pt[1]+this._offset*r.ca),this._angleToLine?(y=r.ca,a=r.sa):(y=1,a=0),this._isFirst&&this._flipFirst&&(y=-y,a=-a),this.internalPlacement.setRotateCS(y,a),this._isFirst=!1,this._posCount--,0===this._posCount&&(this.iteratePath=!1),this.internalPlacement}}var E=at(4619),U=at(97373);let J=(()=>{class S{static local(){return null===S.instance&&(S.instance=new S),S.instance}execute(i,r,x,y){return new K(i,r,x,y)}}return S.instance=null,S})();class K{constructor(e,i,r,x){if(this._xMin=0,this._xMax=0,this._yMin=0,this._yMax=0,this._currentX=0,this._currentY=0,this._stepX=Math.abs(i.stepX??16)*r,this._stepY=Math.abs(i.stepY??16)*r,0!==this._stepX&&0!==this._stepY&&e&&function F(S){return void 0!==S.rings}(e)&&e.rings){if(this._gridType=i.gridType??$.bj.Fixed,this._gridType===$.bj.Random)this._randomLCG=new E.Z(1*(i.seed??13)),this._randomness=(i.randomness??100)/100,this._gridAngle=0,this._shiftOddRows=!1,this._cosAngle=1,this._sinAngle=0,this._offsetX=0,this._offsetY=0;else{if(this._randomness=0,this._gridAngle=i.gridAngle??0,this._shiftOddRows=i.shiftOddRows??!1,this._offsetX=(i.offsetX??0)*r,this._offsetY=(i.offsetY??0)*r,this._cosAngle=Math.cos(this._gridAngle/180*Math.PI),this._sinAngle=-Math.sin(this._gridAngle/180*Math.PI),this._stepX)if(this._offsetX<0)for(;this._offsetX<-.5*this._stepX;)this._offsetX+=this._stepX;else for(;this._offsetX>=.5*this._stepX;)this._offsetX-=this._stepX;if(this._stepY)if(this._offsetY<0)for(;this._offsetY<-.5*this._stepY;)this._offsetY+=this._stepY;else for(;this._offsetY>=.5*this._stepY;)this._offsetY-=this._stepY}this._graphicOriginX=0,this._graphicOriginY=0,this._internalPlacement=new U.u,this._calculateMinMax(e),this._geometry=e}}next(){return this._geometry?this._nextInside():null}_calculateMinMax(e){let i,r,x,y,a,P,b,w;this._xMin=0,this._xMax=0,this._yMin=0,this._yMax=0,a=P=Number.MAX_VALUE,b=w=-Number.MAX_VALUE;for(const L of e.rings){const A=L?L.length:0;for(let ot=0;ot<A;++ot)i=L[ot][0]-this._graphicOriginX-this._offsetX,r=L[ot][1]-this._graphicOriginY-this._offsetY,x=this._cosAngle*i-this._sinAngle*r,y=this._sinAngle*i+this._cosAngle*r,a=Math.min(a,x),b=Math.max(b,x),P=Math.min(P,y),w=Math.max(w,y)}a+=this._graphicOriginX,b+=this._graphicOriginX,P+=this._graphicOriginY,w+=this._graphicOriginY,this._xMin=Math.round(a/this._stepX),this._xMax=Math.round(b/this._stepX),this._yMin=Math.round(P/this._stepY),this._yMax=Math.round(w/this._stepY),this._currentX=this._xMax+1,this._currentY=this._yMin-1}_nextInside(){for(;;){if(this._currentX>this._xMax){if(this._currentY++,this._currentY>this._yMax)return null;this._currentX=this._xMin,this._shiftOddRows&&this._currentY%2&&this._currentX--}let e=this._currentX*this._stepX+this._offsetX;this._shiftOddRows&&this._currentY%2&&(e+=.5*this._stepX);const i=this._currentY*this._stepY+this._offsetY;let r,x;return this._currentX++,this._gridType===$.bj.Random?(r=this._graphicOriginX+e+this._stepX*this._randomness*(.5-this._randomLCG.getFloat())*2/3,x=this._graphicOriginY+i+this._stepY*this._randomness*(.5-this._randomLCG.getFloat())*2/3):(r=this._graphicOriginX+this._cosAngle*e+this._sinAngle*i,x=this._graphicOriginY-this._sinAngle*e+this._cosAngle*i),this._internalPlacement.setTranslate(r,x),this._internalPlacement}}}let n=(()=>{class S{static local(){return null===S.instance&&(S.instance=new S),S.instance}execute(i,r,x,y){return new O(i,r,x)}}return S.instance=null,S})();class O extends Dt.v1{constructor(e,i,r){super(e,!0,!0),this._curveHelper=new Lt,this._angleToLine=void 0===i.angleToLine||i.angleToLine,this._offset=void 0!==i.offset?i.offset*r:0,this._relativeTo=i.relativeTo,this._position=void 0!==i.startPointOffset?i.startPointOffset*r:0,this._epsilon=.001*r}processPath(e){const i=this._position;if(this._relativeTo===$.CS.SegmentMidpoint){for(this.iteratePath||(this._segmentCount=e.length,this._curSegment=1,this.iteratePath=!0);this._curSegment<this._segmentCount;){const x=this._curSegment;this._curSegment++;const y=e[x-1],a=e[x],P=this._curveHelper.calculateLength(y,a);if(P<this._epsilon)continue;const b=.5+this._position/P,[w,L]=this._curveHelper.getAngleCS(y,a,b),A=(0,Dt.XV)(y,a,b);return this.internalPlacement.setTranslate(A[0]-this._offset*L,A[1]+this._offset*w),this._angleToLine&&this.internalPlacement.setRotateCS(w,L),this.internalPlacement}return this.iteratePath=!1,null}this._relativeTo===$.CS.LineEnd&&(0,Dt.hh)(e);const r=this.onLine(e,i);return this._relativeTo===$.CS.LineEnd&&(0,Dt.hh)(e),r}onLine(e,i){let r,x=!1;switch(this._relativeTo){case $.CS.LineMiddle:default:r=this._curveHelper.calculatePathLength(e)/2+i;break;case $.CS.LineBeginning:r=i;break;case $.CS.LineEnd:r=i,x=!0}const y=e.length;let a,P=0,b=e[0];for(let w=1;w<y;++w){a=b,b=e[w];const L=this._curveHelper.calculateLength(a,b);if(P+L>r){const A=(r-P)/L,[ot,lt]=this._curveHelper.getAngleCS(a,b,A),gt=(0,Dt.XV)(a,b,A),xt=x?-this._offset:this._offset;return this.internalPlacement.setTranslate(gt[0]-xt*lt,gt[1]+xt*ot),this._angleToLine&&(x?this.internalPlacement.setRotateCS(-ot,-lt):this.internalPlacement.setRotateCS(ot,lt)),this.internalPlacement}P+=L}return null}}let z=(()=>{class S{static local(){return null===S.instance&&(S.instance=new S),S.instance}execute(i,r,x,y){return new j(i,r,x)}}return S.instance=null,S})();class j extends Dt.v1{constructor(e,i,r){super(e,!0,!0),this._curveHelper=new Lt,this._angleToLine=void 0===i.angleToLine||i.angleToLine,this._offset=void 0!==i.offset?i.offset*r:0,this._endPoints=void 0===i.placeOnEndPoints||i.placeOnEndPoints,this._controlPoints=void 0===i.placeOnControlPoints||i.placeOnControlPoints,this._regularVertices=void 0===i.placeOnRegularVertices||i.placeOnRegularVertices,this._tags=[],this._tagIterator=0}processPath(e){if(this.iteratePath||(this._preparePath(e),this.iteratePath=!0),this._tagIterator>=this._tags.length)return this._tags.length=0,this._tagIterator=0,this.iteratePath=!1,null;const i=this._tags[this._tagIterator];this._angleToLine&&this.internalPlacement.setRotate(i[2]);let r=i[0],x=i[1];if(0!==this._offset){const y=Math.cos(i[2]),a=Math.sin(i[2]);r-=this._offset*a,x+=this._offset*y}return this.internalPlacement.setTranslate(r,x),this._tagIterator++,this.internalPlacement}_preparePath(e){this._tags.length=0,this._tagIterator=0;const i=(0,Dt.QK)(e),r=e.length-1;let x,y,a=0,P=0,b=0,w=0,L=0;for(;a<r;){a++,x=e[a-1],y=e[a];const A=(0,Dt.zv)(x),ot=(0,Dt.zv)(y);(this._angleToLine||0!==this._offset)&&(w=this._curveHelper.getAngle(x,y,0)),1===a?i?(P=w,b=A):(this._endPoints||this._controlPoints&&1===A)&&this._tags.push([x[0],x[1],w]):1===A?this._controlPoints&&this._tags.push([x[0],x[1],ct(L,w)]):this._regularVertices&&this._tags.push([x[0],x[1],ct(L,w)]),(this._angleToLine||0!==this._offset)&&(L=this._curveHelper.getAngle(x,y,1)),a===r&&(i?1===ot||1===b?this._controlPoints&&this._tags.push([y[0],y[1],ct(L,P)]):this._regularVertices&&this._tags.push([y[0],y[1],ct(L,P)]):(this._endPoints||this._controlPoints&&1===ot)&&this._tags.push([y[0],y[1],L]))}this._tagIterator=0}}function ct(S,e){const i=Math.PI;for(;Math.abs(e-S)>i+2e-15;)e-S>i?e-=2*i:e+=2*i;return(S+e)/2}var st=at(8314),tt=at(27105),it=at(62208);class Mt{constructor(e=vt){this._data=[],this._compare=e}get size(){return this._data.length}enqueue(e){if(null==e)return;const{_data:i,_compare:r}=this;i.push(e);let x=i.length-1>>>0;const y=i[x];for(;x>0;){const a=x-1>>1,P=i[a];if(!(r(P,y)<=0))break;i[a]=y,i[x]=P,x=a}}dequeue(){const{_data:e,_compare:i}=this,r=e[0],x=e.pop();if(0===e.length)return r;e[0]=x;let y=0;const a=e.length,P=e[0];let b,w,L=null;for(;;){const A=2*y+1,ot=2*y+2;if(L=null,A<a&&(b=e[A],i(b,P)>0&&(L=A)),ot<a&&(w=e[ot],(null===L&&i(w,P)<=0||null!==L&&i(w,b)<=0)&&(L=ot)),null===L)break;e[y]=e[L],e[L]=P,y=L}return r}}const vt=(S,e)=>S<e?-1:S>e?1:0;var Ft=at(25748),Ot=at(11519);function Jt(S,e){const{rings:i}=e;let r=0;for(const x of i){const y=x.length;for(let a=1;a<y;++a){const P=x[a-1],b=x[a];P[1]>S[1]!=b[1]>S[1]&&((b[0]-P[0])*(S[1]-P[1])-(b[1]-P[1])*(S[0]-P[0])>0?r++:r--)}}return 0!==r}function $t(S,e,i){if(i&&Jt(S,e))return{coord:S,distance:0};let r=1/0,x=0,y=0;const a=[0,0],{rings:P}=e;for(const b of P)if(!(b.length<2))for(let w=0;w<b.length-1;w++){(0,Ft.Tx)(a,S,b,w);const L=ue(S,a);L<r&&(r=L,x=a[0],y=a[1])}return{coord:[x,y],distance:Math.sqrt(r)}}function Qt(S,e,i,r){const x=[e,0];let y=1/0,a=1/0,P=!1,b=!1;const w=[[e,r[1]-1],[e,r[3]+1]],L=[0,0],A=[0,0],ot=[0,0],lt=[[0,0],[0,0]],gt=(0,ie.Ue)(),{rings:xt}=S;for(const Et of xt)if(!(Et.length<2))for(let Yt=1;Yt<Et.length;Yt++){if(lt[0][0]=Et[Yt-1][0],lt[0][1]=Et[Yt-1][1],lt[1][0]=Et[Yt][0],lt[1][1]=Et[Yt][1],null===he(gt,lt)||(A[0]=w[0][0],A[1]=w[0][1],ot[0]=w[1][0],ot[1]=w[1][1],0===Se(gt,A,ot))||!(0,Ot.UT)(w[0],w[1],lt[0],lt[1],L))continue;const ae=L[1];y>a?ae<y&&(y=ae,P=!0):ae<a&&(a=ae,b=!0)}return P&&b?x[1]=(y+a)/2:x[0]=x[1]=NaN,x}function he(S,e){if(e.length<2)return null;S||(S=(0,ie.Ue)());const[i,r]=e[0],[x,y]=e[1];return S[0]=Math.min(i,x),S[1]=Math.min(r,y),S[2]=Math.max(i,x),S[3]=Math.max(r,y),S}function Se(S,e,i){let r=ge(e,S),x=ge(i,S);const y=S[0],a=S[1],P=S[2],b=S[3];if(r&x)return 0;if(!(r|x))return 4;const w=(r?1:0)|(x?2:0);do{const L=i[0]-e[0],A=i[1]-e[1];if(L>A)3&r?(1&r?(e[1]+=A*(y-e[0])/L,e[0]=y):(e[1]+=A*(P-e[0])/L,e[0]=P),r=ge(e,S)):3&x?(1&x?(i[1]+=A*(y-i[0])/L,i[0]=y):(i[1]+=A*(P-i[0])/L,i[0]=P),x=ge(i,S)):r?(4&r?(e[0]+=L*(a-e[1])/A,e[1]=a):(e[0]+=L*(b-e[1])/A,e[1]=b),r=ge(e,S)):(4&x?(i[0]+=L*(a-i[1])/A,i[1]=a):(i[0]+=L*(b-i[1])/A,i[1]=b),x=ge(i,S));else if(12&r?(4&r?(e[0]+=L*(a-e[1])/A,e[1]=a):(e[0]+=L*(b-e[1])/A,e[1]=b),r=ge(e,S)):12&x?(4&x?(i[0]+=L*(a-i[1])/A,i[1]=a):(i[0]+=L*(b-i[1])/A,i[1]=b),x=ge(i,S)):r?(1&r?(e[1]+=A*(y-e[0])/L,e[0]=y):(e[1]+=A*(P-e[0])/L,e[0]=P),r=ge(e,S)):(1&x?(i[1]+=A*(y-i[0])/L,i[0]=y):(i[1]+=A*(P-i[0])/L,i[0]=P),x=ge(i,S)),r&x)return 0}while(r|x);return w}function ge(S,e){return(S[0]<e[0]?1:0)|(S[0]>e[2]?1:0)<<1|(S[1]<e[1]?1:0)<<2|(S[1]>e[3]?1:0)<<3}function ye(S,e,i){return S+(e-S)*i}function ue(S,e){return(S[0]-e[0])*(S[0]-e[0])+(S[1]-e[1])*(S[1]-e[1])}function Ce(S,e){if(S<e)return-1;if(S>e)return 1;if(S===e)return 0;const i=isNaN(S),r=isNaN(e);return i<r?-1:i>r?1:0}class xe{constructor(e,i,r,x){this.x=e,this.y=i,this.cellSize=r,this.distancefromCellCenter=(0,Ft.ko)(e,i,x),this.maxDistanceToPolygon=this.distancefromCellCenter+this.cellSize*Math.SQRT2}}let Me=(()=>{class S{static local(){return null===S.instance&&(S.instance=new S),S.instance}execute(i,r,x,y){return new Ee(i,r,x)}}return S.instance=null,S})();class Ee{constructor(e,i,r){this._geometry=e,this._offsetX=void 0!==i.offsetX?i.offsetX*r:0,this._offsetY=void 0!==i.offsetY?i.offsetY*r:0,this._method=void 0!==i.method?i.method:$.Lh.OnPolygon,this._internalPlacement=new U.u}next(){const e=this._geometry;return this._geometry=null,e&&function Te(S){return void 0!==S.rings}(e)?this._polygonCenter(e):null}_polygonCenter(e){let i=!1;switch(this._method){case $.Lh.CenterOfMass:{const r=(0,tt.NA)(e);r&&(this._internalPlacement.setTranslate(r[0]+this._offsetX,r[1]+this._offsetY),i=!0)}break;case $.Lh.BoundingBoxCenter:{const r=(0,ie.Ue)();(0,ne.$P)(r,e),r&&(this._internalPlacement.setTranslate((r[2]+r[0])/2+this._offsetX,(r[3]+r[1])/2+this._offsetY),i=!0)}break;default:{let r;r=(0,st.Z)("polylabel-placement-enabled")?function Ne(S){if(!S||!S.rings||0===S.rings.length)return null;const e=(0,ne.lC)((0,ie.Ue)(),S.rings[0]);if(!e)return null;const i=e[2]-e[0],r=e[3]-e[1];if(0===i||0===r)return[e[0]+i/2,e[1]+r/2];const x=Math.max(Math.min(i,r)/100,1),y=new Mt((lt,gt)=>gt.maxDistanceToPolygon-lt.maxDistanceToPolygon),a=Math.min(i,r);let P=a/2,b=0,w=0;for(b=e[0];b<e[2];b+=a)for(w=e[1];w<e[3];w+=a)y.enqueue(new xe(b+P,w+P,P,S));const L=(0,tt.a)(S.rings,!1);if(null===L)return null;let A,ot=new xe(L[0],L[1],0,S);for(;y.size>0;)A=(0,it.Wg)(y.dequeue()),A.distancefromCellCenter>ot.distancefromCellCenter&&(ot=A),A.maxDistanceToPolygon-ot.distancefromCellCenter<=x||(P=A.cellSize/2,y.enqueue(new xe(A.x-P,A.y-P,P,S)),y.enqueue(new xe(A.x+P,A.y-P,P,S)),y.enqueue(new xe(A.x-P,A.y+P,P,S)),y.enqueue(new xe(A.x+P,A.y+P,P,S)));return[ot.x,ot.y]}(e):function ee(S){const{rings:e}=S;if(!e||0===e.length)return null;const i=(0,ne.$P)((0,ie.Ue)(),S);if(!i)return null;const r=4*(Math.abs(i[0])+Math.abs(i[2])+Math.abs(i[1])+Math.abs(i[3])+1)*222045e-19;let x=0,y=0;for(let Pe=0;Pe<e.length;Pe++){const we=(0,Ft.Sm)(e[Pe]);we>y&&(y=we,x=Pe)}if(Math.abs(y)<=2*r*r){const Pe=(0,ne.lC)((0,ie.Ue)(),e[x]);return[(Pe[0]+Pe[2])/2,(Pe[1]+Pe[3])/2]}const a=(0,tt.DS)(e[x],!1,(0,ie.Ue)());if(null===a)return null;if(1===e.length&&e[0].length<4)return a;const P=[[NaN,NaN],[NaN,NaN],[NaN,NaN],[NaN,NaN]],b=[NaN,NaN,NaN,NaN],w=[NaN,NaN,NaN,NaN];let L=!1,A=$t(a,S,!0);0===A.distance&&(L=!0,P[0][0]=a[0],P[0][1]=a[1],A=$t(a,S,!1)),b[0]=A.distance,w[0]=0;const ot=[NaN,NaN];let lt=!1,gt=.25,xt=-1;const Et=(0,ne.lC)((0,ie.Ue)(),e[x]);let Yt=NaN;do{if(Yt=NaN,P[1]=Qt(S,ye(Et[0],Et[2],gt),0,i),isNaN(P[1][0])||isNaN(P[1][1])||(A=$t(P[1],S,!1),Yt=A.distance),!isNaN(Yt)&&Yt>r&&Jt(P[1],S))lt=!0,b[1]=Yt,w[1]=ue(P[1],a);else if(!isNaN(Yt)&&Yt>xt&&(xt=Yt,ot[0]=P[1][0],ot[1]=P[1][1]),gt-=.01,gt<.1){if(!(xt>=0))break;lt=!0,b[1]=xt,P[1][0]=ot[0],P[1][1]=ot[1],w[1]=ue(P[1],a)}}while(!lt);lt=!1,gt=.5,xt=-1;let ae=.01,ce=1;do{if(Yt=NaN,P[2]=Qt(S,ye(Et[0],Et[2],gt),0,i),isNaN(P[2][0])||isNaN(P[2][1])||(A=$t(P[2],S,!1),Yt=A.distance),!isNaN(Yt)&&Yt>r&&Jt(P[2],S))lt=!0,b[2]=Yt,w[2]=ue(P[2],a);else if(!isNaN(Yt)&&Yt>xt)xt=Yt,ot[0]=P[2][0],ot[1]=P[2][1];else if(Yt>xt&&(xt=Yt,ot[0]=P[2][0],ot[1]=P[2][1]),gt=.5+ae*ce,ae+=.01,ce*=-1,gt<.3||gt>.7){if(!(xt>=0))break;lt=!0,b[2]=xt,P[2][0]=ot[0],P[2][1]=ot[1],w[2]=ue(P[2],a)}}while(!lt);lt=!1,gt=.75,xt=-1;do{if(Yt=NaN,P[3]=Qt(S,ye(Et[0],Et[2],gt),0,i),isNaN(P[3][0])||isNaN(P[3][1])||(A=$t(P[3],S,!1),Yt=A.distance),!isNaN(Yt)&&Yt>r&&Jt(P[3],S))lt=!0,b[3]=Yt,w[3]=ue(P[3],a);else if(Yt>xt&&(xt=Yt,ot[0]=P[3][0],ot[1]=P[3][1]),gt+=.01,gt>.9){if(!(xt>=0))break;lt=!0,b[3]=xt,P[3][0]=ot[0],P[3][1]=ot[1],w[3]=ue(P[3],a)}}while(!lt);const qt=[0,1,2,3],Oe=L?0:1;let ze;for(let Pe=Oe;Pe<4;Pe++)for(let we=Oe;we<3;we++){const Ge=w[we],He=w[we+1];Ce(Ge,He)>0&&(ze=qt[we],qt[we]=qt[we+1],qt[we+1]=ze,w[we]=He,w[we+1]=Ge)}let De=Oe,Fe=0,Re=0;for(let Pe=Oe;Pe<4;Pe++){switch(Pe){case 0:Re=2*b[qt[Pe]];break;case 1:Re=1.66666666*b[qt[Pe]];break;case 2:Re=1.33333333*b[qt[Pe]];break;case 3:Re=b[qt[Pe]]}Re>Fe&&(Fe=Re,De=qt[Pe])}return P[De]}(e),null!==r&&(this._internalPlacement.setTranslate(r[0]+this._offsetX,r[1]+this._offsetY),i=!0)}}return i?this._internalPlacement:null}}function Ae(S){if(!S)return null;switch(S.type){case"CIMGeometricEffectAddControlPoints":return Bt.local();case"CIMGeometricEffectArrow":return Zt.local();case"CIMGeometricEffectBuffer":return _t.local();case"CIMGeometricEffectControlMeasureLine":return nt.local();case"CIMGeometricEffectCut":return Xt.local();case"CIMGeometricEffectDashes":return ut.local();case"CIMGeometricEffectDonut":return St.local();case"CIMGeometricEffectJog":return Ht.local();case"CIMGeometricEffectMove":return Gt.local();case"CIMGeometricEffectOffset":return re.local();case"CIMGeometricEffectReverse":return oe.local();case"CIMGeometricEffectRotate":return It.local();case"CIMGeometricEffectScale":return I.local();case"CIMGeometricEffectWave":return R.local()}return null}function Ie(S){if(!S)return null;switch(S.type){case"CIMMarkerPlacementAlongLineSameSize":return ft.local();case"CIMMarkerPlacementAtExtremities":return Ct.local();case"CIMMarkerPlacementAtRatioPositions":return v.local();case"CIMMarkerPlacementInsidePolygon":return J.local();case"CIMMarkerPlacementOnLine":return n.local();case"CIMMarkerPlacementOnVertices":return z.local();case"CIMMarkerPlacementPolygonCenter":return Me.local()}return null}},97373:(ve,fe,at)=>{at.d(fe,{u:()=>At});class At{constructor(){this.setIdentity()}getAngle(){return(null==this.rz||0===this.rz&&1!==this.rzCos&&0!==this.rzSin)&&(this.rz=Math.atan2(this.rzSin,this.rzCos)),this.rz}setIdentity(){this.tx=0,this.ty=0,this.tz=0,this.s=1,this.rx=0,this.ry=0,this.rz=0,this.rzCos=1,this.rzSin=0}setTranslate(Bt,se){this.tx=Bt,this.ty=se}setTranslateZ(Bt){this.tz=Bt}setRotateCS(Bt,se){this.rz=void 0,this.rzCos=Bt,this.rzSin=se}setRotate(Bt){this.rz=Bt,this.rzCos=void 0,this.rzSin=void 0}setRotateY(Bt){this.ry=Bt}setScale(Bt){this.s=Bt}setMeasure(Bt){this.m=Bt}}},26933:(ve,fe,at)=>{at.d(fe,{cD:()=>Vt,uQ:()=>kt,zA:()=>ht}),at(986);var yt=at(17002),Dt=at(58817),Bt=at(63290),se=at(62208),$=at(27899),zt=at(23841),pt=at(65401),Lt=at(32442),dt=at(27105),Tt=at(91179),Kt=at(29214),Zt=at(91558);class et{applyColorSubstituition(h,I){if(!I)return h;this._rasterizationCanvas||(this._rasterizationCanvas=document.createElement("canvas"));const{width:Y,height:R}=h,Z=this._rasterizationCanvas,ft=Z.getContext("2d");h!==Z&&(Z.width=Y,Z.height=R,ft.drawImage(h,0,0,Y,R));const q=ft.getImageData(0,0,Y,R).data;if(I)for(const N of I)if(N&&N.oldColor&&4===N.oldColor.length&&N.newColor&&4===N.newColor.length){const[v,k,E,U]=N.oldColor,[F,J,K,W]=N.newColor;if(v===F&&k===J&&E===K&&U===W)continue;for(let n=0;n<q.length;n+=4)v===q[n]&&k===q[n+1]&&E===q[n+2]&&U===q[n+3]&&(q[n]=F,q[n+1]=J,q[n+2]=K,q[n+3]=W)}const Ct=new ImageData(q,Y,R);return ft.putImageData(Ct,0,0),Z}tintImageData(h,I){if(!I)return h;this._rasterizationCanvas||(this._rasterizationCanvas=document.createElement("canvas"));const{width:Y,height:R}=h,Z=this._rasterizationCanvas,ft=Z.getContext("2d");h!==Z&&(Z.width=Y,Z.height=R,ft.drawImage(h,0,0,Y,R));const q=ft.getImageData(0,0,Y,R),Ct=new Uint8Array(q.data),N=new Zt.Z(I),v=[N.r/255,N.g/255,N.b/255,N.a];for(let E=0;E<Ct.length;E+=4)Ct[E+0]*=v[0],Ct[E+1]*=v[1],Ct[E+2]*=v[2],Ct[E+3]*=v[3];const k=new ImageData(new Uint8ClampedArray(Ct.buffer),Y,R);return ft.putImageData(k,0,0),Z}}var _t=at(95727),Nt=at(97373),nt=at(7547);function Ut(It){const h=It.getFrame(0);if(h instanceof HTMLImageElement||h instanceof HTMLCanvasElement)return h;const I=document.createElement("canvas");I.width=It.width,I.height=It.height;const Y=I.getContext("2d");return h instanceof ImageData?Y.putImageData(h,0,0):Y.drawImage(h,0,0),I}var Xt=at(31375),jt=at(68937),Wt=at(80991);at(40028),at(39351),at(25797);const bt=Math.PI/180,ut=Bt.Z.getLogger("esri.symbols.cim.CIMSymbolDrawHelper");class ht{constructor(h){this._t=h}static createIdentity(){return new ht([1,0,0,0,1,0])}clone(){return new ht(this._t.slice())}transform(h){const I=this._t;return[I[0]*h[0]+I[1]*h[1]+I[2],I[3]*h[0]+I[4]*h[1]+I[5]]}static createScale(h,I){return new ht([h,0,0,0,I,0])}scale(h,I){const Y=this._t;return Y[0]*=h,Y[1]*=h,Y[2]*=h,Y[3]*=I,Y[4]*=I,Y[5]*=I,this}scaleRatio(){return Math.sqrt(this._t[0]*this._t[0]+this._t[1]*this._t[1])}static createTranslate(h,I){return new ht([0,0,h,0,0,I])}translate(h,I){const Y=this._t;return Y[2]+=h,Y[5]+=I,this}static createRotate(h){const I=Math.cos(h),Y=Math.sin(h);return new ht([I,-Y,0,Y,I,0])}rotate(h){return ht.multiply(this,ht.createRotate(h),this)}angle(){const h=this._t[0],I=this._t[3],Y=Math.sqrt(h*h+I*I);return[h/Y,I/Y]}static multiply(h,I,Y){const R=h._t,Z=I._t,q=R[1]*Z[0]+R[4]*Z[1],Ct=R[2]*Z[0]+R[5]*Z[1]+Z[2],N=R[0]*Z[3]+R[3]*Z[4],v=R[1]*Z[3]+R[4]*Z[4],k=R[2]*Z[3]+R[5]*Z[4]+Z[5],E=Y._t;return E[0]=R[0]*Z[0]+R[3]*Z[1],E[1]=q,E[2]=Ct,E[3]=N,E[4]=v,E[5]=k,Y}invert(){const h=this._t;let I=h[0]*h[4]-h[1]*h[3];return 0===I?new ht([0,0,0,0,0,0]):(I=1/I,new ht([h[4]*I,-h[1]*I,(h[1]*h[5]-h[2]*h[4])*I,-h[3]*I,h[0]*I,(h[2]*h[3]-h[0]*h[5])*I]))}}class St{constructor(h,I){this._resourceManager=h,this._transfos=[],this._sizeTransfos=[],this._geomUnitsPerPoint=1,this._placementPool=new $.Z(Nt.u,void 0,void 0,100),this._earlyReturn=!1,this._mapRotation=0,this._transfos.push(I||ht.createIdentity()),this._sizeTransfos.push(I?I.scaleRatio():1)}setTransform(h,I){this._transfos=[h||ht.createIdentity()],this._sizeTransfos=[I||(h?h.scaleRatio():1)]}setGeomUnitsPerPoint(h){this._geomUnitsPerPoint=h}transformPt(h){return this._transfos[this._transfos.length-1].transform(h)}transformSize(h){return h*this._sizeTransfos[this._sizeTransfos.length-1]}reverseTransformPt(h){return this._transfos[this._transfos.length-1].invert().transform(h)}reverseTransformSize(h){return h/this._sizeTransfos[this._sizeTransfos.length-1]}getTransformAngle(){return this._transfos[this._transfos.length-1].angle()}geomUnitsPerPoint(){return this.isEmbedded()?1:this._geomUnitsPerPoint}isEmbedded(){return this._transfos.length>1}back(){return this._transfos[this._transfos.length-1]}push(h,I){const Y=I?h.scaleRatio():1;ht.multiply(h,this.back(),h),this._transfos.push(h),this._sizeTransfos.push(this._sizeTransfos[this._sizeTransfos.length-1]*Y)}pop(){this._transfos.splice(-1,1),this._sizeTransfos.splice(-1,1)}drawSymbol(h,I,Y){if(h)switch(h.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":this.drawMultiLayerSymbol(h,I);break;case"CIMTextSymbol":this.drawTextSymbol(h,I,Y)}}drawMultiLayerSymbol(h,I){if(!h)return;const Y=h.symbolLayers;if(!Y)return;const R=h.effects;if(R&&R.length>0){const Z=this.executeEffects(R,I);if(Z){let ft=Z.next();for(;ft;)this.drawSymbolLayers(Y,ft),ft=Z.next()}}else this.drawSymbolLayers(Y,I)}executeEffects(h,I){const Y=this._resourceManager.geometryEngine;let R=new Kt.M(I);for(const Z of h){const ft=(0,_t.h)(Z);ft&&(R=ft.execute(R,Z,this.geomUnitsPerPoint(),Y))}return R}drawSymbolLayers(h,I){let Y=h.length;for(;Y--;){const R=h[Y];if(!R||!1===R.enable)continue;const Z=R.effects;if(Z&&Z.length>0){const ft=this.executeEffects(Z,I);if(ft){let q=null;for(;(q=ft.next())&&(this.drawSymbolLayer(R,q),!this._earlyReturn););}}else this.drawSymbolLayer(R,I);if(this._earlyReturn)return}}drawSymbolLayer(h,I){switch(h.type){case"CIMSolidFill":this.drawSolidFill(I,h.color);break;case"CIMHatchFill":this.drawHatchFill(I,h);break;case"CIMPictureFill":this.drawPictureFill(I,h);break;case"CIMGradientFill":this.drawGradientFill(I,h);break;case"CIMSolidStroke":this.drawSolidStroke(I,h.color,h.width,h.capStyle,h.joinStyle,h.miterLimit);break;case"CIMPictureStroke":this.drawPictureStroke(I,h);break;case"CIMGradientStroke":this.drawGradientStroke(I,h);break;case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":this.drawMarkerLayer(h,I)}}drawHatchFill(h,I){const Y=this._buildHatchPolyline(I,h,this.geomUnitsPerPoint());Y&&(this.pushClipPath(h),this.drawMultiLayerSymbol(I.lineSymbol,Y),this.popClipPath())}drawPictureFill(h,I){}drawGradientFill(h,I){}drawPictureStroke(h,I){}drawGradientStroke(h,I){}drawMarkerLayer(h,I){const Y=h.markerPlacement;if(Y){const R=(0,_t.W)(Y);if(R){const Z="CIMMarkerPlacementInsidePolygon"===Y.type||"CIMMarkerPlacementPolygonCenter"===Y.type&&Y.clipAtBoundary;Z&&this.pushClipPath(I);const ft=R.execute(I,Y,this.geomUnitsPerPoint(),this._resourceManager.geometryEngine);if(ft){let q=null;for(;(q=ft.next())&&(this.drawMarker(h,q),!this._earlyReturn););}Z&&this.popClipPath()}}else{const R=this._placementPool.acquire();if((0,Tt.wp)(I))R.tx=I.x,R.ty=I.y,this.drawMarker(h,R);else if((0,Tt.oU)(I))[R.tx,R.ty]=(0,dt.tO)(I),this.drawMarker(h,R);else for(const Z of I.points)if(R.tx=Z[0],R.ty=Z[1],this.drawMarker(h,R),this._earlyReturn)break;this._placementPool.release(R)}}drawMarker(h,I){switch(h.type){case"CIMCharacterMarker":case"CIMPictureMarker":this.drawPictureMarker(h,I);break;case"CIMVectorMarker":this.drawVectorMarker(h,I)}}drawPictureMarker(h,I){if(!h)return;const Y=this._resourceManager.getResource(h.url),R=h.size??10;if((0,se.Wi)(Y)||R<=0)return;const Z=Y.width,ft=Y.height;if(!Z||!ft)return;const q=Z/ft,Ct=h.scaleX??1,N=ht.createIdentity(),v=h.anchorPoint;if(v){let K=v.x,W=v.y;"Absolute"!==h.anchorPointUnits&&(K*=R*q*Ct,W*=R),N.translate(-K,-W)}let k=h.rotation??0;h.rotateClockwise&&(k=-k),this._mapRotation&&(k+=this._mapRotation),k&&N.rotate(k*bt);let E=h.offsetX??0,U=h.offsetY??0;if(E||U){if(this._mapRotation){const K=bt*this._mapRotation,W=Math.cos(K),n=Math.sin(K),O=E*n+U*W;E=E*W-U*n,U=O}N.translate(E,U)}const F=this.geomUnitsPerPoint();1!==F&&N.scale(F,F);const J=I.getAngle();J&&N.rotate(J),N.translate(I.tx,I.ty),this.push(N,!1),this.drawImage(h,R),this.pop()}drawVectorMarker(h,I){if(!h)return;const Y=h.markerGraphics;if(!Y)return;const R=h.size??10,Z=h.frame,ft=Z?Z.ymax-Z.ymin:0,q=R&&ft?R/ft:1,Ct=ht.createIdentity();Z&&Ct.translate(.5*-(Z.xmax+Z.xmin),.5*-(Z.ymax+Z.ymin));const N=h.anchorPoint;if(N){let J=N.x,K=N.y;"Absolute"!==h.anchorPointUnits?Z&&(J*=Z.xmax-Z.xmin,K*=Z.ymax-Z.ymin):(J/=q,K/=q),Ct.translate(-J,-K)}1!==q&&Ct.scale(q,q);let v=h.rotation??0;h.rotateClockwise&&(v=-v),this._mapRotation&&(v+=this._mapRotation),v&&Ct.rotate(v*bt);let k=h.offsetX??0,E=h.offsetY??0;if(k||E){if(this._mapRotation){const J=bt*this._mapRotation,K=Math.cos(J),W=Math.sin(J),n=k*W+E*K;k=k*K-E*W,E=n}Ct.translate(k,E)}const U=this.geomUnitsPerPoint();1!==U&&Ct.scale(U,U);const F=I.getAngle();F&&Ct.rotate(F),Ct.translate(I.tx,I.ty),this.push(Ct,h.scaleSymbolsProportionally);for(const J of Y)if(J&&J.symbol&&J.geometry||ut.error("Invalid marker graphic",J),this.drawSymbol(J.symbol,J.geometry,J.textString),this._earlyReturn)break;this.pop()}drawTextSymbol(h,I,Y){if(!h||!(0,Tt.wp)(I)||(h.height??10)<=0)return;const R=ht.createIdentity();let Z=h.angle??0;Z=-Z,Z&&R.rotate(Z*bt);const ft=h.offsetX??0,q=h.offsetY??0;(ft||q)&&R.translate(ft,q);const Ct=this.geomUnitsPerPoint();1!==Ct&&R.scale(Ct,Ct),R.translate(I.x,I.y),this.push(R,!1),this.drawText(h,Y),this.pop()}_buildHatchPolyline(h,I,Y){let R=(void 0!==h.separation?h.separation:4)*Y,Z=void 0!==h.rotation?h.rotation:0;if(0===R)return null;R<0&&(R=-R);let ft=0;const q=.5*R;for(;ft>q;)ft-=R;for(;ft<-q;)ft+=R;const Ct=(0,pt.Ue)();(0,Lt.$P)(Ct,I),Ct[0]-=q,Ct[1]-=q,Ct[2]+=q,Ct[3]+=q;const N=[[Ct[0],Ct[1]],[Ct[0],Ct[3]],[Ct[2],Ct[3]],[Ct[2],Ct[1]]];for(;Z>180;)Z-=180;for(;Z<0;)Z+=180;const v=Math.cos(Z*bt),k=Math.sin(Z*bt),E=-R*k,U=R*v;let F,J,K,W;ft=(void 0!==h.offsetX?h.offsetX*Y:0)*k-(void 0!==h.offsetY?h.offsetY*Y:0)*v,F=K=Number.MAX_VALUE,J=W=-Number.MAX_VALUE;for(const st of N){const tt=st[0],it=st[1],Mt=v*tt+k*it,vt=-k*tt+v*it;F=Math.min(F,Mt),K=Math.min(K,vt),J=Math.max(J,Mt),W=Math.max(W,vt)}K=Math.floor(K/R)*R;let n=v*F-k*K-E*ft/R,O=k*F+v*K-U*ft/R,z=v*J-k*K-E*ft/R,mt=k*J+v*K-U*ft/R;const j=1+Math.round((W-K)/R),ct=[];for(let st=0;st<j;st++)n+=E,O+=U,z+=E,mt+=U,ct.push([[n,O],[z,mt]]);return{paths:ct}}}class kt extends St{constructor(h,I){super(h,I),this.reset()}reset(){this._xmin=this._ymin=1/0,this._xmax=this._ymax=-1/0,this._clipCount=0}envelope(){return new Xt.Z(this._xmin,this._ymin,this._xmax-this._xmin,this._ymax-this._ymin)}bounds(){return(0,pt.al)(this._xmin,this._ymin,this._xmax,this._ymax)}drawSolidFill(h){if(h&&!(this._clipCount>0))if((0,Tt.oU)(h))this._processPath(h.rings,0);else if((0,Tt.l9)(h))this._processPath(h.paths,0);else if((0,Tt.YX)(h)){const I=wt(h);I&&this._processPath(I.rings,0)}else console.error("drawSolidFill Unexpected geometry type!")}drawSolidStroke(h,I,Y){if(!h||this._clipCount>0)return;const R=.5*this.transformSize(Y);if((0,Tt.oU)(h))this._processPath(h.rings,R);else if((0,Tt.l9)(h))this._processPath(h.paths,R);else if((0,Tt.YX)(h)){const Z=wt(h);Z&&this._processPath(Z.rings,R)}else console.error("drawSolidStroke unexpected geometry type!")}drawMarkerLayer(h,I){(0,Tt.oU)(I)&&h.markerPlacement&&("CIMMarkerPlacementInsidePolygon"===h.markerPlacement.type||"CIMMarkerPlacementPolygonCenter"===h.markerPlacement.type&&h.markerPlacement.clipAtBoundary)?this._processPath(I.rings,0):super.drawMarkerLayer(h,I)}drawHatchFill(h,I){this.drawSolidFill(h)}drawPictureFill(h,I){this.drawSolidFill(h)}drawGradientFill(h,I){this.drawSolidFill(h)}drawPictureStroke(h,I){this.drawSolidStroke(h,null,I.width)}drawGradientStroke(h,I){this.drawSolidStroke(h,null,I.width)}pushClipPath(h){this.drawSolidFill(h),this._clipCount++}popClipPath(){this._clipCount--}drawImage(h,I){const{url:Y}=h,R=h.scaleX??1;let Z=R*I,ft=I;const q=this._resourceManager.getResource(Y);!I&&(0,se.pC)(q)&&(Z=R*q.width,ft=q.height),this._merge(this.transformPt([-Z/2,-ft/2]),0),this._merge(this.transformPt([-Z/2,ft/2]),0),this._merge(this.transformPt([Z/2,-ft/2]),0),this._merge(this.transformPt([Z/2,ft/2]),0)}drawText(h,I){if(!I||0===I.length)return;this._textRasterizer||(this._textRasterizer=new jt.Z);const Y=pe(h),[R,Z]=this._textRasterizer.computeTextSize(I,Y);let ft=0;switch(h.horizontalAlignment){case"Left":ft=R/2;break;case"Right":ft=-R/2}let q=0;switch(h.verticalAlignment){case"Bottom":q=Z/2;break;case"Top":q=-Z/2;break;case"Baseline":q=Z/6}this._merge(this.transformPt([-R/2+ft,-Z/2+q]),0),this._merge(this.transformPt([-R/2+ft,Z/2+q]),0),this._merge(this.transformPt([R/2+ft,-Z/2+q]),0),this._merge(this.transformPt([R/2+ft,Z/2+q]),0)}_processPath(h,I){if(h)for(const Y of h){const R=Y?Y.length:0;if(R>1){this._merge(this.transformPt(Y[0]),I);for(let Z=1;Z<R;Z++)this._merge(this.transformPt(Y[Z]),I)}}}_merge(h,I){h[0]-I<this._xmin&&(this._xmin=h[0]-I),h[0]+I>this._xmax&&(this._xmax=h[0]+I),h[1]-I<this._ymin&&(this._ymin=h[1]-I),h[1]+I>this._ymax&&(this._ymax=h[1]+I)}}class Vt extends St{constructor(h,I,Y,R){super(I,Y),this._applyAdditionalRenderProps=R,this._colorSubstitutionHelper=new et,this._ctx=h}drawSolidFill(h,I){if(!h)return;if((0,Tt.oU)(h))this._buildPath(h.rings,!0);else if((0,Tt.l9)(h))this._buildPath(h.paths,!0);else if((0,Tt.YX)(h))this._buildPath(wt(h).rings,!0);else{if(!(0,Tt.aW)(h))return;console.log("CanvasDrawHelper.drawSolidFill - No implementation!")}const Y=this._ctx;Y.fillStyle="string"==typeof I?I:"rgba("+Math.round(I[0])+","+Math.round(I[1])+","+Math.round(I[2])+","+I[3]/255+")",Y.fill("evenodd")}drawSolidStroke(h,I,Y,R,Z,ft){if(!h||!I||0===Y)return;if((0,Tt.oU)(h))this._buildPath(h.rings,!0);else if((0,Tt.l9)(h))this._buildPath(h.paths,!1);else{if(!(0,Tt.YX)(h))return void console.log("CanvasDrawHelper.drawSolidStroke isn't implemented!");this._buildPath(wt(h).rings,!0)}const q=this._ctx;q.strokeStyle="string"==typeof I?I:"rgba("+Math.round(I[0])+","+Math.round(I[1])+","+Math.round(I[2])+","+I[3]/255+")",q.lineWidth=Math.max(this.transformSize(Y),.5),this._setCapStyle(R),this._setJoinStyle(Z),q.miterLimit=ft,q.stroke()}pushClipPath(h){if(this._ctx.save(),(0,Tt.oU)(h))this._buildPath(h.rings,!0);else if((0,Tt.l9)(h))this._buildPath(h.paths,!0);else{if(!(0,Tt.YX)(h))return;this._buildPath(wt(h).rings,!0)}this._ctx.clip("evenodd")}popClipPath(){this._ctx.restore()}drawImage(h,I){const{colorSubstitutions:Y,url:R,tintColor:Z}=h,ft=h.scaleX??1,q=this._resourceManager.getResource(R);if((0,se.Wi)(q))return;let Ct=I*(q.width/q.height),N=I;I||(Ct=q.width,N=q.height);const v=(0,Wt.TB)(R)||"src"in q&&(0,Wt.TB)(q.src);let k="getFrame"in q?Ut(q):q;Y&&(k=this._colorSubstitutionHelper.applyColorSubstituition(k,Y)),this._applyAdditionalRenderProps&&!v&&Z&&(k=this._colorSubstitutionHelper.tintImageData(k,Z));const E=this.transformPt([0,0]),[U,F]=this.getTransformAngle(),J=this.transformSize(1),K=this._ctx;K.save(),K.setTransform({m11:ft*J*U,m12:ft*J*F,m21:-J*F,m22:J*U,m41:E[0],m42:E[1]}),K.drawImage(k,-Ct/2,-N/2,Ct,N),K.restore()}drawText(h,I){if(!I||0===I.length)return;this._textRasterizer||(this._textRasterizer=new jt.Z);const Y=pe(h);Y.size*=this.transformSize((0,zt.Wz)(1));const R=this._textRasterizer.rasterizeText(I,Y);if(!R)return;const{size:Z,anchorX:ft,anchorY:q,canvas:Ct}=R,N=Z[0]*(ft+.5),v=Z[1]*(q-.5),k=this._ctx,E=this.transformPt([0,0]),[U,F]=this.getTransformAngle();k.save(),k.setTransform({m11:1*U,m12:1*F,m21:-1*F,m22:1*U,m41:E[0]-1*N,m42:E[1]+1*v}),k.drawImage(Ct,0,0),k.restore()}drawPictureFill(h,I){if(!h)return;let{colorSubstitutions:Y,height:R,offsetX:Z,offsetY:ft,rotation:q,scaleX:Ct,tintColor:N,url:v}=I;const k=this._resourceManager.getResource(v);if((0,se.Wi)(k))return;if((0,Tt.oU)(h))this._buildPath(h.rings,!0);else if((0,Tt.l9)(h))this._buildPath(h.paths,!0);else if((0,Tt.YX)(h))this._buildPath(wt(h).rings,!0);else{if(!(0,Tt.aW)(h))return;console.log("CanvasDrawHelper.drawPictureFill - No implementation!")}const E=this._ctx,U=(0,Wt.TB)(v)||"src"in k&&(0,Wt.TB)(k.src);let F,J="getFrame"in k?Ut(k):k;if(Y&&(J=this._colorSubstitutionHelper.applyColorSubstituition(J,Y)),this._applyAdditionalRenderProps){U||N&&(J=this._colorSubstitutionHelper.tintImageData(J,N)),F=E.createPattern(J,"repeat");const K=this.transformSize(1);q||(q=0),Z?Z*=K:Z=0,ft?ft*=K:ft=0,R&&(R*=K);const W=R?R/k.height:1,n=Ct&&R?Ct*R/k.width:1;if(0!==q||1!==W||1!==n||0!==Z||0!==ft){const O=new DOMMatrix;O.rotateSelf(0,0,-q).translateSelf(Z,ft).scaleSelf(n,W,1),F.setTransform(O)}}else F=E.createPattern(J,"repeat");E.save(),E.fillStyle=F,E.fill("evenodd"),E.restore()}drawPictureStroke(h,I){if(!h)return;let{colorSubstitutions:Y,capStyle:R,joinStyle:Z,miterLimit:ft,tintColor:q,url:Ct,width:N}=I;const v=this._resourceManager.getResource(Ct);if((0,se.Wi)(v))return;let k;if((0,Tt.oU)(h))k=h.rings;else if((0,Tt.l9)(h))k=h.paths;else if((0,Tt.YX)(h))k=wt(h).rings;else{if(!(0,Tt.aW)(h))return;console.log("CanvasDrawHelper.drawPictureStroke - No implementation!")}N||(N=v.width);const E=(0,Wt.TB)(Ct)||"src"in v&&(0,Wt.TB)(v.src);let U="getFrame"in v?Ut(v):v;Y&&(U=this._colorSubstitutionHelper.applyColorSubstituition(U,Y)),this._applyAdditionalRenderProps&&(E||q&&(U=this._colorSubstitutionHelper.tintImageData(U,q)));const F=Math.max(this.transformSize((0,zt.F2)(N)),.5),J=F/U.width,K=this._ctx,W=K.createPattern(U,"repeat-y");let n,O;K.save(),this._setCapStyle(R),this._setJoinStyle(Z),K.miterLimit=ft,K.lineWidth=F;for(let z of k)if(z=(0,Dt.d9)(z),ne(z),z&&!(z.length<=1)){n=this.transformPt(z[0]);for(let mt=1;mt<z.length;mt++){O=this.transformPt(z[mt]);const j=Gt(n,O),ct=new DOMMatrix;ct.translateSelf(0,n[1]-F/2).scaleSelf(J,J,1).rotateSelf(0,0,90-j),W.setTransform(ct),K.strokeStyle=W,K.beginPath(),K.moveTo(n[0],n[1]),K.lineTo(O[0],O[1]),K.stroke(),n=O}}K.restore()}_buildPath(h,I){const Y=this._ctx;if(Y.beginPath(),h)for(const R of h){const Z=R?R.length:0;if(Z>1){let ft=this.transformPt(R[0]);Y.moveTo(ft[0],ft[1]);for(let q=1;q<Z;q++)ft=this.transformPt(R[q]),Y.lineTo(ft[0],ft[1]);I&&Y.closePath()}}}_setCapStyle(h){switch(h){case nt.kP.Butt:this._ctx.lineCap="butt";break;case nt.kP.Round:this._ctx.lineCap="round";break;case nt.kP.Square:this._ctx.lineCap="square"}}_setJoinStyle(h){switch(h){case nt.r4.Bevel:this._ctx.lineJoin="bevel";break;case nt.r4.Round:this._ctx.lineJoin="round";break;case nt.r4.Miter:this._ctx.lineJoin="miter"}}}function Gt(It,h){return 180/Math.PI*Math.atan2(h[1]-It[1],h[0]-It[0])}const wt=It=>It?{spatialReference:It.spatialReference,rings:[[[It.xmin,It.ymin],[It.xmin,It.ymax],[It.xmax,It.ymax],[It.xmax,It.ymin],[It.xmin,It.ymin]]]}:null;function pe(It,h=1){const I=(0,Wt.BX)(It),Y=(0,Wt.wi)(It.fontStyleName),R=(0,yt.BN)(It.fontFamilyName),{weight:Z,style:ft}=Y,q=h*(It.height||5),Ct=(0,Wt.X_)(It.horizontalAlignment),N=(0,Wt.FG)(It.verticalAlignment),v=(0,Wt.W7)(It),k=(0,Wt.$Z)(It.haloSymbol),E=k?h*(0|It.haloSize):0;return{color:v,size:q,horizontalAlignment:Ct,verticalAlignment:N,font:{family:R,style:(0,Wt.pJ)(ft),weight:(0,Wt.On)(Z),decoration:I},halo:{size:E||0,color:k,style:ft},pixelRatio:1,premultiplyColors:!0}}function ne(It){let h,I,Y,R,Z,ft=It[0],q=1;for(;q<It.length;)h=It[q][0]-ft[0],I=It[q][1]-ft[1],R=0!==h?I/h:Math.PI/2,void 0!==Y&&R-Y<=1e-4?(It.splice(q-1,1),ft=Z):(Z=ft,ft=It[q],q++),Y=R}},35909:(ve,fe,at)=>{at.d(fe,{B$:()=>Gt,E0:()=>wt,U1:()=>I});var At=at(15861),yt=at(91558),Dt=at(986),Bt=at(58817),se=at(63290),$=at(62208),zt=at(4619),pt=at(23841),Tt=(at(65401),at(32442),at(46679)),Kt=at(97373),Zt=at(26933),et=at(7547),_t=at(80991),Nt=at(39236),Ut=(at(86575),at(39351));at(25797);const jt=Math.PI,Wt=jt/2,Pt=96/72,rt=(Math,se.Z.getLogger("esri.symbols.cim.CIMSymbolHelper"));function ht(N,v,k){switch(v.type){case"CIMSymbolReference":return ht(N,v.symbol,k);case"CIMPointSymbol":null==k&&(k={x:0,y:0}),N.drawSymbol(v,k);break;case"CIMLineSymbol":null==k&&(k={paths:[[[0,0],[10,0]]]}),N.drawSymbol(v,k);break;case"CIMPolygonSymbol":null==k&&(k={rings:[[[0,0],[0,10],[10,10],[10,0],[0,0]]]}),N.drawSymbol(v,k);break;case"CIMTextSymbol":N.drawSymbol(v,{x:0,y:0});break;case"CIMVectorMarker":{const E=new Kt.u;N.drawMarker(v,E);break}}return N.envelope()}class Gt{static getEnvelope(v,k,E){const U=new Zt.uQ(E);if(Array.isArray(v)){let F;for(const J of v)F?F.union(ht(U,J,k)):F=ht(U,J,k);return F}return ht(U,v,k)}static getTextureAnchor(v,k){const E=this.getEnvelope(v,null,k);if(!E)return[0,0,0];const K=E.height*Pt+2;return[-(E.x+.5*E.width)*Pt/(E.width*Pt+2),-(E.y+.5*E.height)*Pt/K,K]}static rasterize(v,k,E,U,F=!0){const J=E||this.getEnvelope(k,null,U);if(!J)return[null,0,0,0,0];const K=(J.x+.5*J.width)*Pt,W=(J.y+.5*J.height)*Pt;v.width=J.width*Pt,v.height=J.height*Pt,E||(v.width+=2,v.height+=2);const n=v.getContext("2d"),O=Zt.zA.createScale(Pt,-Pt);O.translate(.5*v.width-K,.5*v.height+W);const z=new Zt.cD(n,U,O);switch(k.type){case"CIMPointSymbol":z.drawSymbol(k,{type:"point",x:0,y:0});break;case"CIMVectorMarker":{const ct=new Kt.u;z.drawMarker(k,ct);break}}const mt=n.getImageData(0,0,v.width,v.height),j=new Uint8Array(mt.data);if(F){let ct;for(let st=0;st<j.length;st+=4)ct=j[st+3]/255,j[st]=j[st]*ct,j[st+1]=j[st+1]*ct,j[st+2]=j[st+2]*ct}return[j,v.width,v.height,-K/v.width,-W/v.height]}static fromTextSymbol(v){const{angle:k,color:E,font:U,haloColor:F,haloSize:J,horizontalAlignment:K,kerning:W,text:n,verticalAlignment:O,xoffset:z,yoffset:mt}=v;let j,ct,st,tt,it;U&&(j=U.family,ct=U.style,st=U.weight,tt=U.size,it=U.decoration);let Mt=!1;return n&&(Mt=(0,Dt.E)(n)[1]),{type:"CIMPointSymbol",symbolLayers:[{type:"CIMVectorMarker",enable:!0,anchorPointUnits:"Relative",dominantSizeAxis3D:"Y",size:10,billboardMode3D:"FaceNearPlane",frame:{xmin:-5,ymin:-5,xmax:5,ymax:5},markerGraphics:[{type:"CIMMarkerGraphic",geometry:{x:0,y:0},symbol:{type:"CIMTextSymbol",angle:k,blockProgression:et.zV.BTT,depth3D:1,extrapolateBaselines:!0,fontEffects:et.eZ.Normal,fontEncoding:et.DD.Unicode,fontFamilyName:j||"Arial",fontStyleName:ne(ct,st),fontType:et.Ky.Unspecified,haloSize:J,height:tt,hinting:et.Dd.Default,horizontalAlignment:oe(K??"center"),kerning:W,letterWidth:100,ligatures:!0,lineGapType:"Multiple",offsetX:(0,_t.NA)(z),offsetY:(0,_t.NA)(mt),strikethrough:"line-through"===it,underline:"underline"===it,symbol:{type:"CIMPolygonSymbol",symbolLayers:[{type:"CIMSolidFill",enable:!0,color:ie(E)}]},haloSymbol:{type:"CIMPolygonSymbol",symbolLayers:[{type:"CIMSolidFill",enable:!0,color:ie(F)}]},shadowColor:[0,0,0,255],shadowOffsetX:1,shadowOffsetY:1,textCase:"Normal",textDirection:Mt?et.UX.RTL:et.UX.LTR,verticalAlignment:pe(O??"baseline"),verticalGlyphOrientation:et.RS.Right,wordSpacing:100,billboardMode3D:et.UR.FaceNearPlane},textString:n}],scaleSymbolsProportionally:!0,respectFrame:!0}],scaleX:1,angleAlignment:"Display"}}static fromPictureFillSymbol(v){const{height:k,outline:E,width:U,xoffset:F,xscale:J,yoffset:K,yscale:W}=v,n=[],O={type:"CIMPolygonSymbol",symbolLayers:n};if(E){const{cap:st,join:tt,miterLimit:it,width:Mt}=E;n.push({type:"CIMSolidStroke",color:ie(E.color),capStyle:re(st),joinStyle:me(tt),miterLimit:it,width:Mt})}let z=v.url;"esriPFS"===v.type&&v.imageData&&(z=v.imageData);const mt="angle"in v?v.angle:0;return n.push({type:"CIMPictureFill",invertBackfaceTexture:!1,scaleX:1,textureFilter:et.Qb.Picture,tintColor:null,url:z,height:k*(W||1),width:U*(J||1),offsetX:(0,_t.NA)(F),offsetY:(0,_t.NA)(K),rotation:(0,_t.NA)(-mt),colorSubstitutions:null}),O}static fromSimpleFillSymbol(v){const{color:k,style:E,outline:U}=v,F=[],J={type:"CIMPolygonSymbol",symbolLayers:F};let K=null;if(U){const{cap:W,join:n,style:O}=U;"solid"!==O&&"none"!==O&&"esriSLSSolid"!==O&&"esriSLSNull"!==O&&(K=[{type:"CIMGeometricEffectDashes",dashTemplate:I(O,W),lineDashEnding:"NoConstraint",scaleDash:!0,offsetAlongLine:null}]),F.push({type:"CIMSolidStroke",color:ie(U.color),capStyle:re(W),joinStyle:me(n),miterLimit:U.miterLimit,width:U.width,effects:K})}if(E&&"solid"!==E&&"none"!==E&&"esriSFSSolid"!==E&&"esriSFSNull"!==E){const W={type:"CIMLineSymbol",symbolLayers:[{type:"CIMSolidStroke",color:ie(k),capStyle:et.kP.Butt,joinStyle:et.r4.Miter,width:.75}]};let n=0;const O=(0,pt.Wz)(Z(E)?8:10);switch(E){case"vertical":case"esriSFSVertical":n=90;break;case"forward-diagonal":case"esriSFSForwardDiagonal":case"diagonal-cross":case"esriSFSDiagonalCross":n=-45;break;case"backward-diagonal":case"esriSFSBackwardDiagonal":n=45;break;case"cross":case"esriSFSCross":n=0}F.push({type:"CIMHatchFill",lineSymbol:W,offsetX:0,offsetY:0,rotation:n,separation:O}),"cross"===E||"esriSFSCross"===E?F.push({type:"CIMHatchFill",lineSymbol:(0,Bt.d9)(W),offsetX:0,offsetY:0,rotation:90,separation:O}):"diagonal-cross"!==E&&"esriSFSDiagonalCross"!==E||F.push({type:"CIMHatchFill",lineSymbol:(0,Bt.d9)(W),offsetX:0,offsetY:0,rotation:45,separation:O})}else!E||"solid"!==E&&"esriSFSSolid"!==E||F.push({type:"CIMSolidFill",enable:!0,color:ie(k)});return J}static fromSimpleLineSymbol(v){const{cap:k,color:E,join:U,marker:F,miterLimit:J,style:K,width:W}=v;let n=null;"solid"!==K&&"none"!==K&&"esriSLSSolid"!==K&&"esriSLSNull"!==K&&(n=[{type:"CIMGeometricEffectDashes",dashTemplate:I(K,k),lineDashEnding:"NoConstraint",scaleDash:!0,offsetAlongLine:null}]);const O=[];if(F){let z;switch(F.placement){case"begin-end":z=et.Tx.Both;break;case"begin":z=et.Tx.JustBegin;break;case"end":z=et.Tx.JustEnd;break;default:z=et.Tx.None}const mt=Gt.fromSimpleMarker(F,W,E).symbolLayers[0];mt.markerPlacement={type:"CIMMarkerPlacementAtExtremities",angleToLine:!0,offset:0,extremityPlacement:z,offsetAlongLine:0},O.push(mt)}return"none"!==K&&"esriSLSNull"!==K&&O.push({type:"CIMSolidStroke",color:ie(E),capStyle:re(k),joinStyle:me(U),miterLimit:J,width:W,effects:n}),{type:"CIMLineSymbol",symbolLayers:O}}static fromPictureMarker(v){const{angle:k,height:E,width:U,xoffset:F,yoffset:J}=v;let K=v.url;return"esriPMS"===v.type&&v.imageData&&(K=v.imageData),{type:"CIMPointSymbol",symbolLayers:[{type:"CIMPictureMarker",invertBackfaceTexture:!1,scaleX:1,textureFilter:et.Qb.Picture,tintColor:null,url:K,size:E,width:U,offsetX:(0,_t.NA)(F),offsetY:(0,_t.NA)(J),rotation:(0,_t.NA)(-k)}]}}static fromSimpleMarker(v,k,E){const{style:U}=v,F=v.color??E;if("path"===U){const n=[];if("outline"in v&&v.outline){const mt=v.outline;n.push({type:"CIMSolidStroke",enable:!0,width:(0,pt.F2)(Math.round((0,pt.Wz)(mt.width))),color:ie(mt.color)})}n.push({type:"CIMSolidFill",enable:!0,color:ie(F),path:v.path});const[O,z]=R("square");return{type:"CIMPointSymbol",symbolLayers:[{type:"CIMVectorMarker",enable:!0,rotation:(0,_t.NA)(-v.angle),size:(0,_t.NA)(v.size||6),offsetX:(0,_t.NA)(v.xoffset),offsetY:(0,_t.NA)(v.yoffset),frame:O,markerGraphics:[{type:"CIMMarkerGraphic",geometry:z,symbol:{type:"CIMPolygonSymbol",symbolLayers:n}}]}]}}const[J,K]=R(U);let W;if(K&&J){const n=[];if("outline"in v&&v.outline){const z=v.outline;n.push({type:"CIMSolidStroke",enable:!0,width:z.width>.667?(0,pt.F2)(Math.round((0,pt.Wz)(z.width))):z.width,color:ie(z.color)})}else!k||"line-marker"!==v.type||"cross"!==v.style&&"x"!==v.style||n.push({type:"CIMSolidStroke",enable:!0,width:k,color:ie(F)});n.push({type:"CIMSolidFill",enable:!0,color:ie(F)});const O={type:"CIMPolygonSymbol",symbolLayers:n};W={type:"CIMPointSymbol",symbolLayers:[{type:"CIMVectorMarker",enable:!0,rotation:(0,_t.NA)(-v.angle),size:(0,_t.NA)(v.size||6*k),offsetX:(0,_t.NA)(v.xoffset),offsetY:(0,_t.NA)(v.yoffset),frame:J,markerGraphics:[{type:"CIMMarkerGraphic",geometry:K,symbol:O}]}]}}return W}static fromCIMHatchFill(v,k){const E=k*(v.separation??4),U=E/2,J=(0,Bt.d9)(v.lineSymbol);let K=this._getLineSymbolPeriod(J)||4;for(;K<4;)K*=2;const W=K/2,n={xmin:-W,xmax:W,ymin:-U,ymax:U},O=J.symbolLayers.find(z=>"CIMSolidStroke"===z.type);return O&&(O.width*=k),{type:"CIMVectorMarker",frame:n,markerGraphics:[{type:"CIMMarkerGraphic",geometry:{paths:[[[-W,0],[W,0]]]},symbol:J}],size:E}}static fetchResources(v,k,E){if(v&&k)switch(v.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":{const U=v.symbolLayers;if(!U)return;for(const F of U)switch(Ct(F,k,E),F.type){case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":case"CIMPictureStroke":case"CIMGradientStroke":case"CIMCharacterMarker":case"CIMPictureMarker":"url"in F&&F.url&&E.push(k.fetchResource(F.url,null));break;case"CIMVectorMarker":{const J=F.markerGraphics;if(!J)continue;for(const K of J)if(K){const W=K.symbol;W&&Gt.fetchResources(W,k,E)}}}}}}static _getLineSymbolPeriod(v){if(v){const k=this._getEffectsRepeat(v.effects);if(k)return k;if(v.symbolLayers)for(const E of v.symbolLayers)if(E){const U=this._getEffectsRepeat(E.effects);if(U)return U;switch(E.type){case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":case"CIMObjectMarker3D":case"CIMglTFMarker3D":{const F=this._getPlacementRepeat(E.markerPlacement);if(F)return F}}}}return 0}static _getEffectsRepeat(v){if(v)for(const k of v)if(k)switch(k.type){case"CIMGeometricEffectDashes":{const E=k.dashTemplate;if(E&&E.length){let U=0;for(const F of E)U+=F;return 1&E.length&&(U*=2),U}break}case"CIMGeometricEffectWave":return k.period;default:rt.error(`unsupported geometric effect type ${k.type}`)}return 0}static _getPlacementRepeat(v){if(v)switch(v.type){case"CIMMarkerPlacementAlongLineSameSize":case"CIMMarkerPlacementAlongLineRandomSize":case"CIMMarkerPlacementAlongLineVariableSize":{const k=v.placementTemplate;if(k&&k.length){let E=0;for(const U of k)E+=U;return 1&k.length&&(E*=2),E}break}}return 0}static fromCIMInsidePolygon(v){const k=v.markerPlacement,E={type:v.type,...v};E.markerPlacement=null,E.anchorPoint=null;const U=Math.abs(k.stepX),F=Math.abs(k.stepY),J=(k.randomness??100)/100;let K,W,n,O;if("Random"===k.gridType){const z=(0,pt.Wz)(Ut.C1),mt=Math.max(Math.floor(z/U),1),j=Math.max(Math.floor(z/F),1);K=mt*U/2,W=j*F/2,n=2*W;const ct=new zt.Z(k.seed),st=J*U/1.5,tt=J*F/1.5;O=[];for(let it=0;it<mt;it++)for(let Mt=0;Mt<j;Mt++){const vt=it*U-K+st*(.5-ct.getFloat()),Ft=Mt*F-W+tt*(.5-ct.getFloat());O.push({x:vt,y:Ft}),0===it&&O.push({x:vt+2*K,y:Ft}),0===Mt&&O.push({x:vt,y:Ft+2*W})}}else!0===k.shiftOddRows?(K=U/2,W=F,n=2*F,O=[{x:-K,y:0},{x:K,y:0},{x:0,y:W},{x:0,y:-W}]):(K=U/2,W=F/2,n=F,O=[{x:-U,y:0},{x:0,y:-F},{x:-U,y:-F},{x:0,y:0},{x:U,y:0},{x:0,y:F},{x:U,y:F},{x:-U,y:F},{x:U,y:-F}]);return{type:"CIMVectorMarker",frame:{xmin:-K,xmax:K,ymin:-W,ymax:W},markerGraphics:O.map(z=>({type:"CIMMarkerGraphic",geometry:z,symbol:{type:"CIMPointSymbol",symbolLayers:[E]}})),size:n}}static getSize(v){if(v)switch(v.type){case"CIMTextSymbol":return v.height;case"CIMPointSymbol":{let k=0;if(v.symbolLayers)for(const E of v.symbolLayers)if(E)switch(E.type){case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":case"CIMObjectMarker3D":case"CIMglTFMarker3D":{const U=E.size;U>k&&(k=U);break}}return k}case"CIMLineSymbol":case"CIMPolygonSymbol":{let k=0;if(v.symbolLayers)for(const E of v.symbolLayers)if(E)switch(E.type){case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":{const U=E.width;U>k&&(k=U);break}case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":case"CIMObjectMarker3D":case"CIMglTFMarker3D":if((0,_t.gJ)(E.markerPlacement)){const U=E.size;U>k&&(k=U)}}return k}}}static getMarkerScaleRatio(v){return v&&"CIMVectorMarker"===v.type&&!1!==v.scaleSymbolsProportionally&&v.frame?v.size/(v.frame.ymax-v.frame.ymin):1}}class wt{static findApplicableOverrides(v,k,E){if(v&&k){if(v.primitiveName){let U=!1;for(const F of E)if(F.primitiveName===v.primitiveName){U=!0;break}if(!U)for(const F of k)F.primitiveName===v.primitiveName&&E.push(F)}switch(v.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(v.effects)for(const U of v.effects)wt.findApplicableOverrides(U,k,E);if(v.symbolLayers)for(const U of v.symbolLayers)wt.findApplicableOverrides(U,k,E);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":case"CIMSolidFill":case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":case"CIMVectorMarker":case"CIMCharacterMarker":case"CIMPictureMarker":if(v.effects)for(const U of v.effects)wt.findApplicableOverrides(U,k,E);if(v.markerPlacement&&wt.findApplicableOverrides(v.markerPlacement,k,E),"CIMVectorMarker"===v.type){if(v.markerGraphics)for(const U of v.markerGraphics)wt.findApplicableOverrides(U,k,E),wt.findApplicableOverrides(U.symbol,k,E)}else"CIMCharacterMarker"===v.type?wt.findApplicableOverrides(v.symbol,k,E):"CIMHatchFill"===v.type?wt.findApplicableOverrides(v.lineSymbol,k,E):"CIMPictureMarker"===v.type&&wt.findApplicableOverrides(v.animatedSymbolProperties,k,E)}}}static findEffectOverrides(v,k,E){if(!k||!v)return;const U=v.length;for(let F=0;F<U;F++){const J=v[F]?.primitiveName;if(J){let K=!1;for(const W of E)if(W.primitiveName===J){K=!0;break}if(!K)for(const W of k)W.primitiveName===J&&E.push(W)}}}static resolveSymbolOverrides(v,k,E,U,F,J,K){return(0,At.Z)(function*(){if(!v||!v.symbol)return null;let{symbol:W,primitiveOverrides:n}=v;const O=!!n;if(!O&&!U)return W;W=(0,Bt.d9)(W);let z=!0;if(k||(k={attributes:{}},z=!1),O){if(z||(n=n.filter(mt=>!mt.valueExpressionInfo?.expression.includes("$feature"))),K||(n=n.filter(mt=>!mt.valueExpressionInfo?.expression.includes("$view"))),n.length>0){const mt=(0,_t.Qf)(k.attributes);yield wt.evaluateOverrides(n,k,{spatialReference:E,fields:mt,geometryType:F},J,K)}wt.applyOverrides(W,n)}return U&&wt.applyDictionaryTextOverrides(W,k,U),W})()}static evaluateOverrides(v,k,E,U,F){return(0,At.Z)(function*(){if(!k)return;let J;for(const K of v){const W=K.valueExpressionInfo;if(W&&E){J||(J=[]),K.value=void 0;const n=(0,Tt.Yi)(W.expression,E.spatialReference,E.fields).then(O=>{K.value=(0,Nt.Z)(O,k,{$view:F},E.geometryType,U)});J.push(n)}}void 0!==J&&J.length>0&&(yield Promise.all(J))})()}static applyDictionaryTextOverrides(v,k,E,U="Normal"){if(v&&v.type)switch(v.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":case"CIMTextSymbol":{const F=v.symbolLayers;if(!F)return;for(const J of F)J&&"CIMVectorMarker"===J.type&&wt.applyDictionaryTextOverrides(J,k,E,"CIMTextSymbol"===v.type?v.textCase:U)}break;case"CIMVectorMarker":{const F=v.markerGraphics;if(!F)return;for(const J of F)J&&wt.applyDictionaryTextOverrides(J,k,E)}break;case"CIMMarkerGraphic":{const F=v.textString;if(F&&F.includes("[")){const J=(0,_t.H1)(F,E);v.textString=(0,_t.E_)(k,J,U)}}}}static applyOverrides(v,k,E,U){if(v.primitiveName)for(const F of k)if(F.primitiveName===v.primitiveName){const J=ft(F.propertyName);if(U&&U.push({cim:v,nocapPropertyName:J,value:v[J]}),F.expression&&(F.value=wt.toValue(F.propertyName,F.expression)),E){let K=!1;for(const W of E)W.primitiveName===v.primitiveName&&(K=!0);K||E.push(F)}(0,$.pC)(F.value)&&(v[J]=F.value)}switch(v.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(v.effects)for(const F of v.effects)wt.applyOverrides(F,k,E,U);if(v.symbolLayers)for(const F of v.symbolLayers)wt.applyOverrides(F,k,E,U);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMSolidFill":case"CIMVectorMarker":if(v.effects)for(const F of v.effects)wt.applyOverrides(F,k,E,U);if("CIMVectorMarker"===v.type&&v.markerGraphics)for(const F of v.markerGraphics)wt.applyOverrides(F,k,E,U),wt.applyOverrides(F.symbol,k,E,U)}}static restoreOverrides(v){for(const k of v)k.cim[k.nocapPropertyName]=k.value}static buildOverrideKey(v){let k="";for(const E of v)void 0!==E.value&&(k+=`${E.primitiveName}${E.propertyName}${JSON.stringify(E.value)}`);return k}static toValue(v,k){if("DashTemplate"===v)return k.split(" ").map(E=>Number(E));if("Color"===v){const E=new yt.Z(k).toRgba();return E[3]*=255,E}return k}}const re=N=>{if(!N)return et.kP.Butt;switch(N){case"butt":return et.kP.Butt;case"square":return et.kP.Square;case"round":return et.kP.Round}},me=N=>{if(!N)return et.r4.Miter;switch(N){case"miter":return et.r4.Miter;case"round":return et.r4.Round;case"bevel":return et.r4.Bevel}},oe=N=>{if((0,$.Wi)(N))return"Center";switch(N){case"left":return"Left";case"right":return"Right";case"center":return"Center"}},pe=N=>{if((0,$.Wi)(N))return"Center";switch(N){case"baseline":return"Baseline";case"top":return"Top";case"middle":return"Center";case"bottom":return"Bottom"}},ie=N=>{if(!N)return[0,0,0,0];const{r:v,g:k,b:E,a:U}=N;return[v,k,E,255*U]},ne=(N,v)=>{const k=It(v),E=h(N);return k&&E?`${k}-${E}`:`${k}${E}`},It=N=>{if(!N)return"";switch(N.toLowerCase()){case"bold":case"bolder":return"bold"}return""},h=N=>{if(!N)return"";switch(N.toLowerCase()){case"italic":case"oblique":return"italic"}return""},I=(N,v)=>{const k="butt"===v;switch(N){case"dash":case"esriSLSDash":return k?[4,3]:[3,4];case"dash-dot":case"esriSLSDashDot":return k?[4,3,1,3]:[3,4,0,4];case"dot":case"esriSLSDot":return k?[1,3]:[0,4];case"long-dash":case"esriSLSLongDash":return k?[8,3]:[7,4];case"long-dash-dot":case"esriSLSLongDashDot":return k?[8,3,1,3]:[7,4,0,4];case"long-dash-dot-dot":case"esriSLSDashDotDot":return k?[8,3,1,3,1,3]:[7,4,0,4,0,4];case"short-dash":case"esriSLSShortDash":return k?[4,1]:[3,2];case"short-dash-dot":case"esriSLSShortDashDot":return k?[4,1,1,1]:[3,2,0,2];case"short-dash-dot-dot":case"esriSLSShortDashDotDot":return k?[4,1,1,1,1,1]:[3,2,0,2,0,2];case"short-dot":case"esriSLSShortDot":return k?[1,1]:[0,2];case"solid":case"esriSLSSolid":case"none":return rt.error("Unexpected: style does not require rasterization"),[0,0];default:return rt.error(`Tried to rasterize SLS, but found an unexpected style: ${N}!`),[0,0]}},R=N=>{let E,U;const F=N;if("circle"===F||"esriSMSCircle"===F){let K=Math.acos(.995),W=Math.ceil(jt/K/4);0===W&&(W=1),K=Wt/W,W*=4;const n=[];n.push([50,0]);for(let O=1;O<W;O++)n.push([50*Math.cos(O*K),-50*Math.sin(O*K)]);n.push([50,0]),E={rings:[n]},U={xmin:-50,ymin:-50,xmax:50,ymax:50}}else if("cross"===F||"esriSMSCross"===F)E={rings:[[[0,50],[0,0],[50,0],[50,-0],[0,-0],[0,-50],[-0,-50],[-0,-0],[-50,-0],[-50,0],[-0,0],[-0,50],[0,50]]]},U={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("diamond"===F||"esriSMSDiamond"===F)E={rings:[[[-50,0],[0,50],[50,0],[0,-50],[-50,0]]]},U={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("square"===F||"esriSMSSquare"===F)E={rings:[[[-50,-50],[-50,50],[50,50],[50,-50],[-50,-50]]]},U={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("x"===F||"esriSMSX"===F)E={rings:[[[0,0],[50,50],[50,50],[0,0],[50,-50],[50,-50],[0,-0],[-50,-50],[-50,-50],[-0,0],[-50,50],[-50,50],[0,0]]]},U={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("triangle"===F||"esriSMSTriangle"===F){const J=57.735026918962575,K=-J,W=2/3*100,n=W-100;E={rings:[[[K,n],[0,W],[J,n],[K,n]]]},U={xmin:K,ymin:n,xmax:J,ymax:W}}else"arrow"===F&&(E={rings:[[[-50,50],[50,0],[-50,-50],[-33,-20],[-33,20],[-50,50]]]},U={xmin:-50,ymin:-50,xmax:50,ymax:50});return[U,E]},Z=N=>"vertical"===N||"horizontal"===N||"cross"===N||"esriSFSCross"===N||"esriSFSVertical"===N||"esriSFSHorizontal"===N,ft=N=>N&&N.charAt(0).toLowerCase()+N.substr(1);let q;function Ct(N,v,k){if(N.effects&&!(0,$.pC)(v.geometryEngine)){if(q)return void k.push(q);(0,_t.Cc)(N.effects)&&(q=(0,_t.RI)(),k.push(q),q.then(E=>v.geometryEngine=E))}}},31375:(ve,fe,at)=>{at.d(fe,{Z:()=>At});class At{constructor(Dt=0,Bt=0,se=0,$=0){this.x=Dt,this.y=Bt,this.width=se,this.height=$}get isEmpty(){return this.width<=0||this.height<=0}union(Dt){this.x=Math.min(this.x,Dt.x),this.y=Math.min(this.y,Dt.y),this.width=Math.max(this.width,Dt.width),this.height=Math.max(this.height,Dt.height)}}},47139:(ve,fe,at)=>{at.d(fe,{Fp:()=>Bt,RL:()=>dt,UV:()=>Lt,bk:()=>pt});var At=at(36161),yt=at(91179),Dt=at(31375);function Bt(et){if(!et)return null;switch(et.type){case"CIMPointSymbol":{const _t=et.symbolLayers;return _t&&1===_t.length?Bt(_t[0]):null}case"CIMVectorMarker":{const _t=et.markerGraphics;if(!_t||1!==_t.length)return null;const Nt=_t[0];if(!Nt)return null;const nt=Nt.geometry;if(!nt)return null;const Ut=Nt.symbol;return!Ut||"CIMPolygonSymbol"!==Ut.type&&"CIMLineSymbol"!==Ut.type||Ut.symbolLayers?.some(Xt=>!!Xt.effects)?null:{geom:nt,asFill:"CIMPolygonSymbol"===Ut.type}}case"sdf":return{geom:et.geom,asFill:et.asFill}}return null}function zt(et){let _t=1/0,Nt=-1/0,nt=1/0,Ut=-1/0;for(const Xt of et)for(const jt of Xt)jt[0]<_t&&(_t=jt[0]),jt[0]>Nt&&(Nt=jt[0]),jt[1]<nt&&(nt=jt[1]),jt[1]>Ut&&(Ut=jt[1]);return[_t,nt,Nt,Ut]}function pt(et){return et?et.rings?zt(et.rings):et.paths?zt(et.paths):(0,yt.YX)(et)?[et.xmin,et.ymin,et.xmax,et.ymax]:null:null}function Lt(et,_t,Nt,nt,Ut){const[Xt,jt,Wt,te]=et;if(Wt<Xt||te<jt)return[0,0,0];const Q=Wt-Xt,Pt=te-jt,ut=Math.floor(31.5),ht=(128-2*(ut+1))/Math.max(Q,Pt),St=Math.round(Q*ht)+2*ut,kt=Math.round(Pt*ht)+2*ut;let Ht=1;_t&&(Ht=kt/ht/(_t.ymax-_t.ymin));let Vt=0,Gt=0,wt=1;nt&&(Ut?_t&&Nt&&_t.ymax-_t.ymin>0&&(wt=(_t.xmax-_t.xmin)/(_t.ymax-_t.ymin),Vt=nt.x/(Nt*wt),Gt=nt.y/Nt):(Vt=nt.x,Gt=nt.y)),Vt=.5*(_t.xmax+_t.xmin)+Vt*(_t.xmax-_t.xmin),Gt=.5*(_t.ymax+_t.ymin)+Gt*(_t.ymax-_t.ymin),Vt-=Xt,Gt-=jt,Vt*=ht,Gt*=ht,Vt+=ut,Gt+=ut;let re=Vt/St-.5,me=Gt/kt-.5;return Ut&&(re*=Nt*wt,me*=Nt),[Ht,re,me]}function dt(et){const _t=function se(et){return et?et.rings?et.rings:et.paths?et.paths:void 0!==et.xmin&&void 0!==et.ymin&&void 0!==et.xmax&&void 0!==et.ymax?[[[et.xmin,et.ymin],[et.xmin,et.ymax],[et.xmax,et.ymax],[et.xmax,et.ymin],[et.xmin,et.ymin]]]:null:null}(et.geom),Nt=function $(et){let _t=1/0,Nt=-1/0,nt=1/0,Ut=-1/0;for(const Xt of et)for(const jt of Xt)jt[0]<_t&&(_t=jt[0]),jt[0]>Nt&&(Nt=jt[0]),jt[1]<nt&&(nt=jt[1]),jt[1]>Ut&&(Ut=jt[1]);return new Dt.Z(_t,nt,Nt-_t,Ut-nt)}(_t),Xt=Math.floor(31.5),jt=(128-2*(Xt+1))/Math.max(Nt.width,Nt.height),Wt=Math.round(Nt.width*jt)+2*Xt,te=Math.round(Nt.height*jt)+2*Xt,Q=[];for(const bt of _t)if(bt&&bt.length>1){const rt=[];for(const ut of bt){let[ht,St]=ut;ht-=Nt.x,St-=Nt.y,ht*=jt,St*=jt,ht+=Xt-.5,St+=Xt-.5,rt.push(et.asFill?[ht,St]:[Math.round(ht),Math.round(St)])}if(et.asFill){const ut=rt.length-1;rt[0][0]===rt[ut][0]&&rt[0][1]===rt[ut][1]||rt.push(rt[0])}Q.push(rt)}const Pt=function Tt(et,_t,Nt,nt){const Ut=_t*Nt,Xt=new Array(Ut),jt=nt*nt+1;for(let Wt=0;Wt<Ut;++Wt)Xt[Wt]=jt;for(const Wt of et){const te=Wt.length;for(let Q=1;Q<te;++Q){const Pt=Wt[Q-1],bt=Wt[Q];let rt,ut,ht,St;Pt[0]<bt[0]?(rt=Pt[0],ut=bt[0]):(rt=bt[0],ut=Pt[0]),Pt[1]<bt[1]?(ht=Pt[1],St=bt[1]):(ht=bt[1],St=Pt[1]);let kt=Math.floor(rt)-nt,Ht=Math.floor(ut)+nt,Vt=Math.floor(ht)-nt,Gt=Math.floor(St)+nt;kt<0&&(kt=0),Ht>_t&&(Ht=_t),Vt<0&&(Vt=0),Gt>Nt&&(Gt=Nt);const wt=bt[0]-Pt[0],re=bt[1]-Pt[1],me=wt*wt+re*re;for(let oe=kt;oe<Ht;oe++)for(let pe=Vt;pe<Gt;pe++){let ie,ne,It=(oe-Pt[0])*wt+(pe-Pt[1])*re;It<0?(ie=Pt[0],ne=Pt[1]):It>me?(ie=bt[0],ne=bt[1]):(It/=me,ie=Pt[0]+It*wt,ne=Pt[1]+It*re);const h=(oe-ie)*(oe-ie)+(pe-ne)*(pe-ne),I=(Nt-pe-1)*_t+oe;h<Xt[I]&&(Xt[I]=h)}}}for(let Wt=0;Wt<Ut;++Wt)Xt[Wt]=Math.sqrt(Xt[Wt]);return Xt}(Q,Wt,te,Xt);return et.asFill&&function Kt(et,_t,Nt,nt,Ut){for(const Xt of et){const jt=Xt.length;for(let Wt=1;Wt<jt;++Wt){const te=Xt[Wt-1],Q=Xt[Wt];let Pt,bt,rt,ut;te[0]<Q[0]?(Pt=te[0],bt=Q[0]):(Pt=Q[0],bt=te[0]),te[1]<Q[1]?(rt=te[1],ut=Q[1]):(rt=Q[1],ut=te[1]);let ht=Math.floor(Pt),St=Math.floor(bt)+1,kt=Math.floor(rt),Ht=Math.floor(ut)+1;ht<nt&&(ht=nt),St>_t-nt&&(St=_t-nt),kt<nt&&(kt=nt),Ht>Nt-nt&&(Ht=Nt-nt);for(let Vt=kt;Vt<Ht;++Vt){if(te[1]>Vt==Q[1]>Vt)continue;const Gt=(Nt-Vt-1)*_t;for(let wt=ht;wt<St;++wt)wt<(Q[0]-te[0])*(Vt-te[1])/(Q[1]-te[1])+te[0]&&(Ut[Gt+wt]=-Ut[Gt+wt]);for(let wt=nt;wt<ht;++wt)Ut[Gt+wt]=-Ut[Gt+wt]}}}}(Q,Wt,te,Xt,Pt),[Zt(Pt,Xt),Wt,te]}function Zt(et,_t){const Nt=2*_t,nt=et.length,Ut=new Uint8Array(4*nt);for(let Xt=0;Xt<nt;++Xt)(0,At.I)(.5-et[Xt]/Nt,Ut,4*Xt);return Ut}},68937:(ve,fe,at)=>{at.d(fe,{Z:()=>Bt});var At=at(23841);class Bt{constructor(zt){zt&&(this._textRasterizationCanvas=zt)}rasterizeText(zt,pt){this._textRasterizationCanvas||(this._textRasterizationCanvas=document.createElement("canvas"));const Lt=this._textRasterizationCanvas,dt=Lt.getContext("2d");this._setFontProperties(dt,pt),this._parameters=pt,this._textLines=zt.split(/\r?\n/),this._lineHeight=this._computeLineHeight();const Tt=this._computeTextWidth(dt,pt),{decoration:Kt,weight:Zt}=pt.font;this._lineThroughWidthOffset=Kt&&"line-through"===Kt?.1*this._lineHeight:0;const et=this._lineHeight*this._textLines.length;Lt.width=Tt+2*this._lineThroughWidthOffset,Lt.height=et,this._renderedLineHeight=Math.round(this._lineHeight*pt.pixelRatio),this._renderedHaloSize=pt.halo.size*pt.pixelRatio,this._renderedWidth=Tt*pt.pixelRatio,this._renderedHeight=et*pt.pixelRatio,this._lineThroughWidthOffset*=pt.pixelRatio;const Nt=pt.halo&&pt.halo.color?pt.halo.color:[0,0,0,0];this._fillStyle=function Dt($){return`rgba(${$.slice(0,3).toString()},${$[3]})`}(pt.color??[0,0,0,0]),this._haloStyle=function yt($){return`rgb(${$.slice(0,3).toString()})`}(Nt);const nt=this._renderedLineHeight,Ut=this._renderedHaloSize;dt.save(),dt.clearRect(0,0,Lt.width,Lt.height),this._setFontProperties(dt,pt);const Xt=function se($,zt){return"center"===$?.5*zt:"right"===$?zt:0}(dt.textAlign,this._renderedWidth)+Ut,jt=Ut,Wt=Ut>0;let te=this._lineThroughWidthOffset,Q=0;Wt&&this._renderHalo(dt,Xt,jt,te,Q,pt),Q+=jt,te+=Xt;for(const kt of this._textLines)Wt?(dt.globalCompositeOperation="destination-out",dt.fillStyle="rgb(0, 0, 0)",dt.fillText(kt,te,Q),dt.globalCompositeOperation="source-over",dt.fillStyle=this._fillStyle,dt.fillText(kt,te,Q)):(dt.fillStyle=this._fillStyle,dt.fillText(kt,te,Q)),Kt&&"none"!==Kt&&this._renderDecoration(dt,te,Q,Kt,Zt),Q+=nt;dt.restore();const Pt=this._renderedWidth+2*this._lineThroughWidthOffset,bt=this._renderedHeight,rt=dt.getImageData(0,0,Pt,bt),ut=new Uint8Array(rt.data);if(pt.premultiplyColors){let kt;for(let Ht=0;Ht<ut.length;Ht+=4)kt=ut[Ht+3]/255,ut[Ht]=ut[Ht]*kt,ut[Ht+1]=ut[Ht+1]*kt,ut[Ht+2]=ut[Ht+2]*kt}let ht,St;switch(pt.horizontalAlignment){case"left":ht=-.5;break;case"right":ht=.5;break;default:ht=0}switch(pt.verticalAlignment){case"bottom":St=-.5;break;case"top":St=.5;break;default:St=0}return{size:[Pt,bt],image:new Uint32Array(ut.buffer),sdf:!1,simplePattern:!1,anchorX:ht,anchorY:St,canvas:Lt}}_renderHalo(zt,pt,Lt,dt,Tt,Kt){const Zt=this._renderedWidth,et=this._renderedHeight;this._haloRasterizationCanvas||(this._haloRasterizationCanvas=document.createElement("canvas")),this._haloRasterizationCanvas.width=Zt,this._haloRasterizationCanvas.height=et;const _t=this._haloRasterizationCanvas,Nt=_t.getContext("2d");Nt.clearRect(0,0,Zt,et),this._setFontProperties(Nt,Kt);const{decoration:nt,weight:Ut}=Kt.font;Nt.fillStyle=this._haloStyle,Nt.strokeStyle=this._haloStyle,Nt.lineJoin="round",this._renderHaloNative(Nt,pt,Lt,nt,Ut),zt.globalAlpha=this._parameters.halo.color[3],zt.drawImage(_t,0,0,Zt,et,dt,Tt,Zt,et),zt.globalAlpha=1}_renderHaloNative(zt,pt,Lt,dt,Tt){const Kt=this._renderedLineHeight,Zt=this._renderedHaloSize;for(const et of this._textLines){const _t=2*Zt,Nt=5,nt=.1;for(let Ut=0;Ut<Nt;Ut++){const Xt=(1-(Nt-1)*nt+Ut*nt)*_t;zt.lineWidth=Xt,zt.strokeText(et,pt,Lt),dt&&"none"!==dt&&this._renderDecoration(zt,pt,Lt,dt,Tt,Xt)}Lt+=Kt}}_setFontProperties(zt,pt){const Lt=Math.max(pt.size,.5),dt=pt.font,Tt=`${dt.style} ${dt.weight} ${(0,At.F2)(Lt*pt.pixelRatio).toFixed(1)}px ${dt.family}, sans-serif`;let Kt;switch(zt.font=Tt,zt.textBaseline="top",pt.horizontalAlignment){case"left":default:Kt="left";break;case"right":Kt="right";break;case"center":Kt="center"}zt.textAlign=Kt}computeTextSize(zt,pt){this._textRasterizationCanvas||(this._textRasterizationCanvas=document.createElement("canvas"));const Lt=this._textRasterizationCanvas,dt=Lt.getContext("2d");this._setFontProperties(dt,pt),this._parameters=pt,this._textLines=zt.split(/\r?\n/),this._lineHeight=this._computeLineHeight();const Tt=this._computeTextWidth(dt,pt),Kt=this._lineHeight*this._textLines.length;return Lt.width=Tt,Lt.height=Kt,[Tt*pt.pixelRatio,Kt*pt.pixelRatio]}_computeTextWidth(zt,pt){let Lt=0;for(const Tt of this._textLines)Lt=Math.max(Lt,zt.measureText(Tt).width);const dt=pt.font;return("italic"===dt.style||"oblique"===dt.style||"string"==typeof dt.weight&&("bold"===dt.weight||"bolder"===dt.weight)||"number"==typeof dt.weight&&dt.weight>600)&&(Lt+=.3*zt.measureText("w").width),Lt+=2*this._parameters.halo.size,Math.round(Lt)}_computeLineHeight(){let zt=1.275*this._parameters.size;const pt=this._parameters.font.decoration;return pt&&"underline"===pt&&(zt*=1.3),Math.round(zt+2*this._parameters.halo.size)}_renderDecoration(zt,pt,Lt,dt,Tt,Kt){const Zt=.9*this._lineHeight,et="bold"===Tt?.06:"bolder"===Tt?.09:.04;switch(zt.textAlign){case"center":pt-=this._renderedWidth/2;break;case"right":pt-=this._renderedWidth}const _t=zt.textBaseline;if("underline"===dt)switch(_t){case"top":Lt+=Zt;break;case"middle":Lt+=Zt/2}else if("line-through"===dt)switch(_t){case"top":Lt+=Zt/1.5;break;case"middle":Lt+=Zt/3}const Nt=Kt?1.5*Kt:Math.ceil(Zt*et);zt.save(),zt.beginPath(),zt.strokeStyle=zt.fillStyle,zt.lineWidth=Nt,zt.moveTo(pt-this._lineThroughWidthOffset,Lt),zt.lineTo(pt+this._renderedWidth+2*this._lineThroughWidthOffset,Lt),zt.stroke(),zt.restore()}}},93678:(ve,fe,at)=>{at.d(fe,{S:()=>J,c:()=>kt});var At=at(15861),yt=at(91558),Dt=at(17002),Bt=at(58817),se=at(63290),$=at(62208),zt=at(23841),pt=at(77275),Lt=at(46679),dt=at(35909),Tt=at(7547);const et=new Set(["StartTimeOffset","Duration","RepeatDelay"]);function _t(n,O){return et.has(O)?function Zt(n){return.05*Math.max(Math.round(n/.05),1)}(n):n}var Nt=at(47139),nt=at(80991),Ut=at(73608),Xt=at(39236),jt=at(39351);const Q=53290320,Pt=10,bt=se.Z.getLogger("esri.symbols.cim.cimAnalyzer");function rt(n){switch(n){case"Butt":return Tt.RL.BUTT;case"Square":return Tt.RL.SQUARE;default:return Tt.RL.ROUND}}function ut(n){switch(n){case"Bevel":return Tt.AH.BEVEL;case"Miter":return Tt.AH.MITER;default:return Tt.AH.ROUND}}function ht(n,O,z,mt){let j;n[O]?j=n[O]:(j={},n[O]=j),j[z]=mt}function St(n){const O=n.markerPlacement;return O&&O.angleToLine?Tt.v2.MAP:Tt.v2.SCREEN}function kt(n,O,z,mt,j){return Ht.apply(this,arguments)}function Ht(){return(Ht=(0,At.Z)(function*(n,O,z,mt,j){const ct=mt??[];if(!n)return ct;let st,tt;const it={};if("CIMSymbolReference"!==n.type)return bt.error("Expect cim type to be 'CIMSymbolReference'"),ct;if(st=n.symbol,tt=n.primitiveOverrides,tt){const vt=[];for(const Ft of tt){const Ot=Ft.valueExpressionInfo;if(Ot&&O){const ee=(0,Lt.Yi)(Ot.expression,O.spatialReference,O.fields).then(Jt=>{(0,$.Wi)(Jt)||ht(it,Ft.primitiveName,Ft.propertyName,Jt)});vt.push(ee)}else null!=Ft.value&&ht(it,Ft.primitiveName,Ft.propertyName,Ft.value)}vt.length>0&&(yield Promise.all(vt))}const Mt=[];switch(dt.B$.fetchResources(st,z,Mt),Mt.length>0&&(yield Promise.all(Mt)),st.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":Vt(st,tt,it,O,ct,z,j)}return ct})).apply(this,arguments)}function Vt(n,O,z,mt,j,ct,st){if(!n)return;const tt=n.symbolLayers;if(!tt)return;const it=n.effects;let Mt;const vt=dt.B$.getSize(n);"CIMPointSymbol"===n.type&&"Map"===n.angleAlignment&&(Mt=Tt.v2.MAP);let Ft=tt.length;for(;Ft--;){const Ot=tt[Ft];if(!Ot||!1===Ot.enable)continue;let Rt;it&&it.length&&(Rt=[...it]);const ee=Ot.effects;ee&&ee.length&&(it?Rt.push(...ee):Rt=[...ee]);const Jt=[];let $t;dt.E0.findEffectOverrides(Rt,O,Jt),$t=Jt.length>0?k(Rt,Jt,z,mt):Rt;const Qt=[];switch(dt.E0.findApplicableOverrides(Ot,O,Qt),Ot.type){case"CIMSolidFill":Gt(Ot,$t,z,Qt,mt,j);break;case"CIMPictureFill":wt(Ot,$t,z,Qt,mt,ct,j);break;case"CIMHatchFill":re(Ot,$t,z,Qt,mt,j);break;case"CIMGradientFill":me(Ot,$t,z,Qt,mt,j);break;case"CIMSolidStroke":oe(Ot,$t,z,Qt,mt,j,"CIMPolygonSymbol"===n.type,vt);break;case"CIMPictureStroke":pe(Ot,$t,z,Qt,mt,j,"CIMPolygonSymbol"===n.type,vt);break;case"CIMGradientStroke":ie(Ot,$t,z,Qt,mt,j,"CIMPolygonSymbol"===n.type,vt);break;case"CIMCharacterMarker":if(ne(Ot,$t,z,Qt,mt,j))break;break;case"CIMPictureMarker":if(ne(Ot,$t,z,Qt,mt,j))break;"CIMLineSymbol"===n.type&&(Mt=St(Ot)),It(Ot,$t,z,Qt,mt,ct,j,Mt,vt);break;case"CIMVectorMarker":if(ne(Ot,$t,z,Qt,mt,j))break;"CIMLineSymbol"===n.type&&(Mt=St(Ot)),h(Ot,$t,z,Qt,mt,j,ct,Mt,vt,st);break;default:bt.error("Cannot analyze CIM layer",Ot.type)}}}function Gt(n,O,z,mt,j,ct){const st=n.primitiveName,tt=(0,nt.NO)(n.color),[it,Mt]=K(mt,st,O,null,null),vt=(0,pt.hP)(JSON.stringify(n)+Mt).toString();ct.push({type:"fill",templateHash:vt,materialHash:it?()=>vt:vt,cim:n,materialOverrides:null,colorLocked:n.colorLocked,color:N(st,z,"Color",j,tt,Ct),height:0,angle:0,offsetX:0,offsetY:0,scaleX:1,effects:O,applyRandomOffset:!1,sampleAlphaOnly:!0})}function wt(n,O,z,mt,j,ct,st){const tt=n.primitiveName,it=n.tintColor?(0,nt.NO)(n.tintColor):{r:255,g:255,b:255,a:1},[Mt,vt]=K(mt,tt,O,null,null),Ft=(0,pt.hP)(JSON.stringify(n)+vt).toString(),Ot=(0,pt.hP)(`${n.url}${JSON.stringify(n.colorSubstitutions)}`).toString();let Rt=(0,nt.NA)(n.scaleX);if("width"in n){const ee=n.width;let Jt=1;const $t=ct.getResource(n.url);(0,$.pC)($t)&&(Jt=$t.width/$t.height),Rt/=Jt*(n.height/ee)}st.push({type:"fill",templateHash:Ft,materialHash:Mt?()=>Ot:Ot,cim:n,materialOverrides:null,colorLocked:n.colorLocked,effects:O,color:N(tt,z,"TintColor",j,it,Ct),height:N(tt,z,"Height",j,n.height),scaleX:N(tt,z,"ScaleX",j,Rt),angle:N(tt,z,"Rotation",j,(0,nt.NA)(n.rotation)),offsetX:N(tt,z,"OffsetX",j,(0,nt.NA)(n.offsetX)),offsetY:N(tt,z,"OffsetY",j,(0,nt.NA)(n.offsetY)),url:n.url,applyRandomOffset:!1,sampleAlphaOnly:!1})}function re(n,O,z,mt,j,ct){const st=["Rotation","OffsetX","OffsetY"],tt=mt.filter(ee=>ee.primitiveName!==n.primitiveName||!st.includes(ee.propertyName)),it=n.primitiveName,[Mt,vt]=K(mt,it,O,null,null),Ft=(0,pt.hP)(JSON.stringify(n)+vt).toString(),Ot=(0,pt.hP)(`${n.separation}${JSON.stringify(n.lineSymbol)}`).toString();let Rt={r:255,g:255,b:255,a:1};if(n.lineSymbol){const ee=n.lineSymbol?.symbolLayers.find(Jt=>"CIMSolidStroke"===Jt.type);ee&&(Rt=(0,nt.NO)(ee.color))}ct.push({type:"fill",templateHash:Ft,materialHash:Mt?F(Ot,z,tt,j):Ot,cim:n,materialOverrides:tt,colorLocked:n.colorLocked,effects:O,color:Rt,height:N(it,z,"Separation",j,n.separation),scaleX:1,angle:N(it,z,"Rotation",j,(0,nt.NA)(n.rotation)),offsetX:N(it,z,"OffsetX",j,(0,nt.NA)(n.offsetX)),offsetY:N(it,z,"OffsetY",j,(0,nt.NA)(n.offsetY)),applyRandomOffset:!1,sampleAlphaOnly:!0})}function me(n,O,z,mt,j,ct){const st=n.primitiveName,[tt,it]=K(mt,st,O,null,null),Mt=(0,pt.hP)(JSON.stringify(n)+it).toString();ct.push({type:"fill",templateHash:Mt,materialHash:tt?F(Mt,z,mt,j):Mt,cim:n,materialOverrides:null,colorLocked:n.colorLocked,effects:O,color:{r:128,g:128,b:128,a:1},height:0,angle:0,offsetX:0,offsetY:0,scaleX:1,applyRandomOffset:!1,sampleAlphaOnly:!1})}function oe(n,O,z,mt,j,ct,st,tt){const it=n.primitiveName,Mt=(0,nt.NO)(n.color),vt=void 0!==n.width?n.width:4,Ft=rt(n.capStyle),Ot=ut(n.joinStyle),Rt=n.miterLimit,[ee,Jt]=K(mt,it,O,null,null),$t=(0,pt.hP)(JSON.stringify(n)+Jt).toString();let Qt,he;if(O&&O instanceof Array&&O.length>0){const _e=O[O.length-1];if("CIMGeometricEffectDashes"===_e.type&&"NoConstraint"===_e.lineDashEnding&&null===_e.offsetAlongLine){const le=(O=[...O]).pop();Qt=le.dashTemplate,he=le.scaleDash}}ct.push({type:"line",templateHash:$t,materialHash:ee?()=>$t:$t,cim:n,materialOverrides:null,isOutline:st,colorLocked:n.colorLocked,effects:O,color:N(it,z,"Color",j,Mt,Ct),width:N(it,z,"Width",j,vt),cap:N(it,z,"CapStyle",j,Ft),join:N(it,z,"JoinStyle",j,Ot),miterLimit:N(it,z,"MiterLimit",j,Rt),referenceWidth:tt,zOrder:q(n.name),dashTemplate:Qt,scaleDash:he,sampleAlphaOnly:!0})}function pe(n,O,z,mt,j,ct,st,tt){const it=(0,pt.hP)(`${n.url}${JSON.stringify(n.colorSubstitutions)}`).toString(),Mt=n.primitiveName,vt=(0,nt.NO)(n.tintColor),Ft=void 0!==n.width?n.width:4,Ot=rt(n.capStyle),Rt=ut(n.joinStyle),ee=n.miterLimit,[Jt,$t]=K(mt,Mt,O,null,null),Qt=(0,pt.hP)(JSON.stringify(n)+$t).toString();ct.push({type:"line",templateHash:Qt,materialHash:Jt?()=>it:it,cim:n,materialOverrides:null,isOutline:st,colorLocked:n.colorLocked,effects:O,color:N(Mt,z,"TintColor",j,vt,Ct),width:N(Mt,z,"Width",j,Ft),cap:N(Mt,z,"CapStyle",j,Ot),join:N(Mt,z,"JoinStyle",j,Rt),miterLimit:N(Mt,z,"MiterLimit",j,ee),referenceWidth:tt,zOrder:q(n.name),dashTemplate:null,scaleDash:!1,url:n.url,sampleAlphaOnly:!1})}function ie(n,O,z,mt,j,ct,st,tt){const it=n.primitiveName,Mt=void 0!==n.width?n.width:4,vt=rt(n.capStyle),Ft=ut(n.joinStyle),Ot=n.miterLimit,[Rt,ee]=K(mt,it,O,null,null),Jt=(0,pt.hP)(JSON.stringify(n)+ee).toString();ct.push({type:"line",templateHash:Jt,materialHash:Rt?F(Jt,z,mt,j):Jt,cim:n,materialOverrides:null,isOutline:st,colorLocked:n.colorLocked,effects:O,color:{r:128,g:128,b:128,a:1},width:N(it,z,"Width",j,Mt),cap:N(it,z,"CapStyle",j,vt),join:N(it,z,"JoinStyle",j,Ft),miterLimit:N(it,z,"MiterLimit",j,Ot),referenceWidth:tt,zOrder:q(n.name),dashTemplate:null,scaleDash:!1,sampleAlphaOnly:!1})}function ne(n,O,z,mt,j,ct){const st=n.markerPlacement;if(!st||"CIMMarkerPlacementInsidePolygon"!==st.type)return!1;const tt=st,it=Math.abs(tt.stepX),Mt=Math.abs(tt.stepY);if(0===it||0===Mt)return!0;const vt=["Rotation","OffsetX","OffsetY"],Ft=mt.filter(le=>le.primitiveName!==n.primitiveName||!vt.includes(le.propertyName)),Ot="url"in n?n.url:null,[Rt,ee]=K(mt,tt.primitiveName,O,null,null),Jt=(0,pt.hP)(JSON.stringify(n)+ee).toString();let $t,Qt,he=null;if("Random"===st.gridType){const le=(0,zt.Wz)(jt.C1),de=Math.max(Math.floor(le/it),1),be=Math.max(Math.floor(le/Mt),1);$t=Mt*be,he=Se=>Se?Se*be:0,Qt=de*it/$t}else st.shiftOddRows?($t=2*Mt,he=le=>le?2*le:0,Qt=it/Mt*.5):($t=Mt,he=null,Qt=it/Mt);let _e={r:255,g:255,b:255,a:1};return"tintColor"in n&&(_e=(0,nt.NO)(n.tintColor)),ct.push({type:"fill",templateHash:Jt,materialHash:Rt?F(Jt,z,Ft,j):Jt,cim:n,materialOverrides:Ft,colorLocked:n.colorLocked,effects:O,color:N(tt.primitiveName,z,"TintColor",j,_e,Ct),height:N(tt.primitiveName,z,"StepY",j,$t,he),scaleX:Qt,angle:N(tt.primitiveName,z,"GridAngle",j,tt.gridAngle),offsetX:N(tt.primitiveName,z,"OffsetX",j,(0,nt.NA)(tt.offsetX)),offsetY:N(tt.primitiveName,z,"OffsetY",j,(0,nt.NA)(tt.offsetY)),url:Ot,applyRandomOffset:"Random"===st.gridType,sampleAlphaOnly:!Ot}),!0}function It(n,O,z,mt,j,ct,st,tt,it){const Mt=n.primitiveName,vt=(0,nt.NA)(n.size);let Ft=(0,nt.NA)(n.scaleX,1);const Ot=(0,nt.NA)(n.rotation),Rt=(0,nt.NA)(n.offsetX),ee=(0,nt.NA)(n.offsetY),Jt=n.tintColor?(0,nt.NO)(n.tintColor):{r:255,g:255,b:255,a:1},$t=(0,pt.hP)(`${n.url}${JSON.stringify(n.colorSubstitutions)}${JSON.stringify(n.animatedSymbolProperties)}`).toString(),Qt=E(n.markerPlacement,mt,z,j),he=function U(n,O,z,mt){const j=[];if(dt.E0.findApplicableOverrides(n,O,j),0===j.length)return n;for(const ct of j)if(ct.valueExpressionInfo){const st=z[ct.primitiveName]&&z[ct.primitiveName][ct.propertyName];st instanceof Lt.mz&&(ct.fn=(tt,it,Mt)=>(0,Xt.Z)(st,tt,{$view:Mt},mt.geometryType,it))}return(ct,st,tt)=>{for(const vt of j)vt.fn&&(vt.value=vt.fn(ct,st,tt));const it=(0,Bt.d9)(n),Mt=n.primitiveName;for(const vt of j)if(vt.primitiveName===Mt){const Ft=v(vt.propertyName);if(null!=vt.value){const Ot=_t(vt.value,vt.propertyName);Ot!==it[Ft]&&(it[Ft]=Ot)}}return it}}(n.animatedSymbolProperties,mt,z,j),[_e,le]=K(mt,Mt,O,Qt,he),de=(0,pt.hP)(JSON.stringify(n)+le).toString(),be=n.anchorPoint??{x:0,y:0};if("width"in n){const ye=n.width;let ue=1;const Ce=ct.getResource(n.url);(0,$.pC)(Ce)&&(ue=Ce.width/Ce.height),Ft/=ue*(vt/ye)}function Se(ye,ue){return(0,nt.hf)(he,ye,ue)}st.push({type:"marker",templateHash:de,materialHash:n.animatedSymbolProperties&&!0===n.animatedSymbolProperties.randomizeStartTime?(ye,ue,Ce,xe)=>{const ke=function te(n){return Math.floor(function Wt(n,O){let z;if("string"==typeof n)z=(0,pt.hP)(n+`-seed(${O})`);else{let mt=12;z=n^O;do{z=107*(z>>8^z)+mt|0}while(0!=--mt)}return(1+z/(1<<31))/2}(n,Q)*Pt)}(xe),Le=Se(ye,ue);return $t+`-MATERIALGROUP(${ke})-ASP(${JSON.stringify(Le)})`}:_e?(ye,ue)=>{const Ce=Se(ye,ue);return $t+`-ASP(${JSON.stringify(Ce)})`}:$t,cim:n,materialOverrides:null,colorLocked:n.colorLocked,effects:O,scaleSymbolsProportionally:!1,alignment:tt,size:N(Mt,z,"Size",j,vt),scaleX:N(Mt,z,"ScaleX",j,Ft),rotation:N(Mt,z,"Rotation",j,Ot),offsetX:N(Mt,z,"OffsetX",j,Rt),offsetY:N(Mt,z,"OffsetY",j,ee),color:N(Mt,z,"TintColor",j,Jt,Ct),anchorPoint:{x:be.x,y:-be.y},isAbsoluteAnchorPoint:"Relative"!==n.anchorPointUnits,outlineColor:{r:0,g:0,b:0,a:0},outlineWidth:0,frameHeight:0,rotateClockwise:n.rotateClockwise,referenceSize:it,sizeRatio:1,markerPlacement:Qt,url:n.url,animatedSymbolProperties:he})}function h(n,O,z,mt,j,ct,st,tt,it,Mt){const vt=n.markerGraphics;if(!vt)return;let Ft=0;if(n.scaleSymbolsProportionally){const Rt=n.frame;Rt&&(Ft=Rt.ymax-Rt.ymin)}const Ot=E(n.markerPlacement,mt,z,j);for(const Rt of vt)if(Rt){const ee=Rt.symbol;if(!ee)continue;switch(ee.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":Y(n,O,Ot,null,Rt,mt,z,j,ct,st,tt,it,Ft,Mt);break;case"CIMTextSymbol":I(n,O,Ot,Rt,z,mt,j,ct,tt,it,Ft)}}}function I(n,O,z,mt,j,ct,st,tt,it,Mt,vt){dt.E0.findApplicableOverrides(mt,ct,[]);const Ot=mt.geometry;if(!("x"in Ot)||!("y"in Ot))return;const Rt=mt.symbol,ee=(0,nt.BX)(Rt),Jt=(0,nt.wi)(Rt.fontStyleName),$t=(0,Dt.BN)(Rt.fontFamilyName);Rt.font={family:$t,decoration:ee,...Jt};const Qt=n.frame,he=Ot.x-.5*(Qt.xmin+Qt.xmax),_e=Ot.y-.5*(Qt.ymin+Qt.ymax),le=n.size/vt,de=n.primitiveName,be=(0,nt.NA)(Rt.height)*le,Se=(0,nt.NA)(Rt.angle),ge=(0,nt.NA)(n.offsetX)+((0,nt.NA)(Rt.offsetX)+he)*le,ye=(0,nt.NA)(n.offsetY)+((0,nt.NA)(Rt.offsetY)+_e)*le,ue=(0,nt.NO)((0,nt.W7)(Rt));let Ce=(0,nt.NO)((0,nt.$Z)(Rt)),xe=(0,nt.F)(Rt);xe||(Ce=(0,nt.NO)((0,nt.W7)(Rt.haloSymbol)),xe=Rt.haloSize*le);const[ke,Le]=K(ct,de,O,z,null),Ne=JSON.stringify(n.effects)+Number(n.colorLocked).toString()+JSON.stringify(n.anchorPoint)+n.anchorPointUnits+JSON.stringify(n.markerPlacement)+n.size.toString(),Te=(0,pt.hP)(JSON.stringify(mt)+Ne+Le).toString();let Me=N(mt.primitiveName,j,"TextString",st,mt.textString,nt.QI,Rt.textCase);if(null==Me)return;const{fontStyleName:Ee}=Rt,Ae=$t+(Ee?"-"+Ee.toLowerCase():"-regular"),Ie=Ae;"string"==typeof Me&&Me.includes("[")&&Rt.fieldMap&&(Me=(0,nt.Qs)(Rt.fieldMap,Me,Rt.textCase)),tt.push({type:"text",templateHash:Te,materialHash:ke||"function"==typeof Me||Me.match(/\[(.*?)\]/)?(S,e,i)=>Ie+"-"+(0,nt.hf)(Me,S,e,i):Ie+"-"+(0,pt.hP)(Me),cim:Rt,materialOverrides:null,colorLocked:n.colorLocked,effects:O,alignment:it,anchorPoint:{x:n.anchorPoint?n.anchorPoint.x:0,y:n.anchorPoint?n.anchorPoint.y:0},isAbsoluteAnchorPoint:"Relative"!==n.anchorPointUnits,fontName:Ae,decoration:ee,weight:N(de,j,"Weight",st,Jt.weight),style:N(de,j,"Size",st,Jt.style),size:N(de,j,"Size",st,be),angle:N(de,j,"Rotation",st,Se),offsetX:N(de,j,"OffsetX",st,ge),offsetY:N(de,j,"OffsetY",st,ye),horizontalAlignment:(0,nt.X_)(Rt.horizontalAlignment),verticalAlignment:(0,nt.FG)(Rt.verticalAlignment),text:Me,color:ue,outlineColor:Ce,outlineSize:xe,referenceSize:Mt,sizeRatio:1,markerPlacement:z})}function Y(n,O,z,mt,j,ct,st,tt,it,Mt,vt,Ft,Ot,Rt){const ee=j.symbol,Jt=ee.symbolLayers;if(!Jt)return;if(Rt)return void Z(n,O,z,mt,j,st,ct,tt,it,Mt,vt,Ft,Ot);let $t=Jt.length;if(W(Jt))return void function R(n,O,z,mt,j,ct,st,tt,it,Mt,vt,Ft,Ot){const Rt=j.geometry,ee=ct[0],Jt=ct[1],$t=(0,Nt.bk)(Rt);if(!$t)return;const Qt="Relative"!==n.anchorPointUnits,[he,_e,le]=(0,Nt.UV)($t,n.frame,n.size,n.anchorPoint,Qt),de={type:"sdf",geom:Rt,asFill:!0},be=n.primitiveName,Se=(0,nt.NA)(n.size),ge=(0,nt.NA)(n.rotation),ye=(0,nt.NA)(n.offsetX),ue=(0,nt.NA)(n.offsetY),Ce=Jt.path,xe=Jt.primitiveName,ke=ee.primitiveName,Le=(0,nt.NO)((0,nt.W7)(Jt)),Ne=(0,nt.NO)((0,nt.$Z)(ee)),Te=(0,nt.F)(ee);let Me=!1,Ee="";for(const e of st)e.primitiveName!==xe&&e.primitiveName!==ke&&e.primitiveName!==be||(void 0!==e.value?Ee+=`-${e.primitiveName}-${e.propertyName}-${JSON.stringify(e.value)}`:e.valueExpressionInfo&&(Me=!0));const Ae=JSON.stringify({...n,markerGraphics:null}),Ie=(0,pt.hP)(JSON.stringify(de)+Ce).toString(),S={type:"marker",templateHash:(0,pt.hP)(JSON.stringify(j)+JSON.stringify(Jt)+JSON.stringify(ee)+Ae+Ee).toString(),materialHash:Me?()=>Ie:Ie,cim:de,materialOverrides:null,colorLocked:n.colorLocked,effects:O,scaleSymbolsProportionally:n.scaleSymbolsProportionally,alignment:vt,anchorPoint:{x:_e,y:le},isAbsoluteAnchorPoint:Qt,size:N(n.primitiveName,tt,"Size",it,Se),rotation:N(n.primitiveName,tt,"Rotation",it,ge),offsetX:N(n.primitiveName,tt,"OffsetX",it,ye),offsetY:N(n.primitiveName,tt,"OffsetY",it,ue),scaleX:1,frameHeight:Ot,rotateClockwise:n.rotateClockwise,referenceSize:Ft,sizeRatio:he,color:N(xe,tt,"Color",it,Le,Ct),outlineColor:N(ke,tt,"Color",it,Ne,Ct),outlineWidth:N(ke,tt,"Width",it,Te),markerPlacement:z,path:Ce,animatedSymbolProperties:mt};Mt.push(S)}(n,O,z,mt,j,Jt,ct,st,tt,it,vt,Ft,Ot);const Qt=Ut.j.applyEffects(ee.effects,j.geometry,Mt.geometryEngine);if(Qt)for(;$t--;){const he=Jt[$t];if(he&&!1!==he.enable)switch(he.type){case"CIMSolidFill":case"CIMSolidStroke":{const _e=Ut.j.applyEffects(he.effects,Qt,Mt.geometryEngine),le=(0,Nt.bk)(_e);if(!le)continue;const de="Relative"!==n.anchorPointUnits,[be,Se,ge]=(0,Nt.UV)(le,n.frame,n.size,n.anchorPoint,de),ye="CIMSolidFill"===he.type,ue={type:"sdf",geom:_e,asFill:ye},Ce=n.primitiveName,xe=(0,nt.NA)(n.size)??10,ke=(0,nt.NA)(n.rotation),Le=(0,nt.NA)(n.offsetX),Ne=(0,nt.NA)(n.offsetY),Te=he.path,Me=he.primitiveName,Ee=(0,nt.NO)(ye?(0,nt.W7)(he):(0,nt.$Z)(he)),Ae=ye?{r:0,g:0,b:0,a:0}:(0,nt.NO)((0,nt.$Z)(he)),Ie=(0,nt.F)(he);if(!ye&&!Ie)break;let S=!1,e="";for(const y of ct)y.primitiveName!==Me&&y.primitiveName!==Ce||(void 0!==y.value?e+=`-${y.primitiveName}-${y.propertyName}-${JSON.stringify(y.value)}`:y.valueExpressionInfo&&(S=!0));(0,$.pC)(O)&&"function"==typeof O&&(S=!0);const i=JSON.stringify({...n,markerGraphics:null}),r=(0,pt.hP)(JSON.stringify(ue)+Te).toString(),x={type:"marker",templateHash:(0,pt.hP)(JSON.stringify(j)+JSON.stringify(he)+i+e).toString(),materialHash:S?()=>r:r,cim:ue,materialOverrides:null,colorLocked:n.colorLocked,effects:O,scaleSymbolsProportionally:n.scaleSymbolsProportionally,alignment:vt,anchorPoint:{x:Se,y:ge},isAbsoluteAnchorPoint:de,size:N(n.primitiveName,st,"Size",tt,xe),rotation:N(n.primitiveName,st,"Rotation",tt,ke),offsetX:N(n.primitiveName,st,"OffsetX",tt,Le),offsetY:N(n.primitiveName,st,"OffsetY",tt,Ne),scaleX:1,frameHeight:Ot,rotateClockwise:n.rotateClockwise,referenceSize:Ft,sizeRatio:be,color:N(Me,st,"Color",tt,Ee,Ct),outlineColor:N(Me,st,"Color",tt,Ae,Ct),outlineWidth:N(Me,st,"Width",tt,Ie),markerPlacement:z,animatedSymbolProperties:mt,path:Te};it.push(x);break}default:Z(n,O,z,mt,j,st,ct,tt,it,Mt,vt,Ft,Ot)}}}function Z(n,O,z,mt,j,ct,st,tt,it,Mt,vt,Ft,Ot){const Rt=function ft(n,O){return{type:n.type,enable:!0,name:n.name,colorLocked:n.colorLocked,primitiveName:n.primitiveName,anchorPoint:n.anchorPoint,anchorPointUnits:n.anchorPointUnits,offsetX:0,offsetY:0,rotateClockwise:n.rotateClockwise,rotation:0,size:n.size,billboardMode3D:n.billboardMode3D,depth3D:n.depth3D,frame:n.frame,markerGraphics:[O],scaleSymbolsProportionally:n.scaleSymbolsProportionally,respectFrame:n.respectFrame,clippingPath:n.clippingPath}}(n,j),ee=["Rotation","OffsetX","OffsetY"],Jt=st.filter(ue=>ue.primitiveName!==n.primitiveName||!ee.includes(ue.propertyName));let $t="";for(const ue of st)void 0!==ue.value&&($t+=`-${ue.primitiveName}-${ue.propertyName}-${JSON.stringify(ue.value)}`);const[Qt,he,_e]=dt.B$.getTextureAnchor(Rt,Mt),le=n.primitiveName,de=(0,nt.NA)(n.rotation),be=(0,nt.NA)(n.offsetX),Se=(0,nt.NA)(n.offsetY),ge=(0,pt.hP)(JSON.stringify(Rt)+$t).toString(),ye={type:"marker",templateHash:ge,materialHash:Jt.length>0||(0,$.pC)(O)&&"function"==typeof O?F(ge,ct,Jt,tt):ge,cim:Rt,materialOverrides:Jt,colorLocked:n.colorLocked,effects:O,scaleSymbolsProportionally:n.scaleSymbolsProportionally,alignment:vt,anchorPoint:{x:Qt,y:he},isAbsoluteAnchorPoint:!1,size:n.size,rotation:N(le,ct,"Rotation",tt,de),offsetX:N(le,ct,"OffsetX",tt,be),offsetY:N(le,ct,"OffsetY",tt,Se),color:{r:255,g:255,b:255,a:1},outlineColor:{r:0,g:0,b:0,a:0},outlineWidth:0,scaleX:1,frameHeight:Ot,rotateClockwise:n.rotateClockwise,referenceSize:Ft,sizeRatio:_e/(0,zt.F2)(n.size),markerPlacement:z,animatedSymbolProperties:mt};it.push(ye)}function q(n){if(n&&0===n.indexOf("Level_")){const O=parseInt(n.substr(6),10);if(!isNaN(O))return O}return 0}function Ct(n){if(!n||0===n.length)return null;const O=new yt.Z(n).toRgba();return{r:O[0],g:O[1],b:O[2],a:O[3]}}function N(n,O,z,mt,j,ct,st){const tt=O[n];if(tt){const it=tt[z];if("string"==typeof it||"number"==typeof it||it instanceof Array)return ct?ct.call(null,it,st):it;if(null!=it&&it instanceof Lt.mz)return(Mt,vt,Ft)=>{let Ot=(0,Xt.Z)(it,Mt,{$view:Ft},mt.geometryType,vt);return null!==Ot&&ct&&(Ot=ct.call(null,Ot,st)),null!==Ot?Ot:j}}return j}function v(n){return n&&n.charAt(0).toLowerCase()+n.substr(1)}function k(n,O,z,mt){for(const j of O)if(j.valueExpressionInfo){const ct=z[j.primitiveName]&&z[j.primitiveName][j.propertyName];ct instanceof Lt.mz&&(j.fn=(st,tt,it)=>(0,Xt.Z)(ct,st,{$view:it},mt.geometryType,tt))}return(j,ct,st)=>{for(const it of O)it.fn&&(it.value=it.fn(j,ct,st));const tt=[];for(let it of n){const Mt=it?.primitiveName;if(Mt){let vt=!1;for(const Ft of O)if(Ft.primitiveName===Mt){const Ot=v(Ft.propertyName);null!=Ft.value&&Ft.value!==it[Ot]&&(vt||(it=(0,Bt.d9)(it),vt=!0),it[Ot]=Ft.value)}}tt.push(it)}return tt}}function E(n,O,z,mt){const j=[];if(dt.E0.findApplicableOverrides(n,O,j),0===j.length)return n;for(const ct of j)if(ct.valueExpressionInfo){const st=z[ct.primitiveName]&&z[ct.primitiveName][ct.propertyName];st instanceof Lt.mz&&(ct.fn=(tt,it,Mt)=>(0,Xt.Z)(st,tt,{$view:Mt},mt.geometryType,it))}return(ct,st,tt)=>{for(const vt of j)vt.fn&&(vt.value=vt.fn(ct,st,tt));const it=(0,Bt.d9)(n),Mt=n.primitiveName;for(const vt of j)if(vt.primitiveName===Mt){const Ft=v(vt.propertyName);null!=vt.value&&vt.value!==it[Ft]&&(it[Ft]=vt.value)}return it}}function F(n,O,z,mt){for(const j of z)if(j.valueExpressionInfo){const ct=O[j.primitiveName]&&O[j.primitiveName][j.propertyName];ct instanceof Lt.mz&&(j.fn=(st,tt,it)=>(0,Xt.Z)(ct,st,{$view:it},mt.geometryType,tt))}return(j,ct,st)=>{for(const tt of z)tt.fn&&(tt.value=tt.fn(j,ct,st));return(0,pt.hP)(n+dt.E0.buildOverrideKey(z)).toString()}}function J(n,O){if(!O||0===O.length)return n;const z=(0,Bt.d9)(n);return dt.E0.applyOverrides(z,O),z}function K(n,O,z,mt,j){let ct=!1,st="";for(const tt of n)tt.primitiveName===O&&(void 0!==tt.value?st+=`-${tt.primitiveName}-${tt.propertyName}-${JSON.stringify(tt.value)}`:tt.valueExpressionInfo&&(ct=!0));return(0,$.pC)(z)&&"function"==typeof z&&(ct=!0),(0,$.pC)(mt)&&"function"==typeof mt&&(ct=!0),(0,$.pC)(j)&&"function"==typeof j&&(ct=!0),[ct,st]}const W=n=>n&&2===n.length&&n[0].enable&&n[1].enable&&"CIMSolidStroke"===n[0].type&&"CIMSolidFill"===n[1].type&&!n[0].effects&&!n[1].effects},73608:(ve,fe,at)=>{at.d(fe,{j:()=>$});var At=at(91179),yt=at(72283),Dt=at(29214),Bt=at(95727);class ${static executeEffects(pt,Lt,dt){const Tt=(0,yt.GP)(Lt);let Zt=new Dt.M(Tt);for(const et of pt){const _t=(0,Bt.h)(et);_t&&(Zt=_t.execute(Zt,et,1.3333333333333333,dt))}return Zt}static next(pt){const Lt=pt.next();return(0,yt.wp)(Lt),Lt}static applyEffects(pt,Lt,dt){if(!pt)return Lt;let Tt=new Dt.M(Lt);for(const et of pt){const _t=(0,Bt.h)(et);_t&&(Tt=_t.execute(Tt,et,1,dt))}let Kt,Zt=null;for(;Kt=Tt.next();)Zt?(0,At.l9)(Zt)?(0,At.l9)(Kt)&&Zt.paths.push(...Kt.paths):(0,At.oU)(Zt)&&(0,At.oU)(Kt)&&Zt.rings.push(...Kt.rings):Zt=Kt;return Zt}}},40028:(ve,fe,at)=>{var At,yt,dt;function Dt(dt){switch(dt){case"left":return At.Left;case"right":return At.Right;case"center":return At.Center}}function Bt(dt){switch(dt){case"top":return yt.Top;case"middle":return yt.Center;case"baseline":return yt.Baseline;case"bottom":return yt.Bottom}}function se(dt){switch(dt){case"above-left":case"esriServerPointLabelPlacementAboveLeft":return[At.Right,yt.Bottom];case"above-center":case"above-along":case"esriServerPointLabelPlacementAboveCenter":case"esriServerLinePlacementAboveAlong":return[At.Center,yt.Bottom];case"above-right":case"esriServerPointLabelPlacementAboveRight":return[At.Left,yt.Bottom];case"center-left":case"esriServerPointLabelPlacementCenterLeft":return[At.Right,yt.Center];case"center-center":case"center-along":case"esriServerPointLabelPlacementCenterCenter":case"esriServerLinePlacementCenterAlong":case"always-horizontal":case"esriServerPolygonPlacementAlwaysHorizontal":return[At.Center,yt.Center];case"center-right":case"esriServerPointLabelPlacementCenterRight":return[At.Left,yt.Center];case"below-left":case"esriServerPointLabelPlacementBelowLeft":return[At.Right,yt.Top];case"below-center":case"below-along":case"esriServerPointLabelPlacementBelowCenter":case"esriServerLinePlacementBelowAlong":return[At.Center,yt.Top];case"below-right":case"esriServerPointLabelPlacementBelowRight":return[At.Left,yt.Top];default:return console.debug(`Found invalid placement type ${dt}`),[At.Center,yt.Center]}}function $(dt){switch(dt){case At.Right:return-1;case At.Center:return 0;case At.Left:return 1;default:return console.debug(`Found invalid horizontal alignment ${dt}`),0}}function zt(dt){switch(dt){case yt.Top:return 1;case yt.Center:return 0;case yt.Bottom:case yt.Baseline:return-1;default:return console.debug(`Found invalid vertical alignment ${dt}`),0}}function pt(dt){switch(dt){case"left":return At.Left;case"right":return At.Right;case"center":return At.Center}}function Lt(dt){switch(dt){case"above-along":case"below-along":case"center-along":case"esriServerLinePlacementAboveAlong":case"esriServerLinePlacementBelowAlong":case"esriServerLinePlacementCenterAlong":return!0;default:return!1}}at.d(fe,{Hd:()=>pt,NS:()=>Lt,TR:()=>yt,b7:()=>Bt,g:()=>$,kH:()=>Dt,qv:()=>se,tf:()=>zt}),(dt=At||(At={}))[dt.Left=-1]="Left",dt[dt.Center=0]="Center",dt[dt.Right=1]="Right",function(dt){dt[dt.Top=1]="Top",dt[dt.Center=0]="Center",dt[dt.Bottom=-1]="Bottom",dt[dt.Baseline=2]="Baseline"}(yt||(yt={}))},25797:(ve,fe,at)=>{at.d(fe,{Nr:()=>Pt});var At=at(31478),yt=at(12225),Dt=at(67831),Bt=at(9545),se=at(40028),$=at(5254),zt=at(84439);class pt{constructor(rt,ut,ht,St){this.center=(0,Bt.f)(rt,ut),this.centerT=(0,Bt.c)(),this.halfWidth=ht/2,this.halfHeight=St/2,this.width=ht,this.height=St}get x(){return this.center[0]}get y(){return this.center[1]}get blX(){return this.center[0]+this.halfWidth}get blY(){return this.center[1]+this.halfHeight}get trX(){return this.center[0]-this.halfWidth}get trY(){return this.center[1]-this.halfHeight}get xmin(){return this.x-this.halfWidth}get xmax(){return this.x+this.halfWidth}get ymin(){return this.y-this.halfHeight}get ymax(){return this.y+this.halfHeight}set x(rt){this.center[0]=rt}set y(rt){this.center[1]=rt}clone(){return new pt(this.x,this.y,this.width,this.height)}serialize(rt){return rt.writeF32(this.center[0]),rt.writeF32(this.center[1]),rt.push(this.width),rt.push(this.height),rt}findCollisionDelta(rt,ut=4){const ht=Math.abs(rt.centerT[0]-this.centerT[0]),St=Math.abs(rt.centerT[1]-this.centerT[1]),Vt=Math.min((rt.halfWidth+this.halfWidth+ut)/ht,(rt.halfHeight+this.halfHeight+ut)/St);return Math.log2(Vt)}extend(rt){const ut=Math.min(this.xmin,rt.xmin),ht=Math.min(this.ymin,rt.ymin),St=Math.max(this.xmax,rt.xmax)-ut,kt=Math.max(this.ymax,rt.ymax)-ht,Ht=ut+St/2,Vt=ht+kt/2;this.width=St,this.height=kt,this.halfWidth=St/2,this.halfHeight=kt/2,this.x=Ht,this.y=Vt}static deserialize(rt){const ut=rt.readF32(),ht=rt.readF32(),St=rt.readInt32(),kt=rt.readInt32();return new pt(ut,ht,St,kt)}}const _t=Math.PI/180;class Nt{constructor(rt,ut,ht,St){this._rotationT=(0,yt.c)(),this._xBounds=0,this._yBounds=0,this.minZoom=0,this.maxZoom=255,this._bounds=null;const kt=ht.rect,Ht=new Float32Array(8);ut*=St;const Vt=ht.code?kt.width*St:ht.metrics.width,Gt=ht.code?kt.height*St:ht.metrics.height;Ht[0]=rt*=St,Ht[1]=ut,Ht[2]=rt+Vt,Ht[3]=ut,Ht[4]=rt,Ht[5]=ut+Gt,Ht[6]=rt+Vt,Ht[7]=ut+Gt,this._data=Ht,this._setTextureCoords(kt),this._scale=St,this._mosaic=ht,this.x=rt,this.y=ut,this.maxOffset=Math.max(rt+Vt,ut+Gt)}get width(){return this._mosaic.metrics.width*this._scale}get mosaic(){return this._mosaic}set angle(rt){this._angle=rt,(0,At.b)(this._rotationT,-rt),this._setOffsets(this._data)}get angle(){return this._angle}get xTopLeft(){return this._data[0]}get yTopLeft(){return this._data[1]}get xBottomRight(){return this._data[6]}get yBottomRight(){return this._data[7]}get texcoords(){return this._texcoords}get textureBinding(){return this._mosaic.textureBinding}get offsets(){return this._offsets||this._setOffsets(this._data),this._offsets}get char(){return String.fromCharCode(this._mosaic.code)}get code(){return this._mosaic.code}get bounds(){if(!this._bounds){const{height:rt,width:ut}=this._mosaic.metrics,ht=ut*this._scale,St=Math.abs(rt)*this._scale,kt=new Float32Array(8);kt[0]=this.x,kt[1]=this.y,kt[2]=this.x+ht,kt[3]=this.y,kt[4]=this.x,kt[5]=this.y+St,kt[6]=this.x+ht,kt[7]=this.y+St;const Ht=(0,At.m)((0,yt.c)(),this._rotationT,this._transform);(0,yt.t)(kt,kt,Ht);let Vt=1/0,Gt=1/0,wt=0,re=0;for(let ne=0;ne<4;ne++){const It=kt[2*ne],h=kt[2*ne+1];Vt=Math.min(Vt,It),Gt=Math.min(Gt,h),wt=Math.max(wt,It),re=Math.max(re,h)}const me=wt-Vt,oe=re-Gt;this._bounds=new pt(Vt+me/2,Gt+oe/2,me,oe)}return this._bounds}setTransform(rt){this._transform=rt,this._offsets=null}_setOffsets(rt){this._offsets||(this._offsets={upperLeft:0,upperRight:0,lowerLeft:0,lowerRight:0});const ut=this._offsets,ht=new Float32Array(8),St=(0,At.m)((0,yt.c)(),this._rotationT,this._transform);(0,yt.t)(ht,rt,St),ut.upperLeft=(0,$.UJ)(8*ht[0],8*ht[1]),ut.upperRight=(0,$.UJ)(8*ht[2],8*ht[3]),ut.lowerLeft=(0,$.UJ)(8*ht[4],8*ht[5]),ut.lowerRight=(0,$.UJ)(8*ht[6],8*ht[7])}_setTextureCoords({x:rt,y:ut,width:ht,height:St}){this._texcoords={upperLeft:(0,$.UJ)(rt,ut),upperRight:(0,$.UJ)(rt+ht,ut),lowerLeft:(0,$.UJ)(rt,ut+St),lowerRight:(0,$.UJ)(rt+ht,ut+St)}}}const nt=(bt,rt)=>({code:0,page:0,sdf:!0,rect:new zt.Z(0,0,11,8),textureBinding:rt,metrics:{advance:0,height:4,width:bt,left:0,top:0}});class Ut{constructor(rt,ut,ht){this._rotation=0,this._decorate(rt,ut,ht),this.glyphs=rt,this.bounds=this._createBounds(rt),this.isMultiline=ut.length>1,this._hasRotation=0!==ht.angle,this._transform=this._createGlyphTransform(this.bounds,ht);for(const St of rt)St.setTransform(this._transform)}setRotation(rt){if(0===rt&&0===this._rotation)return;this._rotation=rt;const ut=this._transform,ht=(0,At.b)((0,yt.c)(),rt);(0,At.m)(ut,ht,ut);for(const St of this.glyphs)St.setTransform(this._transform)}_decorate(rt,ut,ht){if(!ht.decoration||"none"===ht.decoration||!rt.length)return;const St=ht.scale,kt="underline"===ht.decoration?30:20,Ht=rt[0].textureBinding;for(const Vt of ut)rt.push(new Nt(Vt.startX*St,Vt.startY*St+kt*St,nt((Vt.width+Vt.glyphWidthEnd)*St,Ht),1))}get boundsT(){const rt=this.bounds,ut=(0,Dt.s)((0,Bt.c)(),rt.x,rt.y);if((0,Dt.t)(ut,ut,this._transform),this._hasRotation){const ht=Math.max(rt.width,rt.height);return new pt(ut[0],ut[1],ht,ht)}return new pt(ut[0],ut[1],rt.width,rt.height)}_createBounds(rt){let ut=1/0,ht=1/0,St=0,kt=0;for(const Gt of rt)ut=Math.min(ut,Gt.xTopLeft),ht=Math.min(ht,Gt.yTopLeft),St=Math.max(St,Gt.xTopLeft+Gt.width),kt=Math.max(kt,Gt.yBottomRight);const Ht=St-ut,Vt=kt-ht;return new pt(ut+Ht/2,ht+Vt/2,Ht,Vt)}_createGlyphTransform(rt,ut){const ht=_t*ut.angle,St=(0,yt.c)(),kt=(0,Bt.c)();return(0,At.t)(St,St,(0,Dt.s)(kt,ut.xOffset,-ut.yOffset)),ut.isCIM?(0,At.r)(St,St,ht):((0,At.t)(St,St,(0,Dt.s)(kt,rt.x,rt.y)),(0,At.r)(St,St,ht),(0,At.t)(St,St,(0,Dt.s)(kt,-rt.x,-rt.y))),St}}class Xt{constructor(rt,ut,ht,St,kt,Ht){this.glyphWidthEnd=0,this.startX=0,this.startY=0,this.start=Math.max(0,Math.min(ut,ht)),this.end=Math.max(0,Math.max(ut,ht)),this.end<rt.length&&(this.glyphWidthEnd=rt[this.end].metrics.width),this.width=St,this.yMin=kt,this.yMax=Ht}}const jt=bt=>10===bt,Wt=bt=>32===bt;function Pt(bt,rt,ut){const ht=ut.scale,St=new Array,kt=function te(bt,rt,ut){const ht=new Array,kt=ut.maxLineWidth*(1/ut.scale),Ht=rt?bt.length-1:0,Vt=rt?-1:bt.length,Gt=rt?-1:1;let wt=Ht,re=0,me=0,oe=wt,pe=oe,ie=0,ne=1/0,It=0;for(;wt!==Vt;){const{code:I,metrics:Y}=bt[wt],R=Math.abs(Y.top);jt(I)||Wt(I)||(ne=Math.min(ne,R),It=Math.max(It,R+Y.height)),jt(I)?(wt!==Ht&&(ht.push(new Xt(bt,oe,wt-Gt,re,ne,It)),ne=1/0,It=0),re=0,oe=wt+Gt,pe=wt+Gt,me=0):Wt(I)?(pe=wt+Gt,me=0,ie=Y.advance,re+=Y.advance):re>kt?(pe!==oe?(re-=ie,ht.push(new Xt(bt,oe,pe-2*Gt,re-me,ne,It)),ne=1/0,It=0,oe=pe,re=me):(ht.push(new Xt(bt,oe,wt-Gt,re,ne,It)),ne=1/0,It=0,oe=wt,pe=wt,re=0),re+=Y.advance,me+=Y.advance):(re+=Y.advance,me+=Y.advance),wt+=Gt}const h=new Xt(bt,oe,wt-Gt,re,ne,It);return h.start>=0&&h.end<bt.length&&ht.push(h),ht}(bt,rt,ut),Ht=function Q(bt,rt){let ut=0;for(let kt=0;kt<bt.length;kt++){const{width:Ht}=bt[kt];ut=Math.max(Ht,ut)}const St=bt[0].yMin;return{x:0,y:St,height:bt[bt.length-1].yMax+rt.lineHeight*(bt.length-1)+("underline"===rt.decoration?4:0)-St,width:ut}}(kt,ut),{vAlign:Vt,hAlign:Gt}=ut,wt=Vt===se.TR.Baseline?1:0,me=(1-wt)*-Ht.y+Ht.height/2*(wt?0:Vt-1)+-26*(wt?1:0);for(let oe=0;oe<kt.length;oe++){const{start:pe,end:ie,width:ne}=kt[oe];let It=-1*(Gt+1)*(ne/2)-3;const h=oe*ut.lineHeight+me-3;kt[oe].startX=It,kt[oe].startY=h;for(let I=pe;I<=ie;I++){const Y=bt[I];if(jt(Y.code))continue;const R=new Nt(It+Y.metrics.left,h-Y.metrics.top,Y,ht);It+=Y.metrics.advance,St.push(R)}}return new Ut(St,kt,ut)}}}]);