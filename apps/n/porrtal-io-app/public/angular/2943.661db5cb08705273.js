/*
Copyright 2022 Comcast Cable Communications Management, LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
"use strict";(self.webpackChunka_porrtal_io_app=self.webpackChunka_porrtal_io_app||[]).push([[2943],{8549:($e,he,L)=>{L.d(he,{C:()=>se,b:()=>de});var A=L(10109),ie=L(33726),M=L(2166),V=L(95285),_e=L(69960),Me=L(17625),Ge=L(22355),J=L(42743),le=L(16396);function de(U){const w=new Ge.kG;return w.extensions.add("GL_OES_standard_derivatives"),(0,M.S)(w,U),w.attributes.add(le.T.POSITION,"vec3"),w.attributes.add(le.T.UV0,"vec2"),w.varyings.add("vUV","vec2"),U.hasMultipassTerrain&&w.varyings.add("depth","float"),w.vertex.code.add(Me.H`
    void main(void) {
      vUV = uv0;
      ${U.hasMultipassTerrain?"depth = (view * vec4(position, 1.0)).z;":""}
      gl_Position = proj * view * vec4(position, 1.0);
    }
  `),w.include(A.l,U),w.fragment.uniforms.add(new V.A("size",I=>I.size)),w.fragment.uniforms.add(new _e.N("color1",I=>I.color1)),w.fragment.uniforms.add(new _e.N("color2",I=>I.color2)),w.fragment.include(ie.Y),w.fragment.code.add(Me.H`
    void main() {
      ${U.hasMultipassTerrain?"terrainDepthTest(gl_FragCoord, depth);":""}
      vec2 uvScaled = vUV / (2.0 * size);

      vec2 uv = fract(uvScaled - 0.25);
      vec2 ab = clamp((abs(uv - 0.5) - 0.25) / fwidth(uvScaled), -0.5, 0.5);
      float fade = smoothstep(0.25, 0.5, max(fwidth(uvScaled.x), fwidth(uvScaled.y)));
      float t = mix(abs(ab.x + ab.y), 0.5, fade);

      gl_FragColor = mix(color2, color1, t);
      ${U.transparencyPassType===J.Am.Color?"gl_FragColor = premultiplyAlpha(gl_FragColor);":""}
    }
  `),w}const se=Object.freeze(Object.defineProperty({__proto__:null,build:de},Symbol.toStringTag,{value:"Module"}))},32943:($e,he,L)=>{L.r(he),L.d(he,{default:()=>Yt});var A=L(17626),ie=L(14517),M=L(62208),V=L(77712),J=(L(85931),L(8314),L(90912),L(76898)),le=L(39691),de=L(1437),se=L(74554),U=L(32917),w=L(55915),I=L(12080),Te=L(21286),Y=L(15572),Pe=L(67831),ze=L(99770),D=L(84161),R=L(28093),Ae=L(4794),Ee=L(65234),Xe=L(78172),Oe=L(11519),Qe=L(11544),Je=L(44766),ke=L(37118),Ue=L(10049),ce=L(98943);function nt(h,e,d){const v={distance:null};return(0,Ue.cA)(v,[h[0],h[1]],[e[0],e[1]],d),v.distance}function rt(h,e,d,v){const y=at;return(0,w.ke)(h,v,$)&&(0,w.ke)(e,v,X)&&(0,w.ke)(d,v,be)?(y.setPoint(0,0,$),y.setPoint(0,1,X),y.setPoint(0,2,be),Math.abs((0,Je.geodesicArea)(y,"square-meters"))):0}const $=(0,R.c)(),X=(0,R.c)(),be=(0,R.c)(),at=new ke.Z({rings:[[$,X,be]],spatialReference:Ee.Z.WGS84}),W=(0,R.c)();var Ve=L(495),ht=L(53929),ne=L(16730),lt=L(11915);function De(h){return(0,lt.e)(function ct(h){const e=new Float64Array(2*h.length);for(let d=0;d<h.length;++d){const v=h[d],y=2*d;e[y+0]=v[0],e[y+1]=v[1]}return e}(h),[],2)}L(90014),L(26242),L(66601),(0,R.c)();class gt{constructor(e,d){this.positionsWorldCoords=[],this.positionsRenderCoords=[],this.positionsProjectedWorldCoords=[],this.positionsFittedRenderCoords=[],this.positionsGeographic=[],this.positionsSpherical=[],this.positionsStereographic=[],this.pathSegmentLengths=[],this.geodesicPathSegmentLengths=[],this.perimeterSegmentLengths=[],this.intersectingSegments=new Set,this.geodesicIntersectingSegments=new Set,this.areaCentroidWorldCoords=(0,R.c)(),this.areaCentroidRenderCoords=(0,R.c)(),this.geodesicAreaCentroidRenderCoords=(0,R.c)(),this._length=0,this._centroidRenderCoords=(0,R.c)(),this._planeWorldCoords=(0,Ae.c)(),this._worldUp=(0,R.c)(),this._worldTangent=(0,R.c)(),this._frame=[(0,R.c)(),(0,R.c)(),(0,R.c)()],this._pathVersion=-1,this._validMeasurement=!1,this._hasCursorPoint=!1,this._mode=null,this._tempU=(0,R.c)(),this._tempV=(0,R.c)(),this._tempVec3=(0,R.c)(),this._tempSphere={center:(0,R.c)(),radius:0},this._sceneView=e,this.unitNormalizer=d}update(e,d,v,y,C,S,P){const _=this.unitNormalizer,G=this._sceneView.renderSpatialReference,T=this.unitNormalizer.spatialReference,E=(0,M.pC)(d);if(this._pathVersion===e.version&&this._validMeasurement===y&&!P&&this._hasCursorPoint===E&&this._mode===S)return!e.isValidPolygon&&(this._updateCursorSegmentLength(e,d),!0);this._pathVersion=e.version,this._validMeasurement=y,this._hasCursorPoint=E,this._resize(e.numVertices);const b=(0,I.rS)(v.spatialReference),N=(0,w.Up)(v.spatialReference,b)&&(0,w.jF)(v.spatialReference),{positionsGeographic:K,positionsWorldCoords:Le,positionsRenderCoords:Z,positionsSpherical:te}=this;e.forEachVertexPosition((x,F)=>{(function ut(h,e){e.hasZ||(e.z=(0,M.Pt)((0,ht.KO)(h,e,"ground"),0))})(v.elevationProvider,x),(0,w.KC)(x,Le[F],T),(0,w.KC)(x,Z[F],G),N&&((0,w.UY)(x,K[F]),(0,w.KC)(x,te[F],b),(0,D.n)(te[F],te[F]))});const Ce=this._updatePathLengths(y);if(this.pathLength=this._length>1?(0,Y.yG)(_.normalizeDistance(Ce),"meters"):null,N){const x=this._updateGeodesicPathLengths(y,T);this.geodesicPathLength=this._length>1?(0,Y.yG)(x,"meters"):null}else this.geodesicPathLength=null;return this._updateCursorSegmentLength(e,d),this._updateMode(e,S),y?(this._updateArea(v,_,G,T,C),N&&this._updateGeodesicArea(v),!0):(this.area=null,this.geodesicArea=null,this.perimeterLength=null,this.triangleIndices=null,this.geodesicTriangleIndices=null,this.intersectingSegments.clear(),this.geodesicIntersectingSegments.clear(),!0)}getData(){return{positionsWorldCoords:this.positionsWorldCoords,positionsRenderCoords:this.positionsRenderCoords,positionsProjectedWorldCoords:this.positionsProjectedWorldCoords,positionsFittedRenderCoords:this.positionsFittedRenderCoords,positionsGeographic:this.positionsGeographic,positionsSpherical:this.positionsSpherical,positionsStereographic:this.positionsStereographic,pathSegmentLengths:this.pathSegmentLengths,geodesicPathSegmentLengths:this.geodesicPathSegmentLengths,perimeterSegmentLengths:this.perimeterSegmentLengths,intersectingSegments:this.intersectingSegments,geodesicIntersectingSegments:this.geodesicIntersectingSegments,triangleIndices:this.triangleIndices,geodesicTriangleIndices:this.geodesicTriangleIndices,areaCentroidWorldCoords:this.areaCentroidWorldCoords,areaCentroidRenderCoords:this.areaCentroidRenderCoords,geodesicAreaCentroidRenderCoords:this.geodesicAreaCentroidRenderCoords,fittingMode:this.fittingMode,area:this.area,geodesicArea:this.geodesicArea,pathLength:this.pathLength,geodesicPathLength:this.geodesicPathLength,perimeterLength:this.perimeterLength,cursorSegmentLength:this.cursorSegmentLength,geodesicCursorSegmentLength:this.geodesicCursorSegmentLength,unitNormalizer:this.unitNormalizer,actualMeasurementMode:this.actualMeasurementMode}}_resize(e){for(e<this._length&&(this.positionsWorldCoords.length=e,this.positionsRenderCoords.length=e,this.positionsProjectedWorldCoords.length=e,this.positionsFittedRenderCoords.length=e,this.positionsGeographic.length=e,this.positionsSpherical.length=e,this.positionsStereographic.length=e,this.pathSegmentLengths.length=e,this.geodesicPathSegmentLengths.length=e,this.perimeterSegmentLengths.length=e,this._length=e);this._length<e;)this.positionsWorldCoords.push((0,R.c)()),this.positionsRenderCoords.push((0,R.c)()),this.positionsProjectedWorldCoords.push((0,ze.a)()),this.positionsFittedRenderCoords.push((0,R.c)()),this.positionsGeographic.push((0,R.c)()),this.positionsSpherical.push((0,R.c)()),this.positionsStereographic.push((0,ze.a)()),this.pathSegmentLengths.push(0),this.geodesicPathSegmentLengths.push(0),this.perimeterSegmentLengths.push(0),++this._length}_updatePathLengths(e){const d=this.positionsWorldCoords,v=this.pathSegmentLengths;let y=0;for(let C=0;C<this._length;++C){const S=v[C]=(0,D.i)(d[C],d[(C+1)%this._length]);(C<this._length-1||e)&&(y+=S)}return y}_updateGeodesicPathLengths(e,d){const v=this.positionsGeographic,y=this.geodesicPathSegmentLengths;let C=0;for(let S=0;S<this._length;++S){const P=y[S]=nt(v[S],v[(S+1)%this._length],d);(S<this._length-1||e)&&(C+=P)}return C}_updateArea(e,d,v,y,C){const S=e.renderCoordsHelper,P=this.positionsWorldCoords,_=this.positionsRenderCoords,G=this.positionsProjectedWorldCoords,T=this.positionsFittedRenderCoords,E=this._planeWorldCoords,z=this._centroidRenderCoords;(0,Ve.H)(_,z),S.worldUpAtPosition(z,this._worldUp),S.worldBasisAtPosition(z,Xe.R.X,this._worldTangent),(0,w.Qr)(z,this._worldUp,v,this._worldUp,y),(0,w.Qr)(z,this._worldTangent,v,this._worldTangent,y),P.length>2&&function et(h,e){if(h.length<3)throw new Error("need at least 3 points to fit a plane");(0,ce.pG)(h[0],h[1],h[2],e)}(P,E),this.fittingMode=this._selectFittingMode(E,P,this._worldUp,C);let b=0;if("horizontal"===this.fittingMode){let x=-1/0;_.forEach((F,Se)=>{const Ye=S.getAltitude(_[Se]);Ye>x&&(x=Ye,b=Se)})}const N=P[b];let K=E,Le=this._worldTangent;"horizontal"===this.fittingMode?K=this._worldUp:"vertical"===this.fittingMode&&(K=this._tempVec3,Le=this._worldUp,(0,ce.T)(E,this._worldUp,K)),(0,D.c)(this._frame[2],K),(0,ce.T)(Le,K,this._frame[0]),(0,D.f)(this._frame[1],this._frame[0],this._frame[2]),(0,D.o)(this._frame[1],this._frame[1]);const Z=this._tempVec3,te=this._tempU,Ce=this._tempV;for(let x=0;x<this._length;++x){const F=G[x],Se=T[x];(0,D.b)(Z,P[x],N),(0,Pe.a)(F,(0,D.e)(this._frame[0],Z),(0,D.e)(this._frame[1],Z)),(0,D.g)(te,this._frame[0],F[0]),(0,D.g)(Ce,this._frame[1],F[1]),(0,D.a)(Z,te,Ce),(0,D.a)(Z,Z,N),(0,w.SH)(Z,y,Se,v)}this.perimeterLength=this._length>0?(0,Y.yG)(d.normalizeDistance(this._updatePerimeterLengths()),"meters"):null,(0,Ve.H)(T,this.areaCentroidRenderCoords),(0,w.SH)(this.areaCentroidRenderCoords,v,this.areaCentroidWorldCoords,y),this._updateIntersectingSegments(),this.area=0===this.intersectingSegments.size?(0,Y.ne)(d.normalizeArea(this._computeArea()),"square-meters"):null}_updateGeodesicArea(e){const{renderCoordsHelper:d,spatialReference:v}=e,{positionsSpherical:y,positionsStereographic:C}=this,S=this._tempVec3,P=function ot(h,e=null,d=!0){const y=(C,S)=>{if(0===S[0]&&0===S[1]&&0===S[2])return!1;for(let P=0;P<C.length;++P)if((0,D.e)(S,C[P])<-1e-6)return!1;return!0};if(0===h.length)return!1;if(1===h.length)return e&&(0,D.c)(e,h[0]),!0;(0,D.s)(W,0,0,0);for(let C=0;C<h.length;++C)(0,D.a)(W,W,h[C]);if((0,D.n)(W,W),y(h,W))return e&&(0,D.c)(e,W),!0;if(!d)return!1;for(let C=0;C<h.length;++C)for(let S=0;S<h.length;++S)if(C!==S&&((0,D.f)(W,h[C],h[S]),(0,D.n)(W,W),y(h,W)))return e&&(0,D.c)(e,W),!0;return!1}(y,S);if(!P)return void(this.geodesicArea=null);const _=this._tempU,G=this._tempV;(0,ce._F)(S,_,G);for(let T=0;T<this._length;++T){const E=(0,D.e)(y[T],_),z=(0,D.e)(y[T],G),b=(0,D.e)(y[T],S);(0,Pe.a)(C[T],E/b,z/b)}(0,D.g)(S,S,(0,I.Iu)(v).radius),d.toRenderCoords(S,(0,I.rS)(v),this.geodesicAreaCentroidRenderCoords),this._updateGeodesicIntersectingSegments(),this.geodesicArea=P&&0===this.geodesicIntersectingSegments.size?(0,Y.ne)(this._computeGeodesicArea(),"square-meters"):null}_updatePerimeterLengths(){const e=this.positionsProjectedWorldCoords,d=this.perimeterSegmentLengths;let v=0;for(let y=0;y<this._length;++y)v+=d[y]=(0,Pe.j)(e[y],e[(y+1)%this._length]);return v}_updateIntersectingSegments(){const e=this.positionsProjectedWorldCoords,d=this.intersectingSegments;d.clear();for(let v=0;v<this._length;++v)for(let y=v+2;y<this._length;++y)(y+1)%this._length!==v&&(0,Oe.UT)(e[v],e[(v+1)%this._length],e[y],e[(y+1)%this._length])&&(d.add(v),d.add(y))}_computeArea(){const e=this.positionsProjectedWorldCoords,d=this.triangleIndices=new Uint32Array(De(e));let v=0;for(let y=0;y<d.length;y+=3)v+=(0,Qe.wu)(e[d[y]],e[d[y+1]],e[d[y+2]]);return v}_updateGeodesicIntersectingSegments(){const e=this.positionsStereographic,d=this.geodesicIntersectingSegments;d.clear();for(let v=0;v<this._length;++v)for(let y=v+2;y<this._length;++y)(y+1)%this._length!==v&&(0,Oe.UT)(e[v],e[(v+1)%this._length],e[y],e[(y+1)%this._length])&&(d.add(v),d.add(y))}_computeGeodesicArea(){const e=this.positionsGeographic,v=this.geodesicTriangleIndices=new Uint32Array(De(this.positionsStereographic));let y=0;for(let C=0;C<v.length;C+=3)y+=rt(e[v[C]],e[v[C+1]],e[v[C+2]],Ee.Z.WGS84);return y}_selectFittingMode(e,d,v,y){const C=d.map(T=>Math.abs(function tt(h,e){return(0,D.e)(h,e)+h[3]}(e,T))).reduce((T,E)=>Math.max(T,E),0);!function qe(h,e){const d=e.center;(0,D.s)(d,0,0,0);for(let y=0;y<h.length;++y)(0,D.a)(d,d,h[y]);(0,D.g)(d,d,1/h.length);let v=0;for(let y=0;y<h.length;++y)v=Math.max(v,(0,D.d)(d,h[y]));e.radius=Math.sqrt(v)}(d,this._tempSphere);const S=C/(2*this._tempSphere.radius);let G="horizontal";return S<y.maxRelativeErrorCoplanar?G="oblique":S<y.maxRelativeErrorAlmostCoplanar&&(G=Math.abs((0,D.e)(v,e))>Math.cos((0,Te.Vl)(y.verticalAngleThreshold))?"horizontal":"vertical"),G}_updateCursorSegmentLength(e,d){const v=e.lastPoint;!e.isValidPolygon&&(0,M.pC)(v)&&(0,M.pC)(d)?(this.geodesicCursorSegmentLength=(0,Y.yG)(function st(h,e){if(!(0,w.UY)(h,$)||!(0,w.UY)(e,X))return 0;const d={distance:null};return(0,Ue.cA)(d,[$[0],$[1]],[X[0],X[1]]),d.distance}(v,d),"meters"),this.cursorSegmentLength=(0,Y.yG)(this.unitNormalizer.normalizeDistance(function it(h,e,d){return(0,w.KC)(h,$,d)&&(0,w.KC)(e,X,d)?(0,D.i)($,X):0}(v,d,this.unitNormalizer.spatialReference)),"meters")):(this.geodesicCursorSegmentLength=null,this.cursorSegmentLength=null)}_updateMode(e,d){if(d===se.e.Auto){this.actualMeasurementMode="euclidean";let v=0;null!=this.geodesicPathLength&&(v+=this.geodesicPathLength.value),!e.isValidPolygon&&(0,M.pC)(this.geodesicCursorSegmentLength)&&(v+=this.geodesicCursorSegmentLength.value),v>pt&&(this.actualMeasurementMode="geodesic")}else this.actualMeasurementMode=d===se.e.Euclidean?"euclidean":"geodesic";null==this.geodesicPathLength&&(this.actualMeasurementMode="euclidean"),this._mode=d}}const pt=1e5;var mt=L(68);let k=class extends ie.Z{constructor(h){super(h)}initialize(){const{spatialReference:h}=this.view,e=(0,I.rS)(h),d=e===I.GG?I.wY:e,v=!h||(0,w.Up)(h,d)?d:h,y=new mt.D(v);this._measurementDataManager=new gt(this.view,y),this.own([this.analysisViewData.path.on("change",()=>this._update()),(0,U.YP)(()=>this.analysisViewData.cursorPoint,()=>this._update(),U.Z_),(0,U.YP)(()=>this.analysisViewData.mode,()=>this._update(),U.Z_)]),this._update()}_update(h=!1){const{analysisViewData:e,view:d}=this;this._measurementDataManager.update(e.path,e.cursorPoint,d,e.validMeasurement,{maxRelativeErrorCoplanar:.005,maxRelativeErrorAlmostCoplanar:.01,verticalAngleThreshold:80},e.mode,h)&&(e.measurementData=this._measurementDataManager.getData())}};(0,A._)([(0,V.Cb)({constructOnly:!0})],k.prototype,"view",void 0),(0,A._)([(0,V.Cb)({constructOnly:!0})],k.prototype,"analysis",void 0),(0,A._)([(0,V.Cb)({constructOnly:!0})],k.prototype,"analysisViewData",void 0),k=(0,A._)([(0,J.j)("esri.views.3d.analysis.AreaMeasurement.support.AreaMeasurementController")],k);var vt=L(61885),We=L(72392),ft=L(63290),yt=L(49672),we=L(65401),Lt=L(54865),Ct=L(50017),je=L(466),Fe=L(97737);const St=ft.Z.getLogger("esri.views.3d.analysis.AreaMeasurement.support.AreaMeasurement3DPathHelper");let B=class extends vt.Z.EventedAccessor{constructor(h={}){super(h),this._handles=new We.Z,this._version=0,this._internalGeometryChange=!1,this._extent=(0,we.cS)()}destroy(){this._handles=(0,M.SC)(this._handles)}set areaMeasurement(h){this._set("areaMeasurement",h),(0,M.pC)(h)&&(0,M.pC)(this.view)&&this._initialize(h,this.view)}set view(h){this._set("view",h),(0,M.pC)(h)&&(0,M.pC)(this.areaMeasurement)&&this._initialize(this.areaMeasurement,h)}get initialized(){return(0,M.pC)(this.areaMeasurement)&&(0,M.pC)(this.view)}get version(){return this._version}get isValidPolygon(){return this.initialized&&this.editGeometry.components.length>0&&this.editGeometry.components[0].isClosed()}get extent(){if(this.initialized&&this.editGeometry.components.length>0&&this.editGeometry.components[0].vertices.length>0){const h=(0,we.cS)(this._extent);return this.forEachVertex(e=>{(0,we.Ho)(h,e.pos)}),h}return null}get spatialReference(){return this.initialized?this.editGeometry.coordinateHelper.spatialReference:null}_initialize(h,e){this._handles.removeAll(),this._handles.add((0,U.YP)(()=>h.geometry,()=>{this._updateEditGeometryFromModelGeometry(h,e)},U.tX)),this._makeDirty(!0)}_makeDirty(h=!1){this.notifyChange("isValidPolygon"),this.notifyChange("initialized"),this.notifyChange("extent"),h&&this.notifyChange("numVertices")}_updateEditGeometryFromModelGeometry(h,e){if(this._version++,this._internalGeometryChange)return;this._handles.remove("EditGeometry");let d=h.geometry;if((0,M.pC)(d)){const v=(0,w.fM)(d,e.spatialReference);(0,M.Wi)(v)&&(0,Lt.e)(h,d.spatialReference,St),d=v}this._editGeometryOperations=(0,M.pC)(d)?Fe.c.fromGeometry(d,e.state.viewingMode):new Fe.c(new je.XE("polygon",(0,Ct.Y6)(!0,!1,e.spatialReference))),this._makeDirty(!0),this.emit("change"),this._handles.add(this.editGeometry.on("change",v=>{this._makeDirty(null!=v.addedVertices||null!=v.removedVertices),this._internalGeometryChange=!0,h.geometry=this.numVertices>0?this.editGeometry.geometry:null,this._internalGeometryChange=!1}),"EditGeometry")}get editGeometry(){return this._editGeometryOperations.data}get vertices(){const h=[];return this.forEachVertex(e=>{h.push(e)}),h}get numVertices(){return this.initialized&&this.editGeometry.components.length>0?this.editGeometry.components[0].vertices.length:0}get lastPoint(){if(this.initialized&&this.editGeometry.components.length>0){const h=this.editGeometry.components[0].getLastVertex();if((0,M.pC)(h))return this.editGeometry.coordinateHelper.vectorToPoint(h.pos)}return null}getVertex(h){if(!this.initialized||0===this.editGeometry.components.length||0===this.editGeometry.components[0].vertices.length)return null;const e=this.editGeometry.components[0].vertices[0];let d=e;do{if(d.index===h)return d;d=d.rightEdge.rightVertex}while(d!==e&&null!=d);return null}getVertexPositionAsPoint(h){return this.editGeometry.coordinateHelper.vectorToPoint(h.pos)}getVertexPositionAsPointFromIndex(h){return this.editGeometry.coordinateHelper.vectorToPoint(this.getVertex(h).pos)}forEachVertex(h){this.initialized&&this.editGeometry.components.length>0&&this.editGeometry.components[0].iterateVertices(h)}forEachVertexPosition(h){const e=this.editGeometry.coordinateHelper;this.forEachVertex((d,v)=>{e.vectorToPoint(d.pos,Be),h(Be,v)})}clear(){(0,M.pC)(this.areaMeasurement)&&(this.areaMeasurement.geometry=null)}add(h){if(!this.initialized)return null;if(0===this.editGeometry.components.length){const d=(0,M.Wg)(this.view);this.editGeometry.components.push(new je.wA(d.spatialReference,d.state.viewingMode))}const e=this._editGeometryOperations.appendVertex(this.editGeometry.coordinateHelper.pointToVector(h));return this.emit("change"),e}close(){if(!this.initialized||0===this.editGeometry.components.length)return null;const h=this._editGeometryOperations.closeComponent(this.editGeometry.components[0]);return this.emit("change"),h}ensureContains(h,e=""){let d=!1;if(this.editGeometry.components.forEach(v=>{v.iterateVertices(y=>{y===h&&(d=!0)})}),!d)throw new Error(`vertex doesnt exist ${e}`);return d}setVertexPosition(h,e){if(!this.initialized)return null;const d=this._editGeometryOperations.setVertexPosition(h,this.editGeometry.coordinateHelper.pointToVector(e));return this.emit("change"),d}equals(h){if(this.numVertices!==h.numVertices)return!1;let e=!0;return this.forEachVertexPosition((d,v)=>{const y=h.getVertexPositionAsPointFromIndex(v);d.equals(y)||(e=!1)}),!!e}};(0,A._)([(0,V.Cb)({value:null})],B.prototype,"areaMeasurement",null),(0,A._)([(0,V.Cb)({value:null})],B.prototype,"view",null),(0,A._)([(0,V.Cb)()],B.prototype,"isValidPolygon",null),(0,A._)([(0,V.Cb)()],B.prototype,"extent",null),(0,A._)([(0,V.Cb)()],B.prototype,"spatialReference",null),(0,A._)([(0,V.Cb)()],B.prototype,"numVertices",null),B=(0,A._)([(0,J.j)("esri.views.3d.analysis.AreaMeasurement.support.AreaMeasurement3DPathHelper")],B);const Be=new yt.Z;var _t=L(15861),He=(L(52515),L(84600)),Ne=L(28347),Mt=L(43703),ge=L(68063),re=L(87469),ue=L(993),Pt=L(53928),At=L(52107),H=L(40723),pe=L(16396),Ke=L(6945),oe=L(42743),bt=L(60881),me=L(5894),Ze=L(60909),Vt=L(57623),Dt=L(651),wt=L(91056),Rt=L(39114),Re=L(88569),Gt=L(12407),Tt=L(8549),ve=L(67969),fe=L(2078);class ye extends wt.A{initializeProgram(e){const d=ye.shader.get().build(this.configuration);return new Gt.$(e.rctx,d,Rt.i)}_setPipelineState(e){const d=this.configuration,v=e===oe.Am.NONE,y=e===oe.Am.FrontFace;return(0,fe.sm)({blending:d.transparent?v?Et:(0,Re.j7)(e):null,depthTest:{func:(0,Re.Bh)(e)},depthWrite:v?d.writeDepth&&fe.LZ:(0,Re.K5)(e),colorWrite:fe.BK,polygonOffset:v||y?d.polygonOffset&&zt:{factor:-1,units:-25}})}initializePipeline(){return this._setPipelineState(this.configuration.transparencyPassType)}}ye.shader=new Dt.J(Tt.C,()=>L.e(2558).then(L.bind(L,2558)));const zt={factor:0,units:-25},Et=(0,fe.wK)(ve.zi.SRC_ALPHA,ve.zi.ONE,ve.zi.ONE_MINUS_SRC_ALPHA,ve.zi.ONE_MINUS_SRC_ALPHA);var q=L(87601),Ot=L(41528);class Q extends Ot.W{constructor(){super(...arguments),this.transparencyPassType=oe.Am.NONE,this.transparent=!1,this.writeDepth=!0,this.polygonOffset=!1,this.hasMultipassTerrain=!1,this.cullAboveGround=!1}}(0,A._)([(0,q.o)({count:oe.Am.COUNT})],Q.prototype,"transparencyPassType",void 0),(0,A._)([(0,q.o)()],Q.prototype,"transparent",void 0),(0,A._)([(0,q.o)()],Q.prototype,"writeDepth",void 0),(0,A._)([(0,q.o)()],Q.prototype,"polygonOffset",void 0),(0,A._)([(0,q.o)()],Q.prototype,"hasMultipassTerrain",void 0),(0,A._)([(0,q.o)()],Q.prototype,"cullAboveGround",void 0);class Ut extends H.F5{constructor(e){super(e,new It),this.techniqueConfig=new Q}dispose(){}getConfiguration(e,d){return this.techniqueConfig.transparent=this.parameters.transparent,this.techniqueConfig.writeDepth=this.parameters.writeDepth,this.techniqueConfig.polygonOffset=this.parameters.polygonOffset,this.techniqueConfig.transparencyPassType=d?d.transparencyPassType:oe.Am.NONE,this.techniqueConfig.hasMultipassTerrain=!!d&&d.multipassTerrain.enabled,this.techniqueConfig.cullAboveGround=!!d&&d.multipassTerrain.cullAboveGround,this.techniqueConfig}intersect(e,d,v,y,C,S,P){return(0,Vt.Bw)(e,d,y,C,S,void 0,P)}requiresSlot(e){let d=me.r.OPAQUE_MATERIAL;return this.parameters.transparent&&(d=this.parameters.writeDepth?me.r.TRANSPARENT_MATERIAL:me.r.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL),e===d||e===me.r.DRAPED_MATERIAL}createGLMaterial(e){return e.output===Ke.H.Color||e.output===Ke.H.Alpha?new xt(e):null}createBufferWriter(){return new Ze.G_(Ze.W1)}}class xt extends bt.Z{beginSlot(e){return this.ensureTechnique(ye,e)}}class It extends H.Mt{constructor(){super(...arguments),this.size=[1,1],this.color1=[.75,.75,.75,1],this.color2=[.5,.5,.5,1],this.transparent=!1,this.writeDepth=!0,this.polygonOffset=!1}}class Wt extends Pt._{constructor(e){super(e),this._checkerBoardMaterial=null,this._renderOccluded=H.yD.OccludeAndTransparent,this._geometry=null,this._size=[1,1],this._color1=(0,Ae.f)(1,.5,0,.5),this._color2=(0,Ae.f)(1,1,1,.5),this.applyProps(e)}get renderOccluded(){return this._renderOccluded}set renderOccluded(e){e!==this._renderOccluded&&(this._renderOccluded=e,this._updateMaterial())}get geometry(){return this._geometry}set geometry(e){this._geometry=e,this._geometryChanged()}get size(){return this._size}set size(e){this._size=e,this._updateMaterial()}get color1(){return this._color1}set color1(e){(0,ue.g)(e,this._color1)||((0,ue.c)(this._color1,e),this._updateMaterial())}get color2(){return this._color2}set color2(e){(0,ue.g)(e,this._color2)||((0,ue.c)(this._color2,e),this._updateMaterial())}_updateMaterial(){(0,M.pC)(this._checkerBoardMaterial)&&this._checkerBoardMaterial.setParameters({size:this._size,color1:this._color1,color2:this._color2,renderOccluded:this._renderOccluded})}createExternalResources(){this._checkerBoardMaterial=new Ut({size:this._size,color1:this._color1,color2:this._color2,transparent:!0,writeDepth:!1,polygonOffset:!0,renderOccluded:H.yD.OccludeAndTransparent})}destroyExternalResources(){this._checkerBoardMaterial=null}forEachExternalMaterial(e){(0,M.pC)(this._checkerBoardMaterial)&&e(this._checkerBoardMaterial)}createGeometries(e){if((0,M.Wi)(this._geometry)||(0,M.Wi)(this._checkerBoardMaterial))return;const d=jt;(0,Ne.C)(d,this.transform);const v=this._geometry,y=[],C=(0,R.c)();v.position.forEach(_=>{(0,D.b)(C,_,d),y.push(C[0],C[1],C[2])});const S=[];v.uv.forEach(_=>{S.push(_[0],_[1])});const P=new At.Z([[pe.T.POSITION,{size:3,data:y,exclusive:!0}],[pe.T.UV0,{size:2,data:S,exclusive:!0}]],[[pe.T.POSITION,v.triangleIndices],[pe.T.UV0,v.triangleIndices]]);e.addGeometry(P,this._checkerBoardMaterial)}_geometryChanged(){this.recreateGeometry()}}const jt=(0,R.c)();var ae=L(64770),Ft=L(54889),Bt=L(56683),Ht=L(41840);let j=class extends ie.Z{constructor(h){super(h),this._handles=new We.Z,this._params={...Nt},this._path=null,this._intersectedPath=null,this._perimeter=null,this._intersectedPerimeter=null,this._projectionLines=null,this._measurementArea=null,this._areaLabel=null,this._pathLengthLabel=null,this._cursorSegmentLengthLabel=null,this._perimeterLengthLabel=null,this._pathSegments=[],this._perimeterSegments=[],this._cursorSegment=null,this._origin=(0,R.c)(),this._originTransform=(0,Mt.c)(),this._cursorPositionRenderSpace=(0,R.c)(),this.messages=null,this.viewData=Kt,this.areaLabel=null,this.perimeterLengthLabel=null,this.loadingMessages=!0}get visible(){return this.analysisViewData.visible}get testData(){return{labels:{area:this._areaLabel,pathLength:this._pathLengthLabel,cursorSegmentLength:this._cursorSegmentLengthLabel,perimeterLength:this._perimeterLengthLabel}}}initialize(){var h=this;const{analysisViewData:e,_params:d,view:v}=this;this._path=new re.r({view:v,attached:!0,width:d.pathLineWidth,color:d.pathLineColor,polygonOffset:!0,renderOccluded:H.yD.OccludeAndTransparent}),this._intersectedPath=new re.r({view:v,attached:!0,width:d.pathLineWidth,color:d.intersectingLineColor,polygonOffset:!0,renderOccluded:H.yD.OccludeAndTransparent}),this._perimeter=new re.r({view:v,attached:!0,width:d.perimeterLineWidth,color:d.perimeterLineColor,polygonOffset:!0,renderOccluded:H.yD.OccludeAndTransparent}),this._intersectedPerimeter=new re.r({view:v,attached:!0,width:d.perimeterLineWidth,color:d.intersectingLineColor,polygonOffset:!0,renderOccluded:H.yD.OccludeAndTransparent}),this._projectionLines=new re.r({view:v,attached:!0,width:d.projectionLineWidth,color:d.projectionLineColor,stipplePattern:(0,Ft.z5)(d.projectionLineStippleSize),polygonOffset:!0,renderOccluded:H.yD.OccludeAndTransparent}),this._measurementArea=new Wt({view:v,attached:!0,color1:d.areaColor1,color2:d.areaColor2}),this._areaLabel=new ge.Kc({view:v,attached:!0,fontSize:ee.Large}),this._pathLengthLabel=new ge.Kc({view:v,attached:!0,fontSize:ee.Small}),this._cursorSegmentLengthLabel=new ge.Kc({view:v,attached:!0,fontSize:ee.Small}),this._perimeterLengthLabel=new ge.Kc({view:v,attached:!0,fontSize:ee.Small}),this._handles.add([(0,U.YP)(()=>[e.mode,this.visible,e.unit,e.measurementData,e.cursorPoint],()=>this._update(),U.tX),(0,U.YP)(()=>v.state?.camera,()=>this._updateLabels(),U.tX),(0,Bt.qe)((0,_t.Z)(function*(){return h._updateMessageBundle()}))]),this._updateMessageBundle()}destroy(){this._measurementArea=(0,M.SC)(this._measurementArea),this._path=(0,M.SC)(this._path),this._intersectedPath=(0,M.SC)(this._intersectedPath),this._perimeter=(0,M.SC)(this._perimeter),this._intersectedPerimeter=(0,M.SC)(this._intersectedPerimeter),this._areaLabel=(0,M.SC)(this._areaLabel),this._pathLengthLabel=(0,M.SC)(this._pathLengthLabel),this._cursorSegmentLengthLabel=(0,M.SC)(this._cursorSegmentLengthLabel),this._perimeterLengthLabel=(0,M.SC)(this._perimeterLengthLabel),this._projectionLines=(0,M.SC)(this._projectionLines),this._handles=(0,M.SC)(this._handles),this.set("view",null)}_update(){if(this.destroyed||!this.view.ready||!this.view.renderCoordsHelper)return;const{analysisViewData:{measurementData:h},analysisViewData:e}=this;(0,M.Wi)(h)||(this._updateViewData(h,e.path,e.cursorPoint),this._updateOrigin(),this._updatePathSegments(),this._updatePerimeterSegments(),this._updateArea(),this._updateProjectionLines(),this._updateLabels())}_updateViewData(h,e,d){const v=e.isValidPolygon,y="geodesic"===h.actualMeasurementMode,C=y?h.geodesicArea:h.area;let S=1;if(C){const _=this._toPreferredAreaUnit(C,this.analysisViewData.unit);S=(0,Te.sk)(Math.sqrt(_.value)/Math.sqrt(300)),S*=Math.sqrt((0,ne.En)(1,_.unit,"square-meters")),S/=h.unitNormalizer.normalizeDistance(1)}this._set("viewData",{validMeasurement:v,path:e,pathVersion:e.version,cursorPoint:d,measurementData:h,mode:h.actualMeasurementMode,positionsGeographic:h.positionsGeographic,positionsRenderCoords:h.positionsRenderCoords,positionsProjected:h.positionsProjectedWorldCoords,positionsFittedRenderCoords:h.positionsFittedRenderCoords,intersectingSegments:y?h.geodesicIntersectingSegments:h.intersectingSegments,triangleIndices:y?h.geodesicTriangleIndices:h.triangleIndices,fittingMode:h.fittingMode,areaCentroid:y?h.geodesicAreaCentroidRenderCoords:h.areaCentroidRenderCoords,pathLengthLabelSegmentIndex:v?0:e.numVertices-2,perimeterLengthLabelSegmentIndex:0,checkerSize:S})}_updateOrigin(){(0,Ve.H)(this.viewData.positionsRenderCoords,this._origin),(0,Ne.f)(this._originTransform,this._origin),this._measurementArea.transform=this._originTransform,this._projectionLines.transform=this._originTransform}_createSegments(h){const e=this.viewData,d=e.path,v=this.view.renderCoordsHelper.spatialReference,y=e.mode,C=[],S=[],P=[],_=e.validMeasurement?d.numVertices:d.numVertices-1;for(let G=0;G<_;++G){const T=e[h][G],E=e[h][(G+1)%d.numVertices];let z=null;switch(y){case"euclidean":z=new ae.y$(T,E);break;case"geodesic":z=new ae.u4(T,E,v)}e.intersectingSegments.has(G)?P.push(z):S.push(z),C.push(z)}return{all:C,nonIntersecting:S,intersecting:P}}_updatePathSegments(){const{view:{renderCoordsHelper:h},viewData:e,visible:d}=this,v=this._createSegments("positionsRenderCoords"),{cursorPoint:y,mode:C,path:S}=e,P=!S.isValidPolygon,_=h.spatialReference;if(this._cursorSegment=null,S.numVertices>0&&P&&(0,M.pC)(y)&&h.toRenderCoords(y,this._cursorPositionRenderSpace)){const G=e.positionsRenderCoords[S.numVertices-1],T=this._cursorPositionRenderSpace;let E=null;switch(C){case"euclidean":E=new ae.y$(G,T);break;case"geodesic":E=new ae.u4(G,T,_)}v.nonIntersecting.push(E),this._cursorSegment=E}this._path.setGeometryFromSegments(v.nonIntersecting,this._origin),this._path.visible=d,this._intersectedPath.setGeometryFromSegments(v.intersecting,this._origin),this._intersectedPath.visible=d,this._pathSegments=v.all}_updatePerimeterSegments(){const h=this.visible&&"euclidean"===this.viewData.mode,e=this._createSegments("positionsFittedRenderCoords");this._perimeter.setGeometryFromSegments(e.nonIntersecting,this._origin),this._perimeter.visible=h,this._intersectedPerimeter.setGeometryFromSegments(e.intersecting,this._origin),this._intersectedPerimeter.visible=h,this._perimeterSegments=e.all}_updateArea(){const h=this.viewData;switch(h.mode){case"euclidean":this._updateAreaEuclidean(h);break;case"geodesic":this._updateAreaGeodesic()}}_updateAreaEuclidean(h){const e=this.visible;h.validMeasurement&&0===h.intersectingSegments.size&&h.triangleIndices?(this._measurementArea.geometry={uv:h.positionsProjected,position:h.positionsFittedRenderCoords,triangleIndices:h.triangleIndices},this._measurementArea.size=[h.checkerSize,h.checkerSize],this._measurementArea.visible=e):this._measurementArea.visible=!1}_updateAreaGeodesic(){this._measurementArea.visible=!1}_updateProjectionLines(){const h=this.viewData,e=this.visible,d=h.path;if(d.numVertices>0&&h.validMeasurement&&"euclidean"===h.mode){const y=[];for(let C=0;C<d.numVertices;++C){const S=(0,R.c)();(0,D.b)(S,h.positionsRenderCoords[C],this._origin);const P=(0,R.c)();(0,D.b)(P,h.positionsFittedRenderCoords[C],this._origin),y.push([S,P])}this._projectionLines.geometry=y,this._projectionLines.visible=e}else this._projectionLines.geometry=null,this._projectionLines.visible=!1}_updateLabels(){if(this.destroyed)return;const{viewData:h}=this,{measurementData:e,mode:d,path:v}=h;if(!v)return;const y=!v.isValidPolygon,C=this.visible,S=this._formatAreaLabel(this.messages,"geodesic"===d?e.geodesicArea:e.area,this.analysisViewData.unit);(0,M.pC)(S)?(this._areaLabel.geometry={type:"point",point:h.areaCentroid},this._areaLabel.text=S,this._areaLabel.visible=h.validMeasurement&&0===h.intersectingSegments.size&&C):this._areaLabel.visible=!1,this._set("areaLabel",(0,M.Wg)(S));const P=this._formatLengthLabel(this.messages,"geodesic"===d?e.geodesicPathLength:e.pathLength,this.analysisViewData.unit);if((0,M.pC)(P)&&h.pathLengthLabelSegmentIndex>=0&&h.pathLengthLabelSegmentIndex<this._pathSegments.length){const z=this._pathSegments[h.pathLengthLabelSegmentIndex],b=(0,M.pC)(this._cursorSegment)?this._cursorSegment:Zt;this._pathLengthLabel.distance=this._params.labelDistance,this._pathLengthLabel.geometry={type:"corner",left:z,right:b},this._pathLengthLabel.text=P,this._pathLengthLabel.visible=y&&v.numVertices>0&&C}else this._pathLengthLabel.visible=!1;const _="geodesic"===d?h.measurementData.geodesicCursorSegmentLength:h.measurementData.cursorSegmentLength;if((0,M.pC)(_)){const z=this._formatLengthLabel(this.messages,_,this.analysisViewData.unit);this._cursorSegmentLengthLabel.distance=this._params.labelDistance,this._cursorSegmentLengthLabel.geometry=(0,M.pC)(this._cursorSegment)?{type:"segment",segment:this._cursorSegment,sampleLocation:"end"}:null,this._cursorSegmentLengthLabel.anchor="bottom",this._cursorSegmentLengthLabel.text=(0,M.Wg)(z),this._cursorSegmentLengthLabel.visible=y&&0!==_.value&&C}else this._cursorSegmentLengthLabel.visible=!1;this._cursorSegmentLengthLabel.overlaps(this._pathLengthLabel)&&(this._cursorSegmentLengthLabel.visible=!1),this._pathLengthLabel.overlaps(this._areaLabel)&&(this._pathLengthLabel.visible=!1);const G="geodesic"===h.mode,E=this._formatLengthLabel(this.messages,G?e.geodesicPathLength:e.perimeterLength,this.analysisViewData.unit);if(this._set("perimeterLengthLabel",(0,M.Wg)(E)),h.validMeasurement&&0===h.intersectingSegments.size){this._perimeterLengthLabel.distance=this._params.labelDistance,this._perimeterLengthLabel.anchor="top",this._perimeterLengthLabel.text=(0,M.Wg)(E),this._perimeterLengthLabel.visible=!0;let z=!0;for(let b=0;b<h.path.numVertices;++b){const N=(h.perimeterLengthLabelSegmentIndex+b)%h.path.numVertices;if(z=!0,this._perimeterLengthLabel.geometry={type:"segment",segment:G?this._pathSegments[N]:this._perimeterSegments[N],sampleLocation:"center"},!this._perimeterLengthLabel.overlaps(this._areaLabel))break;z=!1}this._perimeterLengthLabel.visible=z&&C}else this._perimeterLengthLabel.visible=!1}_toPreferredAreaUnit(h,e){return(0,Y.nn)(h,this._preferredAreaUnit(h,e))}_preferredAreaUnit(h,e){switch(e){case"metric":return(0,ne.tQ)(h.value,h.unit);case"imperial":return(0,ne.Yl)(h.value,h.unit);default:return e}}_preferredLengthUnit(h,e){const d=this._deriveLengthUnitFromAreaUnit(e);switch(d){case"metric":return(0,ne.KU)(h.value,h.unit);case"imperial":return(0,ne.FN)(h.value,h.unit);default:return d}}_deriveLengthUnitFromAreaUnit(h){switch(h){case"metric":case"ares":case"hectares":return"metric";case"imperial":case"acres":return"imperial";case"square-inches":return"inches";case"square-feet":return"feet";case"square-yards":return"yards";case"square-miles":return"miles";case"square-us-feet":return"us-feet";case"square-millimeters":return"millimeters";case"square-centimeters":return"centimeters";case"square-decimeters":return"decimeters";case"square-meters":return"meters";case"square-kilometers":return"kilometers"}throw new Error("unhandled area unit")}_formatAreaLabel(h,e,d){return h&&e&&(0,He.VG)(h,e,this._preferredAreaUnit(e,d))}_formatLengthLabel(h,e,d){return h&&e&&(0,He.VG)(h,e,this._preferredLengthUnit(e,d))}_updateMessageBundle(){this.loadingMessages=!0,(0,Ht.ME)("esri/core/t9n/Units").then(h=>{this.messages=h,this.view&&this._update()}).finally(()=>{this.loadingMessages=!1})}};var ee,h;(0,A._)([(0,V.Cb)()],j.prototype,"view",void 0),(0,A._)([(0,V.Cb)()],j.prototype,"messages",void 0),(0,A._)([(0,V.Cb)()],j.prototype,"analysis",void 0),(0,A._)([(0,V.Cb)()],j.prototype,"viewData",void 0),(0,A._)([(0,V.Cb)()],j.prototype,"analysisViewData",void 0),(0,A._)([(0,V.Cb)({readOnly:!0})],j.prototype,"areaLabel",void 0),(0,A._)([(0,V.Cb)({readOnly:!0})],j.prototype,"perimeterLengthLabel",void 0),(0,A._)([(0,V.Cb)()],j.prototype,"loadingMessages",void 0),(0,A._)([(0,V.Cb)()],j.prototype,"visible",null),j=(0,A._)([(0,J.j)("esri.views.3d.analysis.AreaMeasurement.support.AreaMeasurementVisualization")],j),(h=ee||(ee={}))[h.Small=12]="Small",h[h.Large=16]="Large";const Nt={laserLineGlowColor:[1,.5,0],laserLineGlowWidth:8,laserLineGlowFalloff:8,laserLineInnerColor:[1,1,1],laserLineInnerWidth:1,laserLineGlobalAlpha:.75,laserLineEnabled:!0,handleColor:[1,.5,0],handleOpacity:.5,handleRadius:5,handleRadiusHovered:10,handleRadiusMouse:10,handleRadiusTouch:25,pathLineColor:[1,.5,0,1],pathLineWidth:3,intersectingLineColor:[1,.2,0,1],perimeterLineColor:[1,.5,0,1],perimeterLineWidth:2,projectionLineColor:[1,.5,0,1],projectionLineWidth:2,projectionLineStippleSize:5,areaColor1:[1,.5,0,.5],areaColor2:[1,1,1,.5],fillColor:[1,.5,0,.5],lineSubdivisions:64,labelDistance:25},Kt={validMeasurement:!1,path:null,pathVersion:-1,cursorPoint:null,measurementData:null,mode:null,positionsGeographic:null,positionsRenderCoords:null,positionsProjected:null,positionsFittedRenderCoords:null,intersectingSegments:null,triangleIndices:null,fittingMode:null,areaCentroid:null,pathLengthLabelSegmentIndex:null,perimeterLengthLabelSegmentIndex:null,checkerSize:null},Zt=new ae.y$((0,R.c)(),(0,R.c)());let O=class extends((0,de.p)(ie.Z)){constructor(h){super(h),this.type="area-measurement-view-3d",this.analysis=null,this.measurementData=null,this.lastDraggedVertex=null,this.cursorPoint=null,this.mode=se.e.Auto}initialize(){const{analysis:h,view:e}=this;this.path=new B({view:e,areaMeasurement:h}),this.analysisVisualization=new j({view:e,analysis:h,analysisViewData:this}),this.analysisController=new k({view:e,analysis:h,analysisViewData:this})}destroy(){this.analysisController=(0,M.SC)(this.analysisController),this.analysisVisualization=(0,M.SC)(this.analysisVisualization),this.path.destroy()}get updating(){return!!this.analysisVisualization?.loadingMessages}get result(){const{measurementData:h}=this;return(0,M.Wi)(h)?{area:null,mode:null,perimeter:null}:"euclidean"===h.actualMeasurementMode?{area:h.area,perimeter:h.perimeterLength,mode:"euclidean"}:{area:h.geodesicArea,perimeter:h.pathLength,mode:"geodesic"}}get viewData(){return this.analysisVisualization.viewData}get validMeasurement(){return this.path.isValidPolygon}get unit(){return(0,M.Pt)(this.analysis.unit,this._defaultUnit)}get testData(){return{visualization:this.analysisVisualization,controller:this.analysisController}}};(0,A._)([(0,V.Cb)({readOnly:!0})],O.prototype,"type",void 0),(0,A._)([(0,V.Cb)({constructOnly:!0,nonNullable:!0})],O.prototype,"analysis",void 0),(0,A._)([(0,V.Cb)()],O.prototype,"updating",null),(0,A._)([(0,V.Cb)()],O.prototype,"analysisVisualization",void 0),(0,A._)([(0,V.Cb)()],O.prototype,"analysisController",void 0),(0,A._)([(0,V.Cb)()],O.prototype,"result",null),(0,A._)([(0,V.Cb)()],O.prototype,"measurementData",void 0),(0,A._)([(0,V.Cb)()],O.prototype,"viewData",null),(0,A._)([(0,V.Cb)()],O.prototype,"validMeasurement",null),(0,A._)([(0,V.Cb)()],O.prototype,"path",void 0),(0,A._)([(0,V.Cb)()],O.prototype,"lastDraggedVertex",void 0),(0,A._)([(0,V.Cb)()],O.prototype,"cursorPoint",void 0),(0,A._)([(0,V.Cb)()],O.prototype,"mode",void 0),(0,A._)([(0,V.Cb)()],O.prototype,"unit",null),(0,A._)([(0,V.Cb)(le.Y)],O.prototype,"_defaultUnit",void 0),O=(0,A._)([(0,J.j)("esri.views.3d.analysis.AreaMeasurementAnalysisView3D")],O);const Yt=O}}]);