/*
Copyright 2022 Comcast Cable Communications Management, LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
"use strict";(self.webpackChunka_porrtal_io_app=self.webpackChunka_porrtal_io_app||[]).push([[6455],{16943:(St,X,f)=>{f.d(X,{Ue:()=>Yn});var j=f(26584),l=f(17626),F=f(62208),p=f(77712),C=(f(85931),f(90912),f(76898)),N=(f(63290),f(8314),f(86810));let H=class extends N.wq{constructor(){super(...arguments),this.raster=void 0}};(0,l._)([(0,p.Cb)({json:{write:!0}})],H.prototype,"raster",void 0),H=(0,l._)([(0,C.j)("esri.layers.support.rasterFunctions.AspectFunctionArguments")],H);const O=H;var J;let Y=J=class extends O{clone(){return new J({raster:this.raster})}};Y=J=(0,l._)([(0,C.j)("esri.layers.support.rasterFunctions.AspectFunctionArguments")],Y);const At=Y;var k=f(66656);let Z=class extends N.wq{constructor(){super(...arguments),this.functionArguments=null,this.readingBufferSize=0}bind(t,n=!1){const a=this._getRasterValues();for(let i=0;i<a.length;i++){const o=a[i];if(o&&"object"==typeof o&&"bind"in o&&(!o.rasterInfo||n)){const r=o.bind(t,n);if(!r.success)return r}}return!this.rasterInfo||n?(this.sourceRasterInfos=this._getSourceRasterInfos(t),this._bindSourceRasters()):{success:!0}}process(t){const n=this._getRasterValues().map(a=>this._readRasterValue(a,t));return this._processPixels({...t,pixelBlocks:n})}getPrimaryRasters(){const t=[],n=[];return this._getPrimaryRasters(this,t,n),{rasters:t,rasterIds:n}}_getOutputPixelType(t){return"unknown"===this.outputPixelType?t:this.outputPixelType??t}_getRasterValues(){const{rasterArgumentNames:t}=this;return"rasters"===t[0]&&Array.isArray(this.functionArguments.rasters)?this.functionArguments.rasters:t.map(n=>this.functionArguments[n])}_getSourceRasterInfos(t){const n=this._getRasterValues(),{rasterInfos:a,rasterIds:i}=t;return n.map(o=>o&&"object"==typeof o&&"bind"in o&&o.rasterInfo?o.rasterInfo:"string"==typeof o&&i.includes(o)?a[i.indexOf(o)]:a[0])}_getPrimaryRasterId(t){return t?.url}_getPrimaryRasters(t,n=[],a=[]){for(let i=0;i<t.sourceRasters.length;i++){const o=t.sourceRasters[i];if("number"!=typeof o)if("bind"in o)this._getPrimaryRasters(o,n,a);else{const r=o,s=this._getPrimaryRasterId(r);if(null==s)continue;a.includes(s)||(this.mainPrimaryRasterId===s?(n.unshift(r),a.unshift(s)):(n.push(r),a.push(s)))}}}_readRasterValue(t,n){const{primaryPixelBlocks:a}=n;if((0,F.Wi)(t)||"$$"===t){const i=a[0];return(0,F.Wi)(i)?null:i.clone()}if("string"==typeof t){const i=n.primaryRasterIds.indexOf(t);return-1===i?null:a[i]}if("number"==typeof t){const i=a[0];if((0,F.Wi)(i))return null;const o=new Float32Array(i.width*i.height);o.fill(t);const r=i.clone();return r.pixels=r.pixels.map(()=>o),r}return t.process(n)}};(0,l._)([(0,p.Cb)({json:{write:!0}})],Z.prototype,"functionName",void 0),(0,l._)([(0,p.Cb)({json:{write:!0}})],Z.prototype,"functionArguments",void 0),(0,l._)([(0,p.Cb)()],Z.prototype,"rasterArgumentNames",void 0),(0,l._)([(0,p.Cb)({json:{write:!0}}),(0,k.p)(t=>t?.toLowerCase())],Z.prototype,"outputPixelType",void 0),(0,l._)([(0,p.Cb)({json:{write:!0}})],Z.prototype,"mainPrimaryRasterId",void 0),(0,l._)([(0,p.Cb)()],Z.prototype,"sourceRasters",void 0),(0,l._)([(0,p.Cb)({json:{write:!0}})],Z.prototype,"sourceRasterInfos",void 0),(0,l._)([(0,p.Cb)({json:{write:!0}})],Z.prototype,"rasterInfo",void 0),(0,l._)([(0,p.Cb)({json:{write:!0}})],Z.prototype,"readingBufferSize",void 0),Z=(0,l._)([(0,C.j)("esri.layers.support.rasterFunctions.BaseRasterFunction")],Z);const m=Z;var w=f(67845);let S=class extends m{constructor(){super(...arguments),this.functionName="Aspect",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isGCS=!1}_bindSourceRasters(){const t=this.sourceRasterInfos[0];this.isGCS=t.spatialReference.isGeographic,this.outputPixelType=this._getOutputPixelType("f32");const n=t.clone();return n.pixelType=this.outputPixelType,n.statistics=null,n.histograms=null,this.rasterInfo=n,{success:!0}}_processPixels(t){const n=t.pixelBlocks?.[0];if((0,F.Wi)(n))return null;const{extent:a}=t;return(0,w.M_)(n,{resolution:a?{x:a.width/n.width,y:a.height/n.height}:{x:1,y:1}})}};(0,l._)([(0,p.Cb)({json:{write:!0,name:"rasterFunction"}})],S.prototype,"functionName",void 0),(0,l._)([(0,p.Cb)({type:At,json:{write:!0,name:"rasterFunctionArguments"}})],S.prototype,"functionArguments",void 0),(0,l._)([(0,p.Cb)()],S.prototype,"rasterArgumentNames",void 0),(0,l._)([(0,p.Cb)({json:{write:!0}})],S.prototype,"isGCS",void 0),S=(0,l._)([(0,C.j)("esri.layers.support.rasterFunctions.AspectFunction")],S);const A=S;var _=f(58817),v=f(55342),R=f(2076),y=f(25688);const M=new Set(["+","-","*","/","(",")"]);function et(t,n,a,i){if("number"==typeof a&&"number"==typeof i)return a+i;let o;if("number"==typeof a){o=i.length;const s=a;(a=new Float32Array(o)).fill(s)}else if(o=a.length,i.constructor===Number){const s=i;(i=new Float32Array(o)).fill(s)}const r=new Float32Array(o);switch(n){case"+":for(let s=0;s<o;s++)(null==t||t[s])&&(r[s]=a[s]+i[s]);break;case"-":for(let s=0;s<o;s++)(null==t||t[s])&&(r[s]=a[s]-i[s]);break;case"*":for(let s=0;s<o;s++)(null==t||t[s])&&(r[s]=a[s]*i[s]);break;case"/":for(let s=0;s<o;s++)(null==t||t[s])&&i[s]&&(r[s]=a[s]/i[s]);break;case"(":case")":throw"encountered error with custom band index equation"}return r}function D(t,n){t.splice(n,1);let a=0,i=0;do{a=0,i=0;for(let o=0;o<t.length;o++)if("("===t[o])a=o;else if(")"===t[o]){i=o;break}i===a+1&&t.splice(a,2)}while(i===a+1);return t}function V(t){if(1===t.length)return{opIndex:0,numIndex:0};let n=0,a=0;for(let s=0;s<t.length;s++)if("("===t[s])n=s;else if(")"===t[s]){a=s;break}const i=0===a?t:t.slice(n+1,a);let o=-1;for(let s=0;s<i.length;s++)if("*"===i[s]||"/"===i[s]){o=s;break}if(o>-1)a>0&&(o+=n+1);else{for(let s=0;s<i.length;s++)if("+"===i[s]||"-"===i[s]){o=s;break}a>0&&(o+=n+1)}let r=0;for(let s=0;s<o;s++)"("===t[s]&&r++;return{opIndex:o,numIndex:o-r}}var W=f(79751);const le=new R.X({0:"custom",1:"ndvi",2:"savi",3:"tsavi",4:"msavi",5:"gemi",6:"pvi",7:"gvitm",8:"sultan",9:"vari",10:"gndvi",11:"sr",12:"ndvi-re",13:"sr-re",14:"mtvi2",15:"rtvi-core",16:"ci-re",17:"ci-g",18:"ndwi",19:"evi",20:"iron-oxide",21:"ferrous-minerals",22:"clay-minerals",23:"wndwi",24:"bai",25:"nbr",26:"ndbi",27:"ndmi",28:"ndsi",29:"mndwi"},{useNumericKeys:!0});function ce(t,n){if(!(0,W.nk)(t))return t;const{equation:a,method:i}=n,o=n.bandIndexes.map(h=>h-1),{pixels:r,mask:s}=t;let e;switch(i){case"gndvi":case"nbr":case"ndbi":case"ndvi":case"ndvi-re":case"ndsi":case"ndmi":case"mndwi":e=Vt(s,r[o[0]],r[o[1]]);break;case"ndwi":e=Vt(s,r[o[1]],r[o[0]]);break;case"sr":case"sr-re":case"iron-oxide":case"ferrous-minerals":case"clay-minerals":e=function me(t,n,a){const i=a.length,o=new Float32Array(i);for(let r=0;r<i;r++)if(null==t||t[r]){const s=n[r],e=a[r];e&&(o[r]=s/e)}return[o]}(s,r[o[0]],r[o[1]]);break;case"ci-g":case"ci-re":e=function he(t,n,a){const i=n.length,o=new Float32Array(i);for(let r=0;r<i;r++)if(null==t||t[r]){const s=n[r],e=a[r];e&&(o[r]=s/e-1)}return[o]}(s,r[o[0]],r[o[1]]);break;case"savi":e=function fe(t,n,a,i){const o=a.length,r=new Float32Array(o);for(let s=0;s<o;s++)if(null==t||t[s]){const e=a[s],u=n[s],c=u+e+i;c&&(r[s]=(u-e)/c*(1+i))}return[r]}(s,r[o[0]],r[o[1]],o[2]+1);break;case"tsavi":e=function de(t,n,a,i,o,r){const s=a.length,e=new Float32Array(s),u=-o*i+r*(1+i*i);for(let c=0;c<s;c++)if(null==t||t[c]){const h=a[c],d=n[c],g=o*d+h+u;g&&(e[c]=i*(d-i*h-o)/g)}return[e]}(s,r[o[0]],r[o[1]],o[2]+1,o[3]+1,o[4]+1);break;case"msavi":e=function ge(t,n,a){const i=a.length,o=new Float32Array(i);for(let r=0;r<i;r++)if(null==t||t[r]){const e=n[r];o[r]=.5*(2*(e+1)-Math.sqrt((2*e+1)**2-8*(e-a[r])))}return[o]}(s,r[o[0]],r[o[1]]);break;case"gemi":e=function ye(t,n,a){const i=a.length,o=new Float32Array(i);for(let r=0;r<i;r++)if(null==t||t[r]){const s=a[r],e=n[r];if(1!==s){const u=(2*(e*e-s*s)+1.5*e+.5*s)/(e+s+.5);o[r]=u*(1-.25*u)-(s-.125)/(1-s)}}return[o]}(s,r[o[0]],r[o[1]]);break;case"pvi":e=function _e(t,n,a,i,o){const r=a.length,s=new Float32Array(r),e=Math.sqrt(1+i*i);for(let u=0;u<r;u++)(null==t||t[u])&&(s[u]=(n[u]-i*a[u]-o)/e);return[s]}(s,r[o[0]],r[o[1]],o[2]+1,o[3]+1);break;case"gvitm":e=function xe(t,n){const[a,i,o,r,s,e]=n,u=a.length,c=new Float32Array(u);for(let h=0;h<u;h++)(null==t||t[h])&&(c[h]=-.2848*a[h]-.2435*i[h]-.5436*o[h]+.7243*r[h]+.084*s[h]-1.18*e[h]);return[c]}(s,[r[o[0]],r[o[1]],r[o[2]],r[o[3]],r[o[4]],r[o[5]]]);break;case"sultan":e=function Ae(t,n){const[a,,i,o,r,s]=n,e=a.length,u=new Float32Array(e),c=new Float32Array(e),h=new Float32Array(e);for(let d=0;d<e;d++)(null==t||t[d])&&(u[d]=s[d]?r[d]/s[d]*100:0,c[d]=a[d]?r[d]/a[d]*100:0,h[d]=o[d]?i[d]/o[d]*(r[d]/o[d])*100:0);return[u,c,h]}(s,[r[o[0]],r[o[1]],r[o[2]],r[o[3]],r[o[4]],r[o[5]]]);break;case"vari":e=function ve(t,n){const[a,i,o]=n,r=a.length,s=new Float32Array(r);for(let e=0;e<r;e++)if(null==t||t[e])for(e=0;e<r;e++){const u=a[e],c=i[e],h=c+u-o[e];h&&(s[e]=(c-u)/h)}return[s]}(s,[r[o[0]],r[o[1]],r[o[2]]]);break;case"mtvi2":e=function Ce(t,n){const[a,i,o]=n,r=a.length,s=new Float32Array(r);for(let e=0;e<r;e++)if(null==t||t[e])for(e=0;e<r;e++){const u=a[e],c=i[e],h=o[e],d=Math.sqrt((2*u+1)**2-6*u-5*Math.sqrt(c)-.5);s[e]=1.5*(1.2*(u-h)-2.5*(c-h))*d}return[s]}(s,[r[o[0]],r[o[1]],r[o[2]]]);break;case"rtvi-core":e=function Fe(t,n){const[a,i,o]=n,r=a.length,s=new Float32Array(r);for(let e=0;e<r;e++)if(null==t||t[e])for(e=0;e<r;e++){const u=a[e];s[e]=100*(u-i[e])-10*(u-o[e])}return[s]}(s,[r[o[0]],r[o[1]],r[o[2]]]);break;case"evi":e=function be(t,n){const[a,i,o]=n,r=a.length,s=new Float32Array(r);for(let e=0;e<r;e++)if(null==t||t[e])for(e=0;e<r;e++){const u=a[e],c=i[e],h=u+6*c-7.5*o[e]+1;h&&(s[e]=2.5*(u-c)/h)}return[s]}(s,[r[o[0]],r[o[1]],r[o[2]]]);break;case"wndwi":e=function we(t,n,a=.5){const[i,o,r]=n,s=o.length,e=new Float32Array(s);for(let u=0;u<s;u++)if(null==t||t[u])for(u=0;u<s;u++){const c=i[u],h=o[u],d=r[u],g=c+a*h+(1-a)*d;g&&(e[u]=(c-a*h-(1-a)*d)/g)}return[e]}(s,[r[o[0]],r[o[1]],r[o[2]]],o[3]??.5);break;case"bai":e=function Se(t,n,a){const i=a.length,o=new Float32Array(i);for(let r=0;r<i;r++)if(null==t||t[r])for(r=0;r<i;r++){const s=(.1-n[r])**2+(.06-a[r])**2;s&&(o[r]=1/s)}return[o]}(s,r[o[0]],r[o[1]]);break;case"custom":e=function Tt(t,n,a){let i,{ops:o,nums:r}=function tt(t,n){(t=t.replace(/ /g,"")).startsWith("-")&&(t="0"+t),t.startsWith("+")&&(t=t.slice(1,t.length));const a=t.split(""),i=[],o=[];let r="";for(let s=0;s<a.length;s++){const e=a[s];if(M.has(e))""!==r&&o.push(parseFloat(r)),i.push(e),r="";else{if("b"===e.toLowerCase()){s++,r=e.concat(a[s]),o.push(n[parseInt(r[1],10)-1]),r="";continue}r=r.concat(e),s===a.length-1&&o.push(parseFloat(r))}}return{ops:i,nums:o}}(a,n);if(0===o.length){const s=1===r.length?r[0]:n[0];if(s instanceof Float32Array)return[s];const e=new Float32Array(n[0].length);return"number"==typeof s?e.fill(s):e.set(s),[e]}for(;o.length>0;){const{numIndex:s,opIndex:e}=V(o);if(i=et(t,o[e],r[s],r[s+1]),1===o.length)break;o=D(o,e),r.splice(s,2,i)}return[i]}(s,r,a);break;default:return t}const u=(0,F.pC)(s)?new Uint8Array(s.length):null;(0,F.pC)(s)&&(0,F.pC)(u)&&u.set(s);const c=new y.Z({width:t.width,height:t.height,pixelType:"f32",pixels:e,mask:u});return c.updateStatistics(),c}function Vt(t,n,a){const i=a.length,o=new Float32Array(i);for(let r=0;r<i;r++)if(null==t||t[r]){const s=n[r],e=a[r],u=s+e;u&&(o[r]=(s-e)/u)}return[o]}var Bt;let vt=Bt=class extends O{constructor(){super(...arguments),this.method="custom"}clone(){return new Bt({method:this.method,bandIndexes:this.bandIndexes,raster:(0,_.d9)(this.raster)})}};(0,l._)([(0,p.Cb)({json:{type:String,write:!0}})],vt.prototype,"bandIndexes",void 0),(0,l._)([(0,v.J)(le)],vt.prototype,"method",void 0),vt=Bt=(0,l._)([(0,C.j)("esri.layers.support.rasterFunctions.BandArithmeticFunctionArguments")],vt);const Te=vt;let pt=class extends m{constructor(){super(...arguments),this.functionName="BandArithmetic",this.functionArguments=null,this.rasterArgumentNames=["raster"]}_bindSourceRasters(){this.outputPixelType=this._getOutputPixelType("f32");const t=this.sourceRasterInfos[0],n=t.clone();return n.pixelType=this.outputPixelType,n.statistics=null,n.histograms=null,n.bandCount="sultan"===this.functionArguments.method?t.bandCount:1,this.rasterInfo=n,{success:!0}}_processPixels(t){const n=t.pixelBlocks?.[0];if((0,F.Wi)(n))return n;const{method:a,bandIndexes:i}=this.functionArguments;return ce(n,{method:a,bandIndexes:i.split(" ").map(r=>parseFloat(r)),equation:i})}};(0,l._)([(0,p.Cb)({json:{write:!0,name:"rasterFunction"}})],pt.prototype,"functionName",void 0),(0,l._)([(0,p.Cb)({type:Te,json:{write:!0,name:"rasterFunctionArguments"}})],pt.prototype,"functionArguments",void 0),(0,l._)([(0,p.Cb)()],pt.prototype,"rasterArgumentNames",void 0),pt=(0,l._)([(0,C.j)("esri.layers.support.rasterFunctions.BandArithmeticFunction")],pt);const Ne=pt;var jt,Pe=f(68653),Gt=f(79023);let $=jt=class extends O{readColorRamp(t){return(0,Gt.i)(t)}clone(){return new jt({colormap:(0,_.d9)(this.colormap),colormapName:this.colormapName,colorRamp:this.colorRamp?.clone(),colorRampName:this.colorRampName})}};(0,l._)([(0,p.Cb)({type:[[Number]],json:{write:!0}})],$.prototype,"colormap",void 0),(0,l._)([(0,p.Cb)({type:String,json:{write:!0}})],$.prototype,"colormapName",void 0),(0,l._)([(0,p.Cb)({types:Gt.V,json:{write:!0}})],$.prototype,"colorRamp",void 0),(0,l._)([(0,Pe.r)("colorRamp")],$.prototype,"readColorRamp",null),(0,l._)([(0,p.Cb)({type:String,json:{write:!0}})],$.prototype,"colorRampName",void 0),$=jt=(0,l._)([(0,C.j)("esri.layers.support.rasterFunctions.ColormapFunctionArguments")],$);const Be=$;var je=f(70208);let nt=class extends m{constructor(){super(...arguments),this.functionName="Colormap",this.functionArguments=null,this.rasterArgumentNames=["raster"]}_bindSourceRasters(){const t=this.sourceRasterInfos[0];if(t.bandCount>1)return{success:!1,error:"colormap-function: source data must be single band"};let{colormap:n,colorRamp:a}=this.functionArguments;if(n?.length||a&&(n=(0,je.XL)(a,256,!0)),!n?.length)return{success:!1,error:"colormap-function: missing colormap argument"};this.outputPixelType=this._getOutputPixelType("u8");const i=t.clone();return i.pixelType=this.outputPixelType,i.colormap=n,this.rasterInfo=i,{success:!0}}_processPixels(t){return t.pixelBlocks?.[0]}};(0,l._)([(0,p.Cb)({json:{write:!0,name:"rasterFunction"}})],nt.prototype,"functionName",void 0),(0,l._)([(0,p.Cb)({type:Be,json:{write:!0,name:"rasterFunctionArguments"}})],nt.prototype,"functionArguments",void 0),(0,l._)([(0,p.Cb)()],nt.prototype,"rasterArgumentNames",void 0),(0,l._)([(0,p.Cb)({json:{write:!0}})],nt.prototype,"indexedColormap",void 0),nt=(0,l._)([(0,C.j)("esri.layers.support.rasterFunctions.ColormapFunction")],nt);const Ie=nt;var Mt,It=f(99433);let Ct=Mt=class extends O{writeRasters(t,n){n.rasters=t.map(a=>"number"==typeof a||"string"==typeof a?a:a.toJSON())}clone(){return new Mt({rasters:(0,_.d9)(this.rasters)})}};(0,l._)([(0,p.Cb)({json:{write:!0}})],Ct.prototype,"rasters",void 0),(0,l._)([(0,It.c)("rasters")],Ct.prototype,"writeRasters",null),Ct=Mt=(0,l._)([(0,C.j)("esri.layers.support.rasterFunctions.CompositeBandFunctionArguments")],Ct);const Me=Ct;let mt=class extends m{constructor(){super(...arguments),this.functionName="CompositeBand",this.functionArguments=null,this.rasterArgumentNames=["rasters"]}_bindSourceRasters(){const{sourceRasterInfos:t}=this,n=t[0];this.outputPixelType=this._getOutputPixelType(n.pixelType);const a=n.clone();if(a.attributeTable=null,a.colormap=null,a.pixelType=this.outputPixelType,a.bandCount=t.map(({bandCount:i})=>i).reduce((i,o)=>i+o),t.every(({statistics:i})=>(0,F.pC)(i)&&i.length)){const i=[];t.forEach(({statistics:o})=>(0,F.pC)(o)&&i.push(...o)),a.statistics=i}if(t.every(({histograms:i})=>(0,F.pC)(i)&&i.length)){const i=[];t.forEach(({histograms:o})=>(0,F.pC)(o)&&i.push(...o)),a.histograms=i}return this.rasterInfo=a,{success:!0}}_processPixels(t){const{pixelBlocks:n}=t;if(!n)return null;const a=n?.[0];return(0,F.Wi)(a)?null:(0,W.Gd)(n)}};(0,l._)([(0,p.Cb)({json:{write:!0,name:"rasterFunction"}})],mt.prototype,"functionName",void 0),(0,l._)([(0,p.Cb)({type:Me,json:{write:!0,name:"rasterFunctionArguments"}})],mt.prototype,"functionArguments",void 0),(0,l._)([(0,p.Cb)()],mt.prototype,"rasterArgumentNames",void 0),mt=(0,l._)([(0,C.j)("esri.layers.support.rasterFunctions.CompositeBandFunction")],mt);const Re=mt;var b,t;(t=b||(b={}))[t.UserDefined=-1]="UserDefined",t[t.LineDetectionHorizontal=0]="LineDetectionHorizontal",t[t.LineDetectionVertical=1]="LineDetectionVertical",t[t.LineDetectionLeftDiagonal=2]="LineDetectionLeftDiagonal",t[t.LineDetectionRightDiagonal=3]="LineDetectionRightDiagonal",t[t.GradientNorth=4]="GradientNorth",t[t.GradientWest=5]="GradientWest",t[t.GradientEast=6]="GradientEast",t[t.GradientSouth=7]="GradientSouth",t[t.GradientNorthEast=8]="GradientNorthEast",t[t.GradientNorthWest=9]="GradientNorthWest",t[t.SmoothArithmeticMean=10]="SmoothArithmeticMean",t[t.Smoothing3x3=11]="Smoothing3x3",t[t.Smoothing5x5=12]="Smoothing5x5",t[t.Sharpening3x3=13]="Sharpening3x3",t[t.Sharpening5x5=14]="Sharpening5x5",t[t.Laplacian3x3=15]="Laplacian3x3",t[t.Laplacian5x5=16]="Laplacian5x5",t[t.SobelHorizontal=17]="SobelHorizontal",t[t.SobelVertical=18]="SobelVertical",t[t.Sharpen=19]="Sharpen",t[t.Sharpen2=20]="Sharpen2",t[t.PointSpread=21]="PointSpread",t[t.None=255]="None";const P=new Map;function Ht(t,n,a,i,o,r,s){const e=new Float32Array(n*a),u=r.length,c=s?0:i,h=s?i:0,d=s?1:n;for(let g=c;g<a-c;g++){const T=g*n;for(let I=h;I<n-h;I++){if(o&&!o[T+I])continue;let E=0;for(let z=0;z<u;z++)E+=t[T+I+(z-i)*d]*r[z];e[T+I]=E}}return e}function Ee(t,n,a,i,o,r,s){const e=new Float32Array(n*a),u=Math.floor(i/2),c=Math.floor(o/2);for(let h=u;h<a-u;h++){const d=h*n;for(let g=c;g<n-c;g++){if(r&&!r[d+g])continue;let T=0;for(let I=0;I<i;I++)for(let E=0;E<o;E++)T+=t[d+g+(I-u)*n+E-c]*s[I*o+E];e[d+g]=T}}return e}function zt(t,n,a,i,o){const r=Math.floor(i/2);for(let e=0;e<r;e++)for(let u=0;u<n;u++)t[e*n+u]=t[(o-1-e)*n+u],t[(a-1-e)*n+u]=t[(a-o+e)*n+u];const s=Math.floor(o/2);for(let e=0;e<a;e++){const u=e*n;for(let c=0;c<s;c++)t[u+c]=t[u+o-1-c],t[u+n-c-1]=t[u+n+c-o]}}var Rt;P.set(b.None,[0,0,0,0,1,0,0,0,0]),P.set(b.LineDetectionHorizontal,[-1,-1,-1,2,2,2,-1,-1,-1]),P.set(b.LineDetectionVertical,[-1,2,-1,-1,2,-1,-1,2,-1]),P.set(b.LineDetectionLeftDiagonal,[2,-1,-1,-1,2,-1,-1,-1,2]),P.set(b.LineDetectionRightDiagonal,[-1,-1,2,-1,2,-1,2,-1,-1]),P.set(b.GradientNorth,[-1,-2,-1,0,0,0,1,2,1]),P.set(b.GradientWest,[-1,0,1,-2,0,2,-1,0,1]),P.set(b.GradientEast,[1,0,-1,2,0,-2,1,0,-1]),P.set(b.GradientSouth,[1,2,1,0,0,0,-1,-2,-1]),P.set(b.GradientNorthEast,[0,-1,-2,1,0,-1,2,1,0]),P.set(b.GradientNorthWest,[-2,-1,0,-1,0,1,0,1,2]),P.set(b.SmoothArithmeticMean,[.111111111111,.111111111111,.111111111111,.111111111111,.111111111111,.111111111111,.111111111111,.111111111111,.111111111111]),P.set(b.Smoothing3x3,[.0625,.125,.0625,.125,.25,.125,.0625,.125,.0625]),P.set(b.Smoothing5x5,[1,1,1,1,1,1,4,4,4,1,1,4,12,4,1,1,4,4,4,1,1,1,1,1,1]),P.set(b.Sharpening3x3,[-1,-1,-1,-1,9,-1,-1,-1,-1]),P.set(b.Sharpening5x5,[-1,-3,-4,-3,-1,-3,0,6,0,-3,-4,6,21,6,-4,-3,0,6,0,-3,-1,-3,-4,-3,-1]),P.set(b.Laplacian3x3,[0,-1,0,-1,4,-1,0,-1,0]),P.set(b.Laplacian5x5,[0,0,-1,0,0,0,-1,-2,-1,0,-1,-2,17,-2,-1,0,-1,-2,-1,0,0,0,-1,0,0]),P.set(b.SobelHorizontal,[-1,-2,-1,0,0,0,1,2,1]),P.set(b.SobelVertical,[-1,0,1,-2,0,2,-1,0,1]),P.set(b.Sharpen,[0,-.25,0,-.25,2,-.25,0,-.25,0]),P.set(b.Sharpen2,[-.25,-.25,-.25,-.25,3,-.25,-.25,-.25,-.25]),P.set(b.PointSpread,[-.627,.352,-.627,.352,2.923,.352,-.627,.352,-.627]);let st=Rt=class extends O{constructor(){super(...arguments),this.rows=3,this.cols=3,this.kernel=[0,0,0,0,1,0,0,0,0]}set kernelType(t){this._set("kernelType",t);const n=P.get(t);if(!n||t===b.UserDefined||t===b.None)return;const a=Math.sqrt(n.length);this._set("kernel",n),this._set("cols",a),this._set("rows",a)}clone(){return new Rt({cols:this.cols,rows:this.rows,kernel:[...this.kernel],kernelType:this.kernelType,raster:(0,_.d9)(this.raster)})}};(0,l._)([(0,p.Cb)({json:{type:Number,write:!0}})],st.prototype,"rows",void 0),(0,l._)([(0,p.Cb)({json:{type:Number,write:!0}})],st.prototype,"cols",void 0),(0,l._)([(0,p.Cb)({json:{name:"type",type:Number,write:!0}})],st.prototype,"kernelType",null),(0,l._)([(0,p.Cb)({json:{type:[Number],write:!0}})],st.prototype,"kernel",void 0),st=Rt=(0,l._)([(0,C.j)("esri.layers.support.rasterFunctions.ConvolutionFunctionArguments")],st);const ke=st;let ht=class extends m{constructor(){super(...arguments),this.functionName="Convolution",this.rasterArgumentNames=["raster"]}_bindSourceRasters(){const{kernelType:t,rows:n,cols:a,kernel:i}=this.functionArguments;if(!P.has(t))return{success:!1,error:`convolution-function: the specified kernel type is not supported ${t}`};if(t!==b.None&&n*a!==i.length)return{success:!1,error:"convolution-function: the specified rows and cols do not match the length of the kernel"};const o=this.sourceRasterInfos[0];this.outputPixelType=this._getOutputPixelType(o.pixelType);const r=o.clone();return r.pixelType=this.outputPixelType,"u8"===this.outputPixelType||[b.None,b.Sharpen,b.Sharpen2,b.Sharpening3x3,b.Sharpening5x5].includes(t)||(r.statistics=null,r.histograms=null),this.rasterInfo=r,{success:!0}}_processPixels(t){const n=t.pixelBlocks?.[0];if((0,F.Wi)(n)||this.functionArguments.kernelType===b.None)return n;let{kernel:a,rows:i,cols:o}=this.functionArguments;const r=a.reduce((s,e)=>s+e);return 0!==r&&1!==r&&(a=a.map(s=>s/r)),function Le(t,n){const a=function De(t){const n=Math.sqrt(t.length),a=t.slice(0,n),i=[1];for(let o=1;o<n;o++){let r=null;for(let s=0;s<n;s++){const e=t[s+o*n],u=t[s];if(null==r)if(0===u){if(e)return{separable:!1,row:null,col:null}}else r=e/u;else if(e/u!==r)return{separable:!1,row:null,col:null}}if(null==r)return{separable:!1,row:null,col:null};i.push(r)}return{separable:!0,row:a,col:i}}(n.kernel),i=!1!==n.mirrorEdges,o=a.separable?function Ue(t,n,a,i=!0){const{pixels:o,width:r,height:s,pixelType:e,mask:u}=t,c=o.length,h=[],d=n.length,g=a.length,T=Math.floor(d/2),I=Math.floor(g/2);for(let E=0;E<c;E++){let z=Ht(o[E],r,s,T,u,n,!0);z=Ht(z,r,s,I,u,a,!1),i&&zt(z,r,s,d,g),h.push(z)}return new y.Z({width:r,height:s,pixelType:e,pixels:h,mask:u})}(t,a.row,a.col,i):function Oe(t,n,a=!0){const{pixels:i,width:o,height:r,pixelType:s,mask:e}=t,u=i.length,c=[],{kernel:h,rows:d,cols:g}=n;for(let T=0;T<u;T++){const I=Ee(i[T],o,r,d,g,e,h);a&&zt(I,o,r,d,g),c.push(I)}return new y.Z({width:o,height:r,pixelType:s,pixels:c,mask:e})}(t,n,i),{outputPixelType:r}=n;return r&&o.clamp(r),o}(n,{kernel:a,rows:i,cols:o,outputPixelType:this.outputPixelType})}};(0,l._)([(0,p.Cb)({json:{write:!0,name:"rasterFunction"}})],ht.prototype,"functionName",void 0),(0,l._)([(0,p.Cb)({type:ke,json:{write:!0,name:"rasterFunctionArguments"}})],ht.prototype,"functionArguments",void 0),(0,l._)([(0,p.Cb)()],ht.prototype,"rasterArgumentNames",void 0),ht=(0,l._)([(0,C.j)("esri.layers.support.rasterFunctions.ConvolutionFunction")],ht);const Ze=ht;var Dt;let Ft=Dt=class extends O{constructor(){super(...arguments),this.bandIDs=[],this.missingBandAction=W.CD.bestMatch}clone(){return new Dt({bandIDs:[...this.bandIDs],missingBandAction:this.missingBandAction})}};(0,l._)([(0,p.Cb)({json:{write:!0}})],Ft.prototype,"bandIDs",void 0),(0,l._)([(0,p.Cb)({json:{write:!0}})],Ft.prototype,"missingBandAction",void 0),Ft=Dt=(0,l._)([(0,C.j)("esri.layers.support.rasterFunctions.ExtractBandFunctionArguments")],Ft);const We=Ft;let ft=class extends m{constructor(){super(...arguments),this.functionName="ExtractBand",this.functionArguments=null,this.rasterArgumentNames=["raster"]}_bindSourceRasters(){const{sourceRasterInfos:t}=this,n=t[0],{bandCount:a}=n,{bandIDs:i,missingBandAction:o}=this.functionArguments;if(o===W.CD.fail&&i.some(u=>u<0||u>=a))return{success:!1,error:"extract-band-function: invalid bandIDs"};this.outputPixelType=this._getOutputPixelType("f32");const r=n.clone();r.pixelType=this.outputPixelType;const{statistics:s,histograms:e}=r;return(0,F.pC)(s)&&s.length&&(r.statistics=i.map(u=>s[u]||s[s.length-1])),(0,F.pC)(e)&&e.length&&(r.histograms=i.map(u=>e[u]||e[e.length-1])),this.rasterInfo=r,{success:!0}}_processPixels(t){const n=t.pixelBlocks?.[0];if((0,F.Wi)(n))return null;const a=n.pixels.length,i=this.functionArguments.bandIDs.map(o=>o>=a?a-1:o);return n.extractBands(i)}};(0,l._)([(0,p.Cb)({json:{write:!0,name:"rasterFunction"}})],ft.prototype,"functionName",void 0),(0,l._)([(0,p.Cb)({type:We,json:{write:!0,name:"rasterFunctionArguments"}})],ft.prototype,"functionArguments",void 0),(0,l._)([(0,p.Cb)()],ft.prototype,"rasterArgumentNames",void 0),ft=(0,l._)([(0,C.j)("esri.layers.support.rasterFunctions.ExtractBandFunction")],ft);const Ve=ft;var Et;let rt=Et=class extends O{constructor(){super(...arguments),this.rasters=[],this.processAsMultiband=!1}writeRasters(t,n){n.rasters=t.map(a=>"number"==typeof a||"string"==typeof a?a:a.toJSON())}clone(){return new Et({method:this.operation,processAsMultiband:this.processAsMultiband,rasters:(0,_.d9)(this.rasters)})}};(0,l._)([(0,p.Cb)({json:{write:!0}})],rt.prototype,"operation",void 0),(0,l._)([(0,p.Cb)({json:{write:!0}})],rt.prototype,"rasters",void 0),(0,l._)([(0,It.c)("rasters")],rt.prototype,"writeRasters",null),(0,l._)([(0,p.Cb)({json:{write:!0}})],rt.prototype,"processAsMultiband",void 0),rt=Et=(0,l._)([(0,C.j)("esri.layers.support.rasterFunctions.LocalFunctionArguments")],rt);const Ge=rt;var Nt;function ze(t,n,a){const[i,o]=t,r=i.length,s=y.Z.createEmptyBand(a,r);for(let e=0;e<r;e++)n&&!n[e]||(s[e]=i[e]+o[e]);return s}function Ke(t,n,a){const[i]=t,r=y.Z.createEmptyBand("f32",i.length);return r.set(i),r}function Xe(t,n,a){const[i,o]=t,r=i.length,s=y.Z.createEmptyBand(a,r);for(let e=0;e<r;e++)n&&!n[e]||(s[e]=i[e]-o[e]);return s}function Je(t,n,a){const[i,o]=t,r=i.length,s=y.Z.createEmptyBand(a,r);for(let e=0;e<r;e++)n&&!n[e]||(s[e]=i[e]*o[e]);return s}function Kt(t,n,a){const[i,o]=t,r=i.length,s=y.Z.createEmptyBand(a,r);for(let e=0;e<r;e++)n&&!n[e]||(s[e]=0===o[e]?0:i[e]/o[e]);return s}function Ye(t,n,a){return Kt(t,n,"f32")}function $e(t,n,a){const[i,o]=t,r=i.length,s=y.Z.createEmptyBand(a,r);for(let e=0;e<r;e++)n&&!n[e]||(s[e]=0===o[e]?0:Math.floor(i[e]/o[e]));return s}function Qe(t,n,a,i){const[o]=t,r=o.length,s=y.Z.createEmptyBand(a,r);for(let e=0;e<r;e++)n&&!n[e]||(s[e]=i(o[e]));return s}function qe(t,n,a,i){const[o,r]=t,s=o.length,e=y.Z.createEmptyBand(a,s);for(let u=0;u<s;u++)n&&!n[u]||(e[u]=i(o[u],r[u]));return e}function tn(t,n,a){const[i,o]=t,r=i.length,s=y.Z.createEmptyBand(a,r);for(let e=0;e<r;e++)n&&!n[e]||(s[e]=i[e]&o[e]);return s}function Xt(t,n,a){const[i,o]=t,r=i.length,s=y.Z.createEmptyBand(a,r);for(let e=0;e<r;e++)n&&!n[e]||(s[e]=i[e]<<o[e]);return s}function en(t,n,a){const[i]=t,o=i.length,r=y.Z.createEmptyBand(a,o);for(let s=0;s<o;s++)n&&!n[s]||(r[s]=~i[s]);return r}function nn(t,n,a){const[i,o]=t,r=i.length,s=y.Z.createEmptyBand(a,r);for(let e=0;e<r;e++)n&&!n[e]||(s[e]=i[e]|o[e]);return s}function sn(t,n,a){const[i,o]=t,r=i.length,s=y.Z.createEmptyBand(a,r);for(let e=0;e<r;e++)n&&!n[e]||(s[e]=i[e]>>o[e]);return s}function rn(t,n,a){const[i,o]=t,r=i.length,s=y.Z.createEmptyBand(a,r);for(let e=0;e<r;e++)n&&!n[e]||(s[e]=i[e]^o[e]);return s}function on(t,n,a){const[i,o]=t,r=i.length,s=y.Z.createEmptyBand(a,r);for(let e=0;e<r;e++)n&&!n[e]||(s[e]=i[e]&&o[e]?1:0);return s}function an(t,n,a){const[i]=t,o=i.length,r=y.Z.createEmptyBand(a,o);for(let s=0;s<o;s++)n&&!n[s]||(r[s]=i[s]?0:1);return r}function un(t,n,a){const[i,o]=t,r=i.length,s=y.Z.createEmptyBand(a,r);for(let e=0;e<r;e++)n&&!n[e]||(s[e]=i[e]||o[e]?1:0);return s}function ln(t,n,a){const[i,o]=t,r=i.length,s=y.Z.createEmptyBand(a,r);for(let e=0;e<r;e++)n&&!n[e]||(s[e]=(i[e]?1:0)^(o[e]?1:0));return s}function cn(t,n,a){const[i,o]=t,r=i.length,s=y.Z.createEmptyBand(a,r);for(let e=0;e<r;e++)n&&!n[e]||(s[e]=i[e]===o[e]?1:0);return s}function Jt(t,n,a,i){const[o]=t,r=o.length,s=y.Z.createEmptyBand(a,r);for(let e=0;e<r;e++)n&&!n[e]||(s[e]=i**o[e]);return s}function pn(t,n,a){return Jt(t,n,a,10)}function mn(t,n,a){return Jt(t,n,a,2)}function hn(t,n,a){const[i,o]=t,r=i.length,s=y.Z.createEmptyBand(a,r);for(let e=0;e<r;e++)n&&!n[e]||(s[e]=i[e]>o[e]?1:0);return s}function fn(t,n,a){const[i,o]=t,r=i.length,s=y.Z.createEmptyBand(a,r);for(let e=0;e<r;e++)n&&!n[e]||(s[e]=i[e]>=o[e]?1:0);return s}function dn(t,n,a){const[i,o]=t,r=i.length,s=y.Z.createEmptyBand(a,r);for(let e=0;e<r;e++)n&&!n[e]||(s[e]=i[e]<o[e]?1:0);return s}function gn(t,n,a){const[i,o]=t,r=i.length,s=y.Z.createEmptyBand(a,r);for(let e=0;e<r;e++)n&&!n[e]||(s[e]=i[e]<=o[e]?1:0);return s}function yn(t,n,a){const[i]=t,o=i.length,r=y.Z.createEmptyBand(a,o);if(!n)return r;for(let s=0;s<o;s++)r[s]=n[s]?0:1;return r}function _n(t,n,a){const[i,o]=t,r=i.length,s=y.Z.createEmptyBand(a,r);for(let e=0;e<r;e++)n&&!n[e]||(s[e]=i[e]%o[e]);return s}function xn(t,n,a){const[i]=t,o=i.length,r=y.Z.createEmptyBand(a,o);for(let s=0;s<o;s++)n&&!n[s]||(r[s]=-i[s]);return r}function An(t,n,a){const[i,o]=t,r=i.length,s=y.Z.createEmptyBand(a,r);for(let e=0;e<r;e++)n&&!n[e]||(s[e]=i[e]===o[e]?0:1);return s}function vn(t,n,a){const[i,o]=t,r=i.length,s=y.Z.createEmptyBand(a,r),e=new Uint8Array(r);for(let u=0;u<r;u++)null!=n&&!n[u]||0!==i[u]||(s[u]=o[u],e[u]=255);return{band:s,mask:e}}function Cn(t,n,a){const[i,o,r]=t,s=i.length,e=y.Z.createEmptyBand(a,s);for(let u=0;u<s;u++)n&&!n[u]||(e[u]=i[u]?o[u]:r[u]);return e}function Yt(t,n,a){const i=t.length;if(i<2)return t[0];const[o]=t,r=o.length,s=y.Z.createEmptyBand(a,r);s.set(o);for(let e=0;e<r;e++)if(!n||n[e])for(let u=1;u<i;u++){const c=t[u];s[e]<c[e]&&(s[e]=c[e])}return s}function $t(t,n,a){const i=t.length;if(i<2)return t[0];const[o]=t,r=o.length,s=y.Z.createEmptyBand(a,r);s.set(o);for(let e=0;e<r;e++)if(!n||n[e])for(let u=1;u<i;u++){const c=t[u];s[e]>c[e]&&(s[e]=c[e])}return s}function Qt(t,n,a){const i=t.length;if(i<2)return t[0];const[o]=t,r=o.length,s=y.Z.createEmptyBand(a,r);s.set(o);for(let e=0;e<r;e++)if(!n||n[e]){let u=s[e];for(let c=1;c<i;c++){const h=t[c];s[e]<h[e]&&(s[e]=h[e]),u>h[e]&&(u=h[e])}s[e]-=u}return s}function qt(t,n,a){const i=t.length;if(i<2)return t[0];const[o]=t,r=o.length,s=y.Z.createEmptyBand(a,r);s.set(o);for(let e=0;e<r;e++)if(!n||n[e]){for(let u=1;u<i;u++)s[e]+=t[u][e];s[e]/=i}return s}function te(t,n,a){const i=t.length;if(i<2)return t[0];const[o]=t,r=o.length,s=y.Z.createEmptyBand(a,r);s.set(o);for(let e=0;e<r;e++)if(!n||n[e])for(let u=1;u<i;u++)s[e]+=t[u][e];return s}function ee(t,n,a){const i=t.length;if(i<2)return t[0];const[o]=t,r=o.length,s=y.Z.createEmptyBand(a,r);for(let e=0;e<r;e++)if(!n||n[e]){const u=new Float32Array(i);let c=0;for(let d=0;d<i;d++){const g=t[d];c+=g[e],u[d]=g[e]}c/=i;let h=0;for(let d=0;d<i;d++)h+=(u[d]-c)*u[d]-c;s[e]=Math.sqrt(h/i-1)}return s}function ne(t,n,a){const i=t.length;if(i<2)return t[0];const o=Math.floor(i/2),[r]=t,s=r.length,e=y.Z.createEmptyBand(a,s),u=new Float32Array(i);for(let c=0;c<s;c++)if(!n||n[c]){for(let h=0;h<i;h++)u[h]=t[h][c];u.sort(),e[c]=u[o]}return e}function se(t,n,a){const i=t.length;if(i<2)return t[0];const[o]=t,r=o.length,s=y.Z.createEmptyBand(a,r),e=new Map;for(let u=0;u<r;u++)if(!n||n[u]){let c;e.clear();for(let g=0;g<i;g++)c=t[g][u],e.set(c,e.has(c)?e.get(c)+1:1);let h=0,d=0;for(const g of e.keys())h=e.get(g),h>d&&(d=h,c=g);s[u]=c}return s}function re(t,n,a){const i=t.length;if(i<2)return t[0];const[o]=t,r=o.length,s=y.Z.createEmptyBand(a,r),e=new Map;for(let u=0;u<r;u++)if(!n||n[u]){let c;e.clear();for(let g=0;g<i;g++)c=t[g][u],e.set(c,e.has(c)?e.get(c)+1:1);let h=0,d=t.length;for(const g of e.keys())h=e.get(g),h<d&&(d=h,c=g);s[u]=c}return s}function oe(t,n,a){const i=t.length;if(i<2)return t[0];const[o]=t,r=o.length,s=y.Z.createEmptyBand(a,r),e=new Set;for(let u=0;u<r;u++)if(!n||n[u]){let c;e.clear();for(let h=0;h<i;h++)c=t[h][u],e.add(c);s[u]=e.size}return s}function Fn(t,n,a){return se(t,null,a)}function bn(t,n,a){return re(t,null,a)}function wn(t,n,a){return oe(t,null,a)}function Sn(t,n,a){return Yt(t,null,a)}function Tn(t,n,a){return $t(t,null,a)}function Nn(t,n,a){return ee(t,null,a)}function Pn(t,n,a){return te(t,null,a)}function Bn(t,n,a){return qt(t,null,a)}function jn(t,n,a){return ne(t,null,a)}function In(t,n,a){return Qt(t,null,a)}!function(t){t[t.Plus=1]="Plus",t[t.Minus=2]="Minus",t[t.Times=3]="Times",t[t.SquareRoot=4]="SquareRoot",t[t.Power=5]="Power",t[t.ACos=6]="ACos",t[t.ASin=7]="ASin",t[t.ATan=8]="ATan",t[t.ATanH=9]="ATanH",t[t.Abs=10]="Abs",t[t.BitwiseAnd=11]="BitwiseAnd",t[t.BitwiseLeftShift=12]="BitwiseLeftShift",t[t.BitwiseNot=13]="BitwiseNot",t[t.BitwiseOr=14]="BitwiseOr",t[t.BitwiseRightShift=15]="BitwiseRightShift",t[t.BitwiseXOr=16]="BitwiseXOr",t[t.BooleanAnd=17]="BooleanAnd",t[t.BooleanNot=18]="BooleanNot",t[t.BooleanOr=19]="BooleanOr",t[t.BooleanXOr=20]="BooleanXOr",t[t.Cos=21]="Cos",t[t.CosH=22]="CosH",t[t.Divide=23]="Divide",t[t.EqualTo=24]="EqualTo",t[t.Exp=25]="Exp",t[t.Exp10=26]="Exp10",t[t.Exp2=27]="Exp2",t[t.GreaterThan=28]="GreaterThan",t[t.GreaterThanEqual=29]="GreaterThanEqual",t[t.Int=30]="Int",t[t.IsNull=31]="IsNull",t[t.Float=32]="Float",t[t.LessThan=33]="LessThan",t[t.LessThanEqual=34]="LessThanEqual",t[t.Ln=35]="Ln",t[t.Log10=36]="Log10",t[t.Log2=37]="Log2",t[t.Majority=38]="Majority",t[t.Max=39]="Max",t[t.Mean=40]="Mean",t[t.Med=41]="Med",t[t.Min=42]="Min",t[t.Minority=43]="Minority",t[t.Mod=44]="Mod",t[t.Negate=45]="Negate",t[t.NotEqual=46]="NotEqual",t[t.Range=47]="Range",t[t.RoundDown=48]="RoundDown",t[t.RoundUp=49]="RoundUp",t[t.SetNull=50]="SetNull",t[t.Sin=51]="Sin",t[t.SinH=52]="SinH",t[t.Square=53]="Square",t[t.Std=54]="Std",t[t.Sum=55]="Sum",t[t.Tan=56]="Tan",t[t.TanH=57]="TanH",t[t.Variety=58]="Variety",t[t.ACosH=59]="ACosH",t[t.ASinH=60]="ASinH",t[t.ATan2=61]="ATan2",t[t.FloatDivide=64]="FloatDivide",t[t.FloorDivide=65]="FloorDivide",t[t.MajorityIgnoreNoData=66]="MajorityIgnoreNoData",t[t.MaxIgnoreNoData=67]="MaxIgnoreNoData",t[t.MeanIgnoreNoData=68]="MeanIgnoreNoData",t[t.MedIgnoreNoData=69]="MedIgnoreNoData",t[t.MinIgnoreNoData=70]="MinIgnoreNoData",t[t.MinorityIgnoreNoData=71]="MinorityIgnoreNoData",t[t.RangeIgnoreNoData=72]="RangeIgnoreNoData",t[t.StdIgnoreNoData=73]="StdIgnoreNoData",t[t.SumIgnoreNoData=74]="SumIgnoreNoData",t[t.VarietyIgnoreNoData=75]="VarietyIgnoreNoData",t[t.Con=76]="Con"}(Nt||(Nt={}));const B=new Map,Pt=new Map,x=new Map;let dt=class extends m{constructor(){super(...arguments),this.functionName="Local",this.functionArguments=null,this.rasterArgumentNames=["rasters"]}_bindSourceRasters(){const{sourceRasterInfos:t}=this,n=t[0],{bandCount:a}=n,{processAsMultiband:i}=this.functionArguments;if(i&&t.some(r=>r.bandCount!==a))return{success:!1,error:"local-function: input rasters do not have same band count"};this.outputPixelType=this._getOutputPixelType("f32");const o=n.clone();return o.pixelType=this.outputPixelType,o.statistics=null,o.histograms=null,i||(o.bandCount=1),this.rasterInfo=o,{success:!0}}_processPixels(t){const{pixelBlocks:n}=t;return(0,F.Wi)(n)||n.some(a=>(0,F.Wi)(a))?null:function Rn(t,n,a={}){!function Mn(){B.size||(B.set(4,Math.sqrt),B.set(6,Math.acos),B.set(7,Math.asin),B.set(8,Math.atan),B.set(9,Math.atanh),B.set(10,Math.abs),B.set(21,Math.cos),B.set(22,Math.cosh),B.set(25,Math.exp),B.set(30,Math.floor),B.set(35,Math.log),B.set(36,Math.log10),B.set(37,Math.log2),B.set(48,Math.floor),B.set(49,Math.ceil),B.set(51,Math.sin),B.set(52,Math.sinh),B.set(56,Math.tan),B.set(57,Math.tanh),B.set(59,Math.acosh),B.set(60,Math.asinh),B.set(65,Math.floor),Pt.set(5,Math.pow),Pt.set(61,Math.atan2),x.set(1,ze),x.set(2,Xe),x.set(3,Je),x.set(11,tn),x.set(12,Xt),x.set(12,Xt),x.set(13,en),x.set(14,nn),x.set(15,sn),x.set(16,rn),x.set(17,on),x.set(18,an),x.set(19,un),x.set(20,ln),x.set(23,Kt),x.set(24,cn),x.set(26,pn),x.set(27,mn),x.set(28,hn),x.set(29,fn),x.set(31,yn),x.set(32,Ke),x.set(33,dn),x.set(34,gn),x.set(44,_n),x.set(45,xn),x.set(46,An),x.set(64,Ye),x.set(65,$e),x.set(76,Cn),x.set(38,se),x.set(39,Yt),x.set(40,qt),x.set(41,ne),x.set(42,$t),x.set(43,re),x.set(47,Qt),x.set(54,ee),x.set(55,te),x.set(58,oe),x.set(66,Fn),x.set(67,Sn),x.set(68,Bn),x.set(69,jn),x.set(70,Tn),x.set(71,bn),x.set(72,In),x.set(73,Nn),x.set(74,Pn),x.set(75,wn))}();const i=(0,F.Wg)(function He(t){const n=t.map(s=>s.mask).filter(s=>(0,F.pC)(s));if(0===n.length)return null;const a=n[0].length,i=new Uint8Array(a);if(1===n.length)return i.set(n[0]),i;let o,r=n[0];for(let s=1;s<n.length;s++){o=n[s];for(let e=0;e<a;e++)i[e]=r[e]|o[e];r=o}return i}(t)),{processAsMultiband:o,outputPixelType:r="f32"}=a,s=o?t[0].pixels.length:1,e=[];let u;for(let h=0;h<s;h++){const d=t.map(T=>T.pixels[h]);let g;if(n===Nt.SetNull){const T=vn(d,i,r);g=T.band,u=T.mask}else x.has(n)?g=x.get(n)(d,i,r):B.has(n)?g=Qe(d,i,r,B.get(n)):Pt.has(n)&&(g=qe(d,i,r,Pt.get(n)));if(null==g)return null;e.push(g)}u||n===Nt.IsNull||(u=i);const c=t[0];return new y.Z({width:c.width,height:c.height,pixelType:r,mask:u,pixels:e})}(n,this.functionArguments.operation,{processAsMultiband:this.functionArguments.processAsMultiband,outputPixelType:this.outputPixelType??void 0})}};(0,l._)([(0,p.Cb)({json:{write:!0,name:"rasterFunction"}})],dt.prototype,"functionName",void 0),(0,l._)([(0,p.Cb)({type:Ge,json:{write:!0,name:"rasterFunctionArguments"}})],dt.prototype,"functionArguments",void 0),(0,l._)([(0,p.Cb)()],dt.prototype,"rasterArgumentNames",void 0),dt=(0,l._)([(0,C.j)("esri.layers.support.rasterFunctions.LocalFunction")],dt);const Dn=dt;var Ot;let gt=Ot=class extends O{constructor(){super(...arguments),this.includedRanges=null,this.noDataValues=null,this.noDataInterpretation=W.DX.matchAny}clone(){return new Ot({includedRanges:this.includedRanges?.slice()??[],noDataValues:this.noDataValues?.slice()??[],noDataInterpretation:this.noDataInterpretation})}};(0,l._)([(0,p.Cb)({json:{write:!0}})],gt.prototype,"includedRanges",void 0),(0,l._)([(0,p.Cb)({json:{write:!0}})],gt.prototype,"noDataValues",void 0),(0,l._)([(0,p.Cb)({json:{write:!0}})],gt.prototype,"noDataInterpretation",void 0),gt=Ot=(0,l._)([(0,C.j)("esri.layers.support.rasterFunctions.MaskFunctionArguments")],gt);const En=gt;let ot=class extends m{constructor(){super(...arguments),this.functionName="Mask",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.lookup=null}_bindSourceRasters(){const t=this.sourceRasterInfos[0].clone(),{pixelType:n}=t;this.outputPixelType=this._getOutputPixelType(n),t.pixelType=this.outputPixelType,this.rasterInfo=t;const{includedRanges:a,noDataValues:i}=this.functionArguments;return a?.length||i?.length?(this.lookup=(0,W.nA)(n,this.functionArguments.includedRanges,this.functionArguments.noDataValues),{success:!0}):{success:!1,error:"missing includedRanges or noDataValues argument"}}_processPixels(t){const n=t.pixelBlocks?.[0];if((0,F.Wi)(n))return null;const{outputPixelType:a,lookup:i}=this,{includedRanges:o,noDataValues:r,noDataInterpretation:s}=this.functionArguments;return(0,W.sS)(n,{includedRanges:o,noDataValues:r,outputPixelType:a,matchAll:s===W.DX.matchAll,lookup:i})}};(0,l._)([(0,p.Cb)({json:{write:!0,name:"rasterFunction"}})],ot.prototype,"functionName",void 0),(0,l._)([(0,p.Cb)({type:En,json:{write:!0,name:"rasterFunctionArguments"}})],ot.prototype,"functionArguments",void 0),(0,l._)([(0,p.Cb)()],ot.prototype,"rasterArgumentNames",void 0),(0,l._)([(0,p.Cb)({json:{write:!0}})],ot.prototype,"lookup",void 0),ot=(0,l._)([(0,C.j)("esri.layers.support.rasterFunctions.MaskFunction")],ot);const On=ot;var Ut;let yt=Ut=class extends O{constructor(){super(...arguments),this.visibleBandID=0,this.infraredBandID=1,this.scaled=!0}clone(){const{visibleBandID:t,infraredBandID:n,scaled:a}=this;return new Ut({visibleBandID:t,infraredBandID:n,scaled:a})}};(0,l._)([(0,p.Cb)({json:{write:!0}})],yt.prototype,"visibleBandID",void 0),(0,l._)([(0,p.Cb)({json:{write:!0}})],yt.prototype,"infraredBandID",void 0),(0,l._)([(0,p.Cb)({json:{write:!0}})],yt.prototype,"scaled",void 0),yt=Ut=(0,l._)([(0,C.j)("esri.layers.support.rasterFunctions.NDVIFunctionArguments")],yt);const Un=yt;let _t=class extends m{constructor(){super(...arguments),this.functionName="NDVI",this.functionArguments=null,this.rasterArgumentNames=["raster"]}_bindSourceRasters(){const{scaled:t}=this.functionArguments;this.outputPixelType=this._getOutputPixelType(t?"u8":"f32");const n=this.sourceRasterInfos[0].clone();n.pixelType=this.outputPixelType,n.colormap=null,n.histograms=null;const[a,i,o,r]=t?[0,200,100,10]:[-1,1,0,.1];return n.statistics=[{min:a,max:i,avg:o,stddev:r}],this.rasterInfo=n,{success:!0}}_processPixels(t){const n=t.pixelBlocks?.[0];if((0,F.Wi)(n))return null;const{visibleBandID:a,infraredBandID:i,scaled:o}=this.functionArguments;return function pe(t,n,a,i){const{mask:o,pixels:r,width:s,height:e}=t,u=r[a],c=r[n],h=c.length,d=i?new Uint8Array(h):new Float32Array(h),g=i?100:1,T=i?100:0;for(let E=0;E<h;E++)if(null==o||o[E]){const z=u[E],ae=c[E],ue=z+ae;ue&&(d[E]=(z-ae)/ue*g+T)}const I=new y.Z({width:s,height:e,mask:o,pixelType:i?"u8":"f32",pixels:[d]});return I.updateStatistics(),I}(n,a,i,o)}};(0,l._)([(0,p.Cb)({json:{write:!0,name:"rasterFunction"}})],_t.prototype,"functionName",void 0),(0,l._)([(0,p.Cb)({type:Un,json:{write:!0,name:"rasterFunctionArguments"}})],_t.prototype,"functionArguments",void 0),(0,l._)([(0,p.Cb)()],_t.prototype,"rasterArgumentNames",void 0),_t=(0,l._)([(0,C.j)("esri.layers.support.rasterFunctions.NDVIFunction")],_t);const Ln=_t;var Lt;let it=Lt=class extends O{constructor(){super(...arguments),this.inputRanges=null,this.outputValues=null,this.noDataRanges=null,this.allowUnmatched=!1}clone(){return new Lt({inputRanges:[...this.inputRanges],outputValues:[...this.outputValues],noDataRanges:[...this.noDataRanges],allowUnmatched:this.allowUnmatched})}};(0,l._)([(0,p.Cb)({json:{write:!0}})],it.prototype,"inputRanges",void 0),(0,l._)([(0,p.Cb)({json:{write:!0}})],it.prototype,"outputValues",void 0),(0,l._)([(0,p.Cb)({json:{write:!0}})],it.prototype,"noDataRanges",void 0),(0,l._)([(0,p.Cb)({json:{write:!0}})],it.prototype,"allowUnmatched",void 0),it=Lt=(0,l._)([(0,C.j)("esri.layers.support.rasterFunctions.RemapFunctionArguments")],it);const kn=it;let at=class extends m{constructor(){super(...arguments),this.functionName="Remap",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.lookup=null}_bindSourceRasters(){const t=this.sourceRasterInfos[0].clone(),{pixelType:n}=t;this.outputPixelType=this._getOutputPixelType(n),t.pixelType=this.outputPixelType,t.colormap=null,t.histograms=null;const{statistics:a}=t,{allowUnmatched:i,outputValues:o}=this.functionArguments;if((0,F.pC)(a)&&a.length&&!i){let r=o[0],s=r;for(let e=0;e<o.length;e++)r=r>o[e]?o[e]:r,s=s>o[e]?s:o[e];for(let e=0;e<a.length;e++)a[e]={...a[e],min:r,max:s}}return this.rasterInfo=t,this.lookup=i?null:(0,W.oB)(n,this.functionArguments.inputRanges,o),{success:!0}}_processPixels(t){const n=t.pixelBlocks?.[0];if((0,F.Wi)(n))return null;const{lookup:a,outputPixelType:i}=this;if(a)return(0,W.XV)(n,{lut:[a.lut],offset:a.offset,outputPixelType:i});const{inputRanges:o,outputValues:r,noDataRanges:s,allowUnmatched:e}=this.functionArguments;return(0,W.a2)(n,{inputRanges:o,outputValues:r,noDataRanges:s,allowUnmatched:e,outputPixelType:i})}};(0,l._)([(0,p.Cb)({json:{write:!0,name:"rasterFunction"}})],at.prototype,"functionName",void 0),(0,l._)([(0,p.Cb)({type:kn,json:{write:!0,name:"rasterFunctionArguments"}})],at.prototype,"functionArguments",void 0),(0,l._)([(0,p.Cb)()],at.prototype,"rasterArgumentNames",void 0),(0,l._)([(0,p.Cb)({json:{write:!0}})],at.prototype,"lookup",void 0),at=(0,l._)([(0,C.j)("esri.layers.support.rasterFunctions.RemapFunction")],at);const Zn=at;var kt;const Wn=new R.X({0:"degree",1:"percent-rise",2:"adjusted"},{useNumericKeys:!0});let ut=kt=class extends O{constructor(){super(...arguments),this.slopeType="degree",this.zFactor=1,this.pixelSizePower=.664,this.pixelSizeFactor=.024}clone(){return new kt({slopeType:this.slopeType,zFactor:this.zFactor,pixelSizePower:this.pixelSizePower,pixelSizeFactor:this.pixelSizeFactor,raster:this.raster})}};(0,l._)([(0,v.J)(Wn)],ut.prototype,"slopeType",void 0),(0,l._)([(0,p.Cb)({type:Number,json:{write:!0}})],ut.prototype,"zFactor",void 0),(0,l._)([(0,p.Cb)({type:Number,json:{name:"psPower",write:!0}})],ut.prototype,"pixelSizePower",void 0),(0,l._)([(0,p.Cb)({type:Number,json:{name:"psFactor",write:!0}})],ut.prototype,"pixelSizeFactor",void 0),ut=kt=(0,l._)([(0,C.j)("esri.layers.support.rasterFunctions.SlopeFunctionArguments")],ut);const Vn=ut;let lt=class extends m{constructor(){super(...arguments),this.functionName="Slope",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isGCS=!1}_bindSourceRasters(){this.outputPixelType=this._getOutputPixelType("f32");const t=this.sourceRasterInfos[0].clone();return t.pixelType=this.outputPixelType,t.statistics=null,t.histograms=null,this.rasterInfo=t,this.isGCS=t.spatialReference.isGeographic,{success:!0}}_processPixels(t){const n=t.pixelBlocks?.[0];if((0,F.Wi)(n))return null;const{zFactor:a,slopeType:i,pixelSizePower:o,pixelSizeFactor:r}=this.functionArguments,{isGCS:s}=this,{extent:e}=t;return(0,w.yg)(n,{zFactor:a,slopeType:i,pixelSizePower:o,pixelSizeFactor:r,isGCS:s,resolution:e?{x:e.width/n.width,y:e.height/n.height}:{x:1,y:1}})}};(0,l._)([(0,p.Cb)({json:{write:!0,name:"rasterFunction"}})],lt.prototype,"functionName",void 0),(0,l._)([(0,p.Cb)({type:Vn,json:{write:!0,name:"rasterFunctionArguments"}})],lt.prototype,"functionArguments",void 0),(0,l._)([(0,p.Cb)()],lt.prototype,"rasterArgumentNames",void 0),(0,l._)([(0,p.Cb)({json:{write:!0}})],lt.prototype,"isGCS",void 0),lt=(0,l._)([(0,C.j)("esri.layers.support.rasterFunctions.SlopeFunction")],lt);const Gn=lt;var Zt;let bt=Zt=class extends O{constructor(){super(...arguments),this.statistics=null,this.histograms=null}clone(){return new Zt({statistics:(0,_.d9)(this.statistics),histograms:(0,_.d9)(this.histograms)})}};(0,l._)([(0,p.Cb)({json:{write:!0}})],bt.prototype,"statistics",void 0),(0,l._)([(0,p.Cb)({json:{write:!0}})],bt.prototype,"histograms",void 0),bt=Zt=(0,l._)([(0,C.j)("esri.layers.support.rasterFunctions.StatisticsHistogramsFunctionArguments")],bt);const Hn=bt;let ct=class extends m{constructor(){super(...arguments),this.functionName="StatisticsHistograms",this.functionArguments=null,this.rasterArgumentNames=["raster"]}_bindSourceRasters(){const t=this.sourceRasterInfos[0];this.outputPixelType=this._getOutputPixelType("u8");const n=t.clone(),{statistics:a,histograms:i}=this.functionArguments;return n.histograms=i,a&&(n.statistics=a.map(([o,r,s,e])=>({min:o,max:r,avg:s,stddev:e}))),this.rasterInfo=n,{success:!0}}_processPixels(t){return t.pixelBlocks?.[0]}};(0,l._)([(0,p.Cb)({json:{write:!0,name:"rasterFunction"}})],ct.prototype,"functionName",void 0),(0,l._)([(0,p.Cb)({type:Hn,json:{write:!0,name:"rasterFunctionArguments"}})],ct.prototype,"functionArguments",void 0),(0,l._)([(0,p.Cb)()],ct.prototype,"rasterArgumentNames",void 0),(0,l._)([(0,p.Cb)({json:{write:!0}})],ct.prototype,"indexedColormap",void 0),ct=(0,l._)([(0,C.j)("esri.layers.support.rasterFunctions.StatisticsHistogramsFunction")],ct);const zn=ct;var Wt;const Kn=new R.X({0:"none",3:"standard-deviation",4:"histogram-equalization",5:"min-max",6:"percent-clip",7:"sigmoid"},{useNumericKeys:!0});let U=Wt=class extends O{constructor(){super(...arguments),this.computeGamma=!1,this.dynamicRangeAdjustment=!1,this.gamma=[],this.histograms=null,this.statistics=null,this.stretchType="none",this.useGamma=!1}writeStatistics(t,n,a){t?.length&&(Array.isArray(t[0])||(t=t.map(i=>[i.min,i.max,i.avg,i.stddev])),n[a]=t)}clone(){return new Wt({stretchType:this.stretchType,outputMin:this.outputMin,outputMax:this.outputMax,useGamma:this.useGamma,computeGamma:this.computeGamma,statistics:(0,_.d9)(this.statistics),gamma:(0,_.d9)(this.gamma),sigmoidStrengthLevel:this.sigmoidStrengthLevel,numberOfStandardDeviations:this.numberOfStandardDeviations,minPercent:this.minPercent,maxPercent:this.maxPercent,histograms:(0,_.d9)(this.histograms),dynamicRangeAdjustment:this.dynamicRangeAdjustment,raster:this.raster})}};(0,l._)([(0,p.Cb)({type:Boolean,json:{write:!0}})],U.prototype,"computeGamma",void 0),(0,l._)([(0,p.Cb)({type:Boolean,json:{name:"dra",write:!0}})],U.prototype,"dynamicRangeAdjustment",void 0),(0,l._)([(0,p.Cb)({type:[Number],json:{write:!0}})],U.prototype,"gamma",void 0),(0,l._)([(0,p.Cb)()],U.prototype,"histograms",void 0),(0,l._)([(0,p.Cb)({type:Number,json:{write:!0}})],U.prototype,"maxPercent",void 0),(0,l._)([(0,p.Cb)({type:Number,json:{write:!0}})],U.prototype,"minPercent",void 0),(0,l._)([(0,p.Cb)({type:Number,json:{write:!0}})],U.prototype,"numberOfStandardDeviations",void 0),(0,l._)([(0,p.Cb)({type:Number,json:{name:"max",write:!0}})],U.prototype,"outputMax",void 0),(0,l._)([(0,p.Cb)({type:Number,json:{name:"min",write:!0}})],U.prototype,"outputMin",void 0),(0,l._)([(0,p.Cb)({type:Number,json:{write:!0}})],U.prototype,"sigmoidStrengthLevel",void 0),(0,l._)([(0,p.Cb)({json:{type:[[Number]],write:!0}})],U.prototype,"statistics",void 0),(0,l._)([(0,It.c)("statistics")],U.prototype,"writeStatistics",null),(0,l._)([(0,v.J)(Kn)],U.prototype,"stretchType",void 0),(0,l._)([(0,p.Cb)({type:Boolean,json:{write:!0}})],U.prototype,"useGamma",void 0),U=Wt=(0,l._)([(0,C.j)("esri.layers.support.rasterFunctions.StretchFunctionArguments")],U);const Xn=U;var wt=f(17057);let Q=class extends m{constructor(){super(...arguments),this.functionName="Stretch",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.lookup=null,this.cutOffs=null}_bindSourceRasters(){this.lookup=null,this.cutOffs=null;const t=this.sourceRasterInfos[0],{pixelType:n}=t,{functionArguments:a}=this,{dynamicRangeAdjustment:i,gamma:o,useGamma:r}=a;if(!i&&["u8","u16","s8","s16"].includes(n)){const e=(0,wt.AV)(a.toJSON(),{rasterInfo:t});this.lookup=(0,wt.hE)({pixelType:n,...e,gamma:r?o:null})}else i&&(this.cutOffs=(0,wt.AV)(a.toJSON(),{rasterInfo:t}));this.outputPixelType=this._getOutputPixelType(n);const s=t.clone();return s.pixelType=this.outputPixelType,s.statistics=null,s.histograms=null,"u8"===this.outputPixelType&&(s.keyProperties.DataType="processed"),this.rasterInfo=s,{success:!0}}_processPixels(t){const n=t.pixelBlocks?.[0];if((0,F.Wi)(n))return n;const{lookup:a}=this;if(a)return(0,W.XV)(n,{...a,outputPixelType:this.rasterInfo.pixelType});const{functionArguments:i}=this,o=this.cutOffs||(0,wt.AV)(i.toJSON(),{rasterInfo:this.sourceRasterInfos[0],pixelBlock:n});return(0,wt.dy)(n,{...o,gamma:i.useGamma?i.gamma:null,outputPixelType:this.outputPixelType})}};(0,l._)([(0,p.Cb)({json:{write:!0,name:"rasterFunction"}})],Q.prototype,"functionName",void 0),(0,l._)([(0,p.Cb)({type:Xn,json:{write:!0,name:"rasterFunctionArguments"}})],Q.prototype,"functionArguments",void 0),(0,l._)([(0,p.Cb)()],Q.prototype,"rasterArgumentNames",void 0),(0,l._)([(0,p.Cb)({json:{write:!0}})],Q.prototype,"lookup",void 0),(0,l._)([(0,p.Cb)({json:{write:!0}})],Q.prototype,"cutOffs",void 0),Q=(0,l._)([(0,C.j)("esri.layers.support.rasterFunctions.StretchFunction")],Q);const Jn=Q,L=new Map;function Yn(t,n){if("rasterFunction"in t)return ie(t,n??{});throw new j.Z("raster-function-helper","unsupported raster function json.")}function ie(t,n){const{rasterFunction:a,rasterFunctionArguments:i}=t,o=t.outputPixelType?.toLowerCase();if(null==a||!L.has(a))throw new j.Z("raster-function-helper",`unsupported raster function: ${a}`);const r=L.get(a),s=("function"==typeof r.ctor?r.ctor:r.ctor.default).fromJSON({...t,outputPixelType:o}),{rasterArgumentNames:e}=s,u=[],c=function $n(t,n){return"rasters"===n[0]&&Array.isArray(t.rasters)?t.rasters:n.map(a=>t[a])}(i,e),h="rasters"===e[0],d=[];for(let g=0;g<c.length;g++){const T=c[g];let I;null==T||"string"==typeof T&&T.startsWith("$")?u.push(n?.raster):"string"==typeof T?n[T]&&u.push(n[T]):"number"!=typeof T&&"rasterFunction"in T&&(I=ie(T,n),h||(s.functionArguments[e[g]]=I),u.push(I)),h&&d.push(I??T)}if(h&&(s.functionArguments.rasters=d),n){s.sourceRasters=u;const g=n.raster?.url;g&&(s.mainPrimaryRasterId=g)}return s}L.set("Aspect",{desc:"Aspect Function",ctor:A,rasterArgumentNames:["raster"]}),L.set("BandArithmetic",{desc:"Band Arithmetic Function",ctor:Ne,rasterArgumentNames:["raster"]}),L.set("Colormap",{desc:"Colormap Function",ctor:Ie,rasterArgumentNames:["raster"]}),L.set("CompositeBand",{desc:"CompositeBand Function",ctor:Re,rasterArgumentNames:["rasters"]}),L.set("Convolution",{desc:"Convolution Function",ctor:Ze,rasterArgumentNames:["raster"]}),L.set("ExtractBand",{desc:"ExtractBand Function",ctor:Ve,rasterArgumentNames:["raster"]}),L.set("Local",{desc:"Local Function",ctor:Dn,rasterArgumentNames:["rasters"]}),L.set("Mask",{desc:"Mask Function",ctor:On,rasterArgumentNames:["raster"]}),L.set("NDVI",{desc:"NDVI Function",ctor:Ln,rasterArgumentNames:["raster"]}),L.set("Remap",{desc:"Remap Function",ctor:Zn,rasterArgumentNames:["raster"]}),L.set("Slope",{desc:"Slope Function",ctor:Gn,rasterArgumentNames:["raster"]}),L.set("StatisticsHistograms",{desc:"Statistics Histograms Function",ctor:zn,rasterArgumentNames:["raster"]}),L.set("Stretch",{desc:"Stretch Function",ctor:Jn,rasterArgumentNames:["raster"]})},96504:(St,X,f)=>{f.d(X,{Z:()=>G});var j=f(17626),l=f(86810),F=f(77712),q=(f(85931),f(90912),f(76898));let C=class extends l.wq{get affectsPixelSize(){return!1}forwardTransform(K){return K}inverseTransform(K){return K}};(0,j._)([(0,F.Cb)()],C.prototype,"affectsPixelSize",null),(0,j._)([(0,F.Cb)({json:{write:!0}})],C.prototype,"spatialReference",void 0),C=(0,j._)([(0,q.j)("esri.layers.support.rasterTransforms.BaseRasterTransform")],C);const G=C},76671:(St,X,f)=>{f.d(X,{Z:()=>K});var j=f(17626),l=f(77712),xt=(f(85931),f(90912),f(55342)),q=f(76898),C=f(96504);let G=class extends C.Z{constructor(){super(...arguments),this.type="gcs-shift",this.tolerance=1e-8}forwardTransform(N){return"point"===(N=N.clone()).type?(N.x>180+this.tolerance&&(N.x-=360),N):(N.xmin>=180-this.tolerance?(N.xmax-=360,N.xmin-=360):N.xmax>180+this.tolerance&&(N.xmin=-180,N.xmax=180),N)}inverseTransform(N){return"point"===(N=N.clone()).type?(N.x<-this.tolerance&&(N.x+=360),N):(N.xmin<-this.tolerance&&(N.xmin+=360,N.xmax+=360),N)}};(0,j._)([(0,xt.J)({GCSShiftXform:"gcs-shift"})],G.prototype,"type",void 0),(0,j._)([(0,l.Cb)()],G.prototype,"tolerance",void 0),G=(0,j._)([(0,q.j)("esri.layers.support.rasterTransforms.GCSShiftTransform")],G);const K=G},85374:(St,X,f)=>{f.d(X,{Z:()=>Z});var j=f(17626),F=(f(29132),f(77712)),q=(f(85931),f(90912),f(55342)),C=f(68653),G=f(76898),K=f(99433),N=f(96504),H=f(72642),O=f(2004);function J(m,w,S){const{x:A,y:_}=w;if(S<2)return{x:m[0]+A*m[2]+_*m[4],y:m[1]+A*m[3]+_*m[5]};if(2===S){const V=A*A,Tt=_*_,W=A*_;return{x:m[0]+A*m[2]+_*m[4]+V*m[6]+W*m[8]+Tt*m[10],y:m[1]+A*m[3]+_*m[5]+V*m[7]+W*m[9]+Tt*m[11]}}const v=A*A,R=_*_,y=A*_,M=v*A,tt=v*_,et=A*R,D=_*R;return{x:m[0]+A*m[2]+_*m[4]+v*m[6]+y*m[8]+R*m[10]+M*m[12]+tt*m[14]+et*m[16]+D*m[18],y:m[1]+A*m[3]+_*m[5]+v*m[7]+y*m[9]+R*m[11]+M*m[13]+tt*m[15]+et*m[17]+D*m[19]}}function Y(m,w,S){const{xmin:A,ymin:_,xmax:v,ymax:R,spatialReference:y}=w;let M=[];if(S<2)M.push({x:A,y:R}),M.push({x:v,y:R}),M.push({x:A,y:_}),M.push({x:v,y:_});else{let D=10;for(let V=0;V<D;V++)M.push({x:A,y:_+(R-_)*V/(D-1)}),M.push({x:v,y:_+(R-_)*V/(D-1)});D=8;for(let V=1;V<=D;V++)M.push({x:A+(v-A)*V/D,y:_}),M.push({x:A+(v-A)*V/D,y:R})}M=M.map(D=>J(m,D,S));const tt=M.map(D=>D.x),et=M.map(D=>D.y);return new O.Z({xmin:Math.min.apply(null,tt),xmax:Math.max.apply(null,tt),ymin:Math.min.apply(null,et),ymax:Math.max.apply(null,et),spatialReference:y})}let k=class extends N.Z{constructor(){super(...arguments),this.polynomialOrder=1,this.type="polynomial"}readForwardCoefficients(m,w){const{coeffX:S,coeffY:A}=w;if(!S?.length||!A?.length||S.length!==A.length)return null;const _=[];for(let v=0;v<S.length;v++)_.push(S[v]),_.push(A[v]);return _}writeForwardCoefficients(m,w,S){const A=[],_=[];for(let v=0;v<m?.length;v++)v%2==0?A.push(m[v]):_.push(m[v]);w.coeffX=A,w.coeffY=_}get inverseCoefficients(){let m=this._get("inverseCoefficients");const w=this._get("forwardCoefficients");return!m&&w&&this.polynomialOrder<2&&(m=function At(m){const[w,S,A,_,v,R]=m,y=A*R-v*_,M=v*_-A*R;return[(v*S-w*R)/y,(A*S-w*_)/M,R/y,_/M,-v/y,-A/M]}(w)),m}set inverseCoefficients(m){this._set("inverseCoefficients",m)}readInverseCoefficients(m,w){const{inverseCoeffX:S,inverseCoeffY:A}=w;if(!S?.length||!A?.length||S.length!==A.length)return null;const _=[];for(let v=0;v<S.length;v++)_.push(S[v]),_.push(A[v]);return _}writeInverseCoefficients(m,w,S){const A=[],_=[];for(let v=0;v<m?.length;v++)v%2==0?A.push(m[v]):_.push(m[v]);w.inverseCoeffX=A,w.inverseCoeffY=_}get affectsPixelSize(){return this.polynomialOrder>0}forwardTransform(m){if("point"===m.type){const w=J(this.forwardCoefficients,m,this.polynomialOrder);return new H.Z({x:w.x,y:w.y,spatialReference:m.spatialReference})}return Y(this.forwardCoefficients,m,this.polynomialOrder)}inverseTransform(m){if("point"===m.type){const w=J(this.inverseCoefficients,m,this.polynomialOrder);return new H.Z({x:w.x,y:w.y,spatialReference:m.spatialReference})}return Y(this.inverseCoefficients,m,this.polynomialOrder)}};(0,j._)([(0,F.Cb)({json:{write:!0}})],k.prototype,"polynomialOrder",void 0),(0,j._)([(0,F.Cb)()],k.prototype,"forwardCoefficients",void 0),(0,j._)([(0,C.r)("forwardCoefficients",["coeffX","coeffY"])],k.prototype,"readForwardCoefficients",null),(0,j._)([(0,K.c)("forwardCoefficients")],k.prototype,"writeForwardCoefficients",null),(0,j._)([(0,F.Cb)({json:{write:!0}})],k.prototype,"inverseCoefficients",null),(0,j._)([(0,C.r)("inverseCoefficients",["inverseCoeffX","inverseCoeffY"])],k.prototype,"readInverseCoefficients",null),(0,j._)([(0,K.c)("inverseCoefficients")],k.prototype,"writeInverseCoefficients",null),(0,j._)([(0,F.Cb)()],k.prototype,"affectsPixelSize",null),(0,j._)([(0,q.J)({PolynomialXform:"polynomial"})],k.prototype,"type",void 0),k=(0,j._)([(0,G.j)("esri.layers.support.rasterTransforms.PolynomialTransform")],k);const Z=k},46572:(St,X,f)=>{f.d(X,{j:()=>k,c:()=>Z});var j=f(76671),l=f(17626),G=(f(63290),f(90912),f(85931),f(26584),f(8314),f(55342)),K=f(76898),N=f(96504);let H=class extends N.Z{constructor(){super(...arguments),this.type="identity"}};(0,l._)([(0,G.J)({IdentityXform:"identity"})],H.prototype,"type",void 0),H=(0,l._)([(0,K.j)("esri.layers.support.rasterTransforms.IdentityTransform")],H);const O=H;var J=f(85374);const Y={GCSShiftXform:j.Z,IdentityXform:O,PolynomialXform:J.Z},At=Object.keys(Y);function k(m){const w=m?.type;return!m||At.includes(w)}function Z(m){if(!m?.type)return null;const S=Y[m?.type];if(S){const A=new S;return A.read(m),A}return null}}}]);