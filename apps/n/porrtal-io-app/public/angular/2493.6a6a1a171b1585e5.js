/*
Copyright 2022 Comcast Cable Communications Management, LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
"use strict";(self.webpackChunka_porrtal_io_app=self.webpackChunka_porrtal_io_app||[]).push([[2493],{42493:(k,F,p)=>{p.r(F),p.d(F,{ElevationQuery:()=>j,GeometryDescriptor:()=>x,getFinestLodIndex:()=>A});var f=p(15861),$=p(59213),T=p(26584),y=p(62208),E=p(10699),I=p(16730),_=p(72854),M=p(72642),N=p(55214),w=p(55915),R=p(65401),z=p(13762),b=p(80403);class S{constructor(e,t=null){this.tile=e,this.zmin=0,this.zmax=0,(0,y.pC)(t)&&(0,y.pC)(e)&&(this._samplerData=new b.K(t,e.extent),this.zmin=t.minValue,this.zmax=t.maxValue)}sample(e,t){if((0,y.Wi)(this._samplerData))return;const{safeWidth:n,width:i,pixelData:o,noDataValue:l,dx:s,dy:a,y1:r,x0:c}=this._samplerData,h=V(a*(r-t),0,n),m=V(s*(e-c),0,n),u=Math.floor(h),g=Math.floor(m),C=u*i+g,G=C+i,D=o[C],q=o[G],U=o[C+1],W=o[G+1];if(D!==l&&q!==l&&U!==l&&W!==l){const P=m-g,Q=D+(U-D)*P;return Q+(q+(W-q)*P-Q)*(h-u)}}}function V(v,e,t){return v<e?e:v>t?t:v}var O=p(68511);class j{queryAll(e,t,n){var i=this;return(0,f.Z)(function*(){if(!(e=n&&n.ignoreInvisibleLayers?e.filter(c=>c.visible):e.slice()).length)throw new T.Z("elevation-query:invalid-layer","Elevation queries require at least one elevation layer to fetch tiles from");const o=x.fromGeometry(t);let l=!1;n&&n.returnSampleInfo||(l=!0);const s={...Z,...n,returnSampleInfo:!0},a=yield i.query(e[e.length-1],o,s),r=yield i._queryAllContinue(e,a,s);return r.geometry=r.geometry.export(),l&&delete r.sampleInfo,r})()}query(e,t,n){var i=this;return(0,f.Z)(function*(){if(!e)throw new T.Z("elevation-query:invalid-layer","Elevation queries require an elevation layer to fetch tiles from");if(!t||!(t instanceof x)&&"point"!==t.type&&"multipoint"!==t.type&&"polyline"!==t.type)throw new T.Z("elevation-query:invalid-geometry","Only point, polyline and multipoint geometries can be used to query elevation");const o={...Z,...n},l=new H(e,t.spatialReference,o),s=o.signal;return yield e.load({signal:s}),yield i._createGeometryDescriptor(l,t,s),yield i._selectTiles(l,s),yield i._populateElevationTiles(l,s),i._sampleGeometryWithElevation(l),i._createQueryResult(l,s)})()}createSampler(e,t,n){var i=this;return(0,f.Z)(function*(){if(!e)throw new T.Z("elevation-query:invalid-layer","Elevation queries require an elevation layer to fetch tiles from");if(!t||"extent"!==t.type)throw new T.Z("elevation-query:invalid-extent","Invalid or undefined extent");const o={...Z,...n};return i._createSampler(e,t,o)})()}createSamplerAll(e,t,n){var i=this;return(0,f.Z)(function*(){if(!(e=n&&n.ignoreInvisibleLayers?e.filter(s=>s.visible):e.slice()).length)throw new T.Z("elevation-query:invalid-layer","Elevation queries require at least one elevation layer to fetch tiles from");if(!t||"extent"!==t.type)throw new T.Z("elevation-query:invalid-extent","Invalid or undefined extent");const o={...Z,...n,returnSampleInfo:!0},l=yield i._createSampler(e[e.length-1],t,o);return i._createSamplerAllContinue(e,t,l,o)})()}_createSampler(e,t,n,i){var o=this;return(0,f.Z)(function*(){const l=n.signal;yield e.load({signal:l});const s=t.spatialReference,a=e.tileInfo.spatialReference;s.equals(a)||(yield(0,w.iQ)([{source:s,dest:a}],{signal:l}),t=(0,w.iV)(t,a));const r=new K(e,t,n,i);return yield o._selectTiles(r,l),yield o._populateElevationTiles(r,l),new z.Tl(r.elevationTiles,r.layer.tileInfo,r.options.noDataValue)})()}_createSamplerAllContinue(e,t,n,i){var o=this;return(0,f.Z)(function*(){if(e.pop(),!e.length)return n;const l=n.samplers.map(c=>(0,R.oJ)(c.extent)),s=yield o._createSampler(e[e.length-1],t,i,l);if(0===s.samplers.length)return n;const a=n.samplers.concat(s.samplers),r=new z.Tl(a,i.noDataValue);return o._createSamplerAllContinue(e,t,r,i)})()}_queryAllContinue(e,t,n){var i=this;return(0,f.Z)(function*(){const o=e.pop(),l=t.geometry.coordinates,s=t.sampleInfo;(0,y.O3)(s);const a=[],r=[];for(let u=0;u<l.length;u++){const g=s[u];g.demResolution>=0?g.source||(g.source=o):e.length&&(a.push(l[u]),r.push(u))}if(!e.length||0===a.length)return t;const c=t.geometry.clone(a),h=yield i.query(e[e.length-1],c,n),m=h.sampleInfo;if(!m)throw new Error("no sampleInfo");return r.forEach((u,g)=>{l[u].z=h.geometry.coordinates[g].z,s[u].demResolution=m[g].demResolution}),i._queryAllContinue(e,t,n)})()}_createQueryResult(e,t){var n=this;return(0,f.Z)(function*(){const i=yield e.geometry.project(e.outSpatialReference,t);(0,y.O3)(i);const o={geometry:i.export(),noDataValue:e.options.noDataValue};return e.options.returnSampleInfo&&(o.sampleInfo=n._extractSampleInfo(e)),e.geometry.coordinates.forEach(l=>{l.tile=null,l.elevationTile=null}),o})()}_createGeometryDescriptor(e,t,n){return(0,f.Z)(function*(){let i;const o=e.layer.tileInfo.spatialReference;if(t instanceof x?i=yield t.project(o,n):(yield(0,w.iQ)([{source:t.spatialReference,dest:o}],{signal:n}),i=(0,w.iV)(t,o)),!i)throw new T.Z("elevation-query:spatial-reference-mismatch",`Cannot query elevation in '${t.spatialReference.wkid}' on an elevation service in '${o.wkid}'`);e.geometry=x.fromGeometry(i)})()}_selectTiles(e,t){var n=this;return(0,f.Z)(function*(){const i=e.options.demResolution;if("geometry"===e.type&&n._preselectOutsideLayerExtent(e),"number"==typeof i)n._selectTilesClosestResolution(e);else if("finest-contiguous"===i)yield n._selectTilesFinestContiguous(e,t);else{if("auto"!==i)throw new T.Z("elevation-query:invalid-dem-resolution",`Invalid dem resolution value '${i}', expected a number, "finest-contiguous" or "auto"`);yield n._selectTilesAuto(e,t)}})()}_preselectOutsideLayerExtent(e){if((0,y.Wi)(e.layer.fullExtent))return;const t=new S(null);t.sample=()=>e.options.noDataValue,e.outsideExtentTile=t;const n=e.layer.fullExtent;e.geometry.coordinates.forEach(i=>{const o=i.x,l=i.y;(o<n.xmin||o>n.xmax||l<n.ymin||l>n.ymax)&&(i.elevationTile=t)})}_selectTilesClosestResolution(e){const n=this._findNearestDemResolutionLODIndex(e.layer.tileInfo,e.options.demResolution);e.selectTilesAtLOD(n)}_findNearestDemResolutionLODIndex(e,t){const n=t/(0,I.c9)(e.spatialReference);let i=e.lods[0],o=0;for(let l=1;l<e.lods.length;l++){const s=e.lods[l];Math.abs(s.resolution-n)<Math.abs(i.resolution-n)&&(i=s,o=l)}return o}_selectTilesFinestContiguous(e,t){var n=this;return(0,f.Z)(function*(){const i=A(e.layer.tileInfo,e.options.minDemResolution);yield n._selectTilesFinestContiguousAt(e,i,t)})()}_selectTilesFinestContiguousAt(e,t,n){var i=this;return(0,f.Z)(function*(){const o=e.layer;if(e.selectTilesAtLOD(t),t<0)return;const l=o.tilemapCache,s=e.getTilesToFetch();try{if(l)yield(0,E.Hl)(Promise.all(s.map(a=>l.fetchAvailability(a.level,a.row,a.col,{signal:n}))),n);else if(yield i._populateElevationTiles(e,n),!e.allElevationTilesFetched())throw e.clearElevationTiles(),new T.Z("elevation-query:has-unavailable-tiles")}catch(a){(0,E.r9)(a),yield i._selectTilesFinestContiguousAt(e,t-1,n)}})()}_populateElevationTiles(e,t){return(0,f.Z)(function*(){const n=e.getTilesToFetch(),i={},o=e.options.cache,l=e.options.noDataValue,s=n.map(function(){var a=(0,f.Z)(function*(r){if(null==r.id)return;const c=`${e.layer.uid}:${r.id}:${l}`,h=(0,y.pC)(o)?o.get(c):null,m=(0,y.pC)(h)?h:yield e.layer.fetchTile(r.level,r.row,r.col,{noDataValue:l,signal:t});(0,y.pC)(o)&&o.put(c,m),i[r.id]=new S(r,m)});return function(r){return a.apply(this,arguments)}}());yield(0,E.Hl)((0,E.as)(s),t),e.populateElevationTiles(i)})()}_selectTilesAuto(e,t){var n=this;return(0,f.Z)(function*(){n._selectTilesAutoFinest(e),n._reduceTilesForMaximumRequests(e);const i=e.layer.tilemapCache;if(!i)return n._selectTilesAutoPrefetchUpsample(e,t);const o=e.getTilesToFetch(),l={},s=o.map(function(){var a=(0,f.Z)(function*(r){const c=new O.f(null,0,0,0,(0,R.Ue)()),h=yield(0,$.q6)(i.fetchAvailabilityUpsample(r.level,r.row,r.col,c,{signal:t}));!1!==h.ok?null!=r.id&&(l[r.id]=c):(0,E.r9)(h.error)});return function(r){return a.apply(this,arguments)}}());yield(0,E.Hl)(Promise.all(s),t),e.remapTiles(l)})()}_reduceTilesForMaximumRequests(e){const t=e.layer.tileInfo;let n=0;const i={},o=a=>{null!=a.id&&(a.id in i?i[a.id]++:(i[a.id]=1,n++))},l=a=>{if(null==a.id)return;const r=i[a.id];1===r?(delete i[a.id],n--):i[a.id]=r-1};e.forEachTileToFetch(o,l);let s=!0;for(;s&&(s=!1,e.forEachTileToFetch(a=>{n<=e.options.maximumAutoTileRequests||(l(a),t.upsampleTile(a)&&(s=!0),o(a))},l),s););}_selectTilesAutoFinest(e){const t=A(e.layer.tileInfo,e.options.minDemResolution);e.selectTilesAtLOD(t,e.options.maximumAutoTileRequests)}_selectTilesAutoPrefetchUpsample(e,t){var n=this;return(0,f.Z)(function*(){const i=e.layer.tileInfo;yield n._populateElevationTiles(e,t);let o=!1;e.forEachTileToFetch((l,s)=>{i.upsampleTile(l)?o=!0:s()}),o&&(yield n._selectTilesAutoPrefetchUpsample(e,t))})()}_sampleGeometryWithElevation(e){e.geometry.coordinates.forEach(t=>{const n=t.elevationTile;let i=e.options.noDataValue;if(n){const o=n.sample(t.x,t.y);(0,y.pC)(o)?i=o:t.elevationTile=null}t.z=i})}_extractSampleInfo(e){const t=e.layer.tileInfo,n=(0,I.c9)(t.spatialReference);return e.geometry.coordinates.map(i=>{let o=-1;return i.elevationTile&&i.elevationTile!==e.outsideExtentTile&&(o=t.lodAt(i.elevationTile.tile.level).resolution*n),{demResolution:o}})}}class x{export(){return this._exporter(this.coordinates,this.spatialReference)}clone(e){const t=new x;return t.geometry=this.geometry,t.spatialReference=this.spatialReference,t.coordinates=e||this.coordinates.map(n=>n.clone()),t._exporter=this._exporter,t}project(e,t){var n=this;return(0,f.Z)(function*(){if(n.spatialReference.equals(e))return n.clone();yield(0,w.iQ)([{source:n.spatialReference,dest:e}],{signal:t});const i=new _.Z({spatialReference:n.spatialReference,points:n.coordinates.map(a=>[a.x,a.y])}),o=(0,w.iV)(i,e);if(!o)return null;const l=n.coordinates.map((a,r)=>{const c=a.clone(),h=o.points[r];return c.x=h[0],c.y=h[1],c}),s=n.clone(l);return s.spatialReference=e,s})()}static fromGeometry(e){const t=new x;if(t.geometry=e,t.spatialReference=e.spatialReference,e instanceof x)t.coordinates=e.coordinates.map(n=>n.clone()),t._exporter=(n,i)=>{const o=e.clone(n);return o.spatialReference=i,o};else switch(e.type){case"point":{const n=e,{hasZ:i,hasM:o}=n;t.coordinates=i&&o?[new d(n.x,n.y,n.z,n.m)]:i?[new d(n.x,n.y,n.z)]:o?[new d(n.x,n.y,null,n.m)]:[new d(n.x,n.y)],t._exporter=(l,s)=>e.hasM?new M.Z(l[0].x,l[0].y,l[0].z,l[0].m,s):new M.Z(l[0].x,l[0].y,l[0].z,s);break}case"multipoint":{const n=e,{hasZ:i,hasM:o}=n;t.coordinates=n.points.map(i&&o?l=>new d(l[0],l[1],l[2],l[3]):i?l=>new d(l[0],l[1],l[2]):o?l=>new d(l[0],l[1],null,l[2]):l=>new d(l[0],l[1])),t._exporter=(l,s)=>e.hasM?new _.Z({points:l.map(a=>[a.x,a.y,a.z,a.m]),hasZ:!0,hasM:!0,spatiaReference:s}):new _.Z(l.map(a=>[a.x,a.y,a.z]),s);break}case"polyline":{const n=e,i=[],o=[],{hasZ:l,hasM:s}=e;let a=0;for(const r of n.paths)if(o.push([a,a+r.length]),a+=r.length,l&&s)for(const c of r)i.push(new d(c[0],c[1],c[2],c[3]));else if(l)for(const c of r)i.push(new d(c[0],c[1],c[2]));else if(s)for(const c of r)i.push(new d(c[0],c[1],null,c[2]));else for(const c of r)i.push(new d(c[0],c[1]));t.coordinates=i,t._exporter=(r,c)=>{const h=r.map(e.hasM?u=>[u.x,u.y,u.z,u.m]:u=>[u.x,u.y,u.z]),m=o.map(u=>h.slice(u[0],u[1]));return new N.Z({paths:m,hasM:e.hasM,hasZ:!0,spatialReference:c})};break}}return t}}class d{constructor(e,t,n=null,i=null,o=null,l=null){this.x=e,this.y=t,this.z=n,this.m=i,this.tile=o,this.elevationTile=l}clone(){return new d(this.x,this.y,this.z,this.m)}}class L{constructor(e,t){this.layer=e,this.options=t}}class H extends L{constructor(e,t,n){super(e,n),this.outSpatialReference=t,this.type="geometry"}selectTilesAtLOD(e){if(e<0)this.geometry.coordinates.forEach(t=>{t.tile=null});else{const t=this.layer.tileInfo,n=t.lods[e].level;this.geometry.coordinates.forEach(i=>{i.tile=t.tileAt(n,i.x,i.y)})}}allElevationTilesFetched(){return!this.geometry.coordinates.some(e=>!e.elevationTile)}clearElevationTiles(){for(const e of this.geometry.coordinates)e.elevationTile!==this.outsideExtentTile&&(e.elevationTile=null)}populateElevationTiles(e){for(const t of this.geometry.coordinates)!t.elevationTile&&t.tile?.id&&(t.elevationTile=e[t.tile.id])}remapTiles(e){for(const t of this.geometry.coordinates){const n=t.tile?.id;t.tile=n?e[n]:null}}getTilesToFetch(){const e={},t=[];for(const n of this.geometry.coordinates){const i=n.tile;if(!i)continue;const o=n.tile?.id;n.elevationTile||!o||e[o]||(e[o]=i,t.push(i))}return t}forEachTileToFetch(e){for(const t of this.geometry.coordinates)t.tile&&!t.elevationTile&&e(t.tile,()=>{t.tile=null})}}class K extends L{constructor(e,t,n,i){super(e,n),this.type="extent",this.elevationTiles=[],this._candidateTiles=[],this._fetchedCandidates=new Set,this.extent=t.intersection(e.fullExtent),this.maskExtents=i}selectTilesAtLOD(e,t){const n=this._maximumLodForRequests(t),i=Math.min(n,e);i<0?this._candidateTiles.length=0:this._selectCandidateTilesCoveringExtentAt(i)}_maximumLodForRequests(e){const t=this.layer.tileInfo;if(!e)return t.lods.length-1;const n=this.extent;if((0,y.Wi)(n))return-1;for(let i=t.lods.length-1;i>=0;i--){const o=t.lods[i],s=o.resolution*t.size[1];if(Math.ceil(n.width/(o.resolution*t.size[0]))*Math.ceil(n.height/s)<=e)return i}return-1}allElevationTilesFetched(){return this._candidateTiles.length===this.elevationTiles.length}clearElevationTiles(){this.elevationTiles.length=0,this._fetchedCandidates.clear()}populateElevationTiles(e){for(const t of this._candidateTiles){const n=t.id&&e[t.id];n&&(this._fetchedCandidates.add(t),this.elevationTiles.push(n))}}remapTiles(e){this._candidateTiles=this._uniqueNonOverlappingTiles(this._candidateTiles.map(t=>e[t.id]))}getTilesToFetch(){return this._candidateTiles}forEachTileToFetch(e,t){const n=this._candidateTiles;this._candidateTiles=[],n.forEach(i=>{if(this._fetchedCandidates.has(i))return void(t&&t(i));let o=!1;e(i,()=>o=!0),o?t&&t(i):this._candidateTiles.push(i)}),this._candidateTiles=this._uniqueNonOverlappingTiles(this._candidateTiles,t)}_uniqueNonOverlappingTiles(e,t){const n={},i=[];for(const l of e){const s=l.id;s&&!n[s]?(n[s]=l,i.push(l)):t&&t(l)}const o=i.sort((l,s)=>l.level-s.level);return o.filter((l,s)=>{for(let a=0;a<s;a++){const r=o[a].extent;if(r&&l.extent&&(0,R.r3)(r,l.extent))return t&&t(l),!1}return!0})}_selectCandidateTilesCoveringExtentAt(e){this._candidateTiles.length=0;const t=this.extent;if((0,y.Wi)(t))return;const n=this.layer.tileInfo,i=n.lods[e],o=n.tileAt(i.level,t.xmin,t.ymin),l=o.extent;if((0,y.Wi)(l))return;const a=i.resolution*n.size[1],r=Math.ceil((t.xmax-l[0])/(i.resolution*n.size[0])),c=Math.ceil((t.ymax-l[1])/a);for(let h=0;h<c;h++)for(let m=0;m<r;m++){const u=new O.f(null,o.level,o.row-h,o.col+m);n.updateTileInfo(u),this._tileIsMasked(u)||this._candidateTiles.push(u)}}_tileIsMasked(e){return!!this.maskExtents&&this.maskExtents.some(t=>e.extent&&(0,R.r3)(t,e.extent))}}function A(v,e=0){let t=v.lods.length-1;if(e>0){const n=e/(0,I.c9)(v.spatialReference),i=v.lods.findIndex(o=>o.resolution<n);0===i?t=0:i>0&&(t=i-1)}return t}const Z={maximumAutoTileRequests:20,noDataValue:0,returnSampleInfo:!1,demResolution:"auto",minDemResolution:0}}}]);