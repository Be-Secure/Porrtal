"use strict";(self.webpackChunka_porrtal_io_app=self.webpackChunka_porrtal_io_app||[]).push([[4654],{986:(Dt,xt,j)=>{j.d(xt,{E:()=>Q});const B=new(j(6879).Z);function Q(it){if(!B.hasBidiChar(it))return[it,!1];let dt;return dt="rtl"===B.checkContextual(it)?"IDNNN":"ICNNN",[B.bidiTransform(it,dt,"VLYSN"),!0]}},72283:(Dt,xt,j)=>{j.d(xt,{GP:()=>it,QK:()=>gt,XV:()=>Mt,hh:()=>st,ov:()=>_t,qh:()=>et,v1:()=>Tt,wp:()=>ut,zY:()=>Et,zv:()=>Lt});var K=j(58817),B=j(91179),Q=j(97373);function it(z){const Z=(0,K.d9)(z);return function at(z){z&&((0,B.oU)(z)?q(z.rings):(0,B.l9)(z)?q(z.paths):(0,B.aW)(z)&&X(z.points),dt(z))}(Z),Z}function dt(z){if(!z)return null;(0,B.wp)(z)?z.y=-z.y:(0,B.oU)(z)?mt(z.rings):(0,B.l9)(z)?mt(z.paths):(0,B.aW)(z)&&L(z.points)}function L(z){if(z){const Z=z.length;for(let $=0;$<Z;$++)z[$][1]=-z[$][1]}}function mt(z){if(z)for(const Z of z)L(Z)}function V(z){if(z)for(let Z=z.length-1;Z>0;--Z)z[Z][0]-=z[Z-1][0],z[Z][1]-=z[Z-1][1]}function Y(z){if(z)for(const Z of z)V(Z)}function X(z){if(z){const Z=z.length;for(let $=1;$<Z;++$)z[$][0]+=z[$-1][0],z[$][1]+=z[$-1][1]}}function q(z){if(z)for(const Z of z)X(Z)}function ut(z){z&&(dt(z),(0,B.oU)(z)?Y(z.rings):(0,B.l9)(z)?Y(z.paths):(0,B.aW)(z)&&V(z.points))}function _t(z){if(z)for(const Z of z)st(Z)}function st(z){z&&z.reverse()}function Mt(z,Z,$){return[z[0]+(Z[0]-z[0])*$,z[1]+(Z[1]-z[1])*$]}function gt(z){return!(!z||0===z.length)&&z[0][0]===z[z.length-1][0]&&z[0][1]===z[z.length-1][1]}function Lt(z){return z[4]}function et(z,Z){z[4]=Z}class Tt{constructor(Z,$,F,W){this.acceptPolygon=$,this.acceptPolyline=F,this.geomUnitsPerPoint=W,this.pathCount=-1,this.pathIndex=-1,this.iteratePath=!1,Z&&((0,B.oU)(Z)?$&&(this.multiPath=Z.rings,this.isClosed=!0):(0,B.l9)(Z)?F&&(this.multiPath=Z.paths,this.isClosed=!1):(0,B.YX)(Z)&&$&&(this.multiPath=kt(Z).rings,this.isClosed=!0),this.multiPath&&(this.pathCount=this.multiPath.length)),this.internalPlacement=new Q.u}next(){if(!this.multiPath)return null;for(;this.iteratePath||this.pathIndex<this.pathCount-1;){this.iteratePath||this.pathIndex++;const Z=this.processPath(this.multiPath[this.pathIndex]);if(Z)return Z}return this.pathCount=-1,this.pathIndex=-1,this.multiPath=null,null}}class Et{constructor(Z,$,F,W){this.inputGeometries=Z,this.acceptPolygon=$,this.acceptPolyline=F,this.geomUnitsPerPoint=W,this.pathCount=-1,this.pathIndex=-1,this.iteratePath=!1}next(){for(;;){if(!this.multiPath){let Z=this.inputGeometries.next();for(;Z;){if((0,B.oU)(Z)?this.acceptPolygon&&(this.multiPath=Z.rings,this.isClosed=!0):(0,B.l9)(Z)?this.acceptPolyline&&(this.multiPath=Z.paths,this.isClosed=!1):(0,B.YX)(Z)&&this.acceptPolygon&&(this.multiPath=kt(Z).rings,this.isClosed=!0),this.multiPath){this.pathCount=this.multiPath.length,this.pathIndex=-1;break}Z=this.inputGeometries.next()}if(!this.multiPath)return null}for(;this.iteratePath||this.pathIndex<this.pathCount-1;){this.iteratePath||this.pathIndex++;const Z=this.processPath(this.multiPath[this.pathIndex]);if(Z)return Z}this.pathCount=-1,this.pathIndex=-1,this.multiPath=null}}}function kt(z){return{rings:[[[z.xmin,z.ymin],[z.xmin,z.ymax],[z.xmax,z.ymax],[z.xmax,z.ymin],[z.xmin,z.ymin]]]}}},29214:(Dt,xt,j)=>{j.d(xt,{M:()=>B}),j(58817);class B{constructor(dt){this._geometry=dt}next(){const dt=this._geometry;return this._geometry=null,dt}}},11004:(Dt,xt,j)=>{j.d(xt,{h:()=>D,W:()=>o});var K=j(58817),B=j(91179),Q=j(72283);let it=(()=>{class a{static local(){return null===a.instance&&(a.instance=new a),a.instance}execute(e,r,_,c){return new dt(e,r,_)}}return a.instance=null,a})();class dt{constructor(i,e,r){this._inputGeometries=i,this._angleTolerance=void 0!==e.angleTolerance?e.angleTolerance:120,this._maxCosAngle=Math.cos((1-Math.abs(this._angleTolerance)/180)*Math.PI)}next(){let i=this._inputGeometries.next();for(;i;){if((0,B.oU)(i)){this._isClosed=!0;const e=(0,K.d9)(i);return this._processMultipath(e.rings),e}if((0,B.l9)(i)){this._isClosed=!1;const e=(0,K.d9)(i);return this._processMultipath(e.paths),e}if((0,B.YX)(i)){if(this._maxCosAngle)return i;this._isClosed=!0;const e=[[i.xmin,i.ymin],[i.xmin,i.ymax],[i.xmax,i.ymax],[i.xmax,i.ymin],[i.xmin,i.ymin]];return this._processPath(e),{rings:[e]}}i=this._inputGeometries.next()}return null}_processMultipath(i){if(i)for(const e of i)this._processPath(e)}_processPath(i){if(i){let e,r,_,c,l,g,d=i.length,P=i[0];this._isClosed&&++d;for(let x=1;x<d;++x){let M;M=this._isClosed&&x===d-1?i[0]:i[x];const w=M[0]-P[0],b=M[1]-P[1],v=Math.sqrt(w*w+b*b);x>1&&v>0&&_>0&&(e*w+r*b)/v/_<=this._maxCosAngle&&(0,Q.qh)(P,1),1===x&&(c=w,l=b,g=v),v>0&&(P=M,e=w,r=b,_=v)}this._isClosed&&_>0&&g>0&&(e*c+r*l)/g/_<=this._maxCosAngle&&(0,Q.qh)(i[0],1)}}}var L=j(7547);const mt=.03;class V{constructor(){this._path=[]}path(){return this._path}addPath(i,e){e||i.reverse(),Array.prototype.push.apply(this._path,i),e||i.reverse()}static mergePath(i,e){e&&Array.prototype.push.apply(i,e)}startPath(i){this._path.push(i)}lineTo(i){this._path.push(i)}close(){const i=this._path;i.length>1&&(i[0][0]===i[i.length-1][0]&&i[0][1]===i[i.length-1][1]||i.push([i[0][0],i[0][1]]))}}class Y{constructor(i=0,e=!1){}normalize(i){const e=Math.sqrt(i[0]*i[0]+i[1]*i[1]);0!==e&&(i[0]/=e,i[1]/=e)}calculateLength(i,e){const r=e[0]-i[0],_=e[1]-i[1];return Math.sqrt(r*r+_*_)}calculateSegLength(i,e){return this.calculateLength(i[e],i[e+1])}calculatePathLength(i){let e=0;const r=i?i.length:0;for(let _=0;_<r-1;++_)e+=this.calculateSegLength(i,_);return e}calculatePathArea(i){let e=0;const r=i?i.length:0;for(let _=0;_<r-1;++_)e+=(i[_+1][0]-i[_][0])*(i[_+1][1]+i[_][1]);return e/2}getCoord2D(i,e,r){return[i[0]+(e[0]-i[0])*r,i[1]+(e[1]-i[1])*r]}getSegCoord2D(i,e,r){return this.getCoord2D(i[e],i[e+1],r)}getAngle(i,e,r){return Math.atan2(e[1]-i[1],e[0]-i[0])}getSegAngle(i,e,r){return this.getAngle(i[e],i[e+1],r)}getAngleCS(i,e,r){const _=e[0]-i[0],c=e[1]-i[1],l=Math.sqrt(_*_+c*c);return l>0?[_/l,c/l]:[1,0]}getSegAngleCS(i,e,r){return this.getAngleCS(i[e],i[e+1],r)}cut(i,e,r,_){return[r<=0?i[e]:this.getSegCoord2D(i,e,r),_>=1?i[e+1]:this.getSegCoord2D(i,e,_)]}addSegment(i,e,r){r&&i.push(e[0]),i.push(e[1])}getSubCurve(i,e,r){const _=[];return this.appendSubCurve(_,i,e,r)?_:null}appendSubCurve(i,e,r,_){const c=e?e.length-1:0;let l=0,g=!0,d=0;for(;d<c;){const P=this.calculateSegLength(e,d);if(0!==P){if(g){if(l+P>r){let M=1,w=!1;l+P>=_&&(M=(_-l)/P,w=!0);const b=this.cut(e,d,(r-l)/P,M);if(b&&this.addSegment(i,b,g),w)break;g=!1}}else{if(l+P>_){const x=this.cut(e,d,0,(_-l)/P);x&&this.addSegment(i,x,g);break}this.addSegment(i,[e[d],e[d+1]],g)}l+=P,++d}else++d}return!0}getCIMPointAlong(i,e){const r=i?i.length-1:0;let _=0,c=-1;for(;c<r;){++c;const l=this.calculateSegLength(i,c);if(0!==l){if(_+l>e)return this.getCoord2D(i[c],i[c+1],(e-_)/l);_+=l}}return null}isEmpty(i,e){if(!i||i.length<=1)return!0;const r=i?i.length-1:0;let _=-1;for(;_<r;)if(++_,i[_+1][0]!==i[_][0]||i[_+1][1]!==i[_][1]||e&&i[_+1][2]!==i[_][2])return!1;return!0}offset(i,e,r,_,c){if(!i||i.length<2)return null;let l=0,g=i[l++],d=l;for(;l<i.length;){const w=i[l];w[0]===g[0]&&w[1]===g[1]||(l!==d&&(i[d]=i[l]),g=i[d++]),l++}const P=i[0][0]===i[d-1][0]&&i[0][1]===i[d-1][1];if(P&&--d,d<(P?3:2))return null;const x=[];g=P?i[d-1]:null;let M=i[0];for(let w=0;w<d;w++){const b=w===d-1?P?i[0]:null:i[w+1];if(g)if(b){const v=[b[0]-M[0],b[1]-M[1]];this.normalize(v);const A=[M[0]-g[0],M[1]-g[1]];this.normalize(A);const H=A[0]*v[1]-A[1]*v[0],nt=A[0]*v[0]+A[1]*v[1];if(0===H&&1===nt){M=b;continue}if(H>=0==e<=0){if(nt<1){const lt=[v[0]-A[0],v[1]-A[1]];this.normalize(lt);const rt=Math.sqrt((1+nt)/2);if(rt>1/_){const ct=-Math.abs(e)/rt;x.push([M[0]-lt[0]*ct,M[1]-lt[1]*ct])}}}else switch(r){case L.id.Mitered:{const lt=Math.sqrt((1+nt)/2);if(lt>0&&1/lt<_){const rt=[v[0]-A[0],v[1]-A[1]];this.normalize(rt);const ct=Math.abs(e)/lt;x.push([M[0]-rt[0]*ct,M[1]-rt[1]*ct]);break}}case L.id.Bevelled:x.push([M[0]+A[1]*e,M[1]-A[0]*e]),x.push([M[0]+v[1]*e,M[1]-v[0]*e]);break;case L.id.Rounded:if(nt<1){x.push([M[0]+A[1]*e,M[1]-A[0]*e]);const lt=Math.floor(2.5*(1-nt));if(lt>0){const rt=1/lt;let ct=rt;for(let Yt=1;Yt<lt;Yt++,ct+=rt){const Ht=[A[1]*(1-ct)+v[1]*ct,-A[0]*(1-ct)-v[0]*ct];this.normalize(Ht),x.push([M[0]+Ht[0]*e,M[1]+Ht[1]*e])}}x.push([M[0]+v[1]*e,M[1]-v[0]*e])}break;default:if(H<0)x.push([M[0]+(A[1]+A[0])*e,M[1]+(A[1]-A[0])*e]),x.push([M[0]+(v[1]-v[0])*e,M[1]-(v[0]+v[1])*e]);else{const lt=Math.sqrt((1+Math.abs(nt))/2),rt=[v[0]-A[0],v[1]-A[1]];this.normalize(rt);const ct=e/lt;x.push([M[0]-rt[0]*ct,M[1]-rt[1]*ct])}}}else{const v=[M[0]-g[0],M[1]-g[1]];this.normalize(v),x.push([M[0]+v[1]*e,M[1]-v[0]*e])}else{const v=[b[0]-M[0],b[1]-M[1]];this.normalize(v),x.push([M[0]+v[1]*e,M[1]-v[0]*e])}g=M,M=b}return x.length<(P?3:2)?null:(P&&x.push([x[0][0],x[0][1]]),x)}}const X=1.7320508075688772,at=L.TF.OpenEnded;let ut=(()=>{class a{static local(){return null===a.instance&&(a.instance=new a),a.instance}execute(e,r,_,c){return new _t(e,r,_)}}return a.instance=null,a})();class _t extends Q.zY{constructor(i,e,r){super(i,!1,!0),this._curveHelper=new Y,this._width=(void 0!==e.width?e.width:5)*r,this._arrowType=void 0!==e.geometricEffectArrowType?e.geometricEffectArrowType:void 0!==e.arrowType?e.arrowType:at,this._offsetFlattenError=mt*r}processPath(i){switch(this._arrowType){case L.TF.OpenEnded:default:return this._constructSimpleArrow(i,!0);case L.TF.Block:return this._constructSimpleArrow(i,!1);case L.TF.Crossed:return this._constructCrossedArrow(i)}}_constructSimpleArrow(i,e){const r=this._curveHelper.calculatePathLength(i);let _=this._width;r<2*_&&(_=r/2);const c=this._curveHelper.getSubCurve(i,0,r-_);if(!c)return null;const l=_/2;if(this._curveHelper.isEmpty(c,!1))return null;const g=this._constructOffset(c,-l);if(!g)return null;const d=this._constructOffset(c,l);if(!d)return null;const P=this._constructArrowBasePoint(g,-l/2);if(!P)return null;const x=this._constructArrowBasePoint(d,l/2);if(!x)return null;const M=i[i.length-1];e||(this._makeControlPoint(d,!0),this._makeControlPoint(g,!0));const w=new V;return w.addPath(d,!0),w.lineTo(x),this._makeControlPoint(w.path()),w.lineTo(M),this._makeControlPoint(w.path()),w.lineTo(P),this._makeControlPoint(w.path()),w.addPath(g,!1),e?{paths:[w.path()]}:(w.close(),{rings:[w.path()]})}_constructCrossedArrow(i){const e=this._curveHelper.calculatePathLength(i);let r=this._width;e<r*(1+X+1)&&(r=e/(1+X+1));const _=this._curveHelper.getSubCurve(i,0,e-r*(1+X));if(!_)return null;const c=r/2;if(this._curveHelper.isEmpty(_,!1))return null;const l=this._constructOffset(_,c);if(!l)return null;const g=this._constructOffset(_,-c);if(!g)return null;const d=this._curveHelper.getSubCurve(i,0,e-r);if(!d||this._curveHelper.isEmpty(d,!1))return null;const P=this._constructOffset(d,c);if(!P)return null;const x=this._constructOffset(d,-c);if(!x)return null;const M=P[P.length-1],w=this._constructArrowBasePoint(P,c/2);if(!w)return null;const b=x[x.length-1],v=this._constructArrowBasePoint(x,-c/2);if(!v)return null;const A=i[i.length-1];this._makeControlPoint(l,!1),this._makeControlPoint(g,!1);const H=new V;return H.addPath(l,!0),this._makeControlPoint(H.path()),H.lineTo(b),H.lineTo(v),this._makeControlPoint(H.path()),H.lineTo(A),this._makeControlPoint(H.path()),H.lineTo(w),this._makeControlPoint(H.path()),H.lineTo(M),this._makeControlPoint(H.path()),H.addPath(g,!1),{paths:[H.path()]}}_constructOffset(i,e){return this._curveHelper.offset(i,e,L.id.Rounded,4,this._offsetFlattenError)}_constructArrowBasePoint(i,e){if(!i||i.length<2)return null;const r=i[i.length-2],_=i[i.length-1],c=[_[0]-r[0],_[1]-r[1]];return this._curveHelper.normalize(c),[_[0]+c[1]*e,_[1]-c[0]*e]}_makeControlPoint(i,e=!1){(0,Q.qh)(e?i[0]:i[i.length-1],1)}}let st=(()=>{class a{static local(){return null===a.instance&&(a.instance=new a),a.instance}execute(e,r,_,c){return new Mt(e,r,_,c)}}return a.instance=null,a})();class Mt{constructor(i,e,r,_){this._inputGeometries=i,this._curveHelper=new Y,this._size=(void 0!==e.size?e.size:1)*r,this._offsetFlattenError=mt*r}next(){let i=this._inputGeometries.next();for(;i;){if((0,B.YX)(i))if(this._size>0){const r=this._curveHelper.offset([[i.xmin,i.ymin],[i.xmin,i.ymax],[i.xmax,i.ymax],[i.xmax,i.ymin],[i.xmin,i.ymin]],this._size,L.id.Rounded,4,this._offsetFlattenError);if(r)return{rings:[r]}}else{if(!(this._size<0))return i;if(Math.min(i.xmax-i.xmin,i.ymax-i.ymin)+2*this._size>0)return{xmin:i.xmin-this._size,xmax:i.xmax+this._size,ymin:i.ymin-this._size,ymax:i.ymax+this._size}}if((0,B.oU)(i)){if(0===this._size)return i;const e=[];for(const r of i.rings){const _=this._curveHelper.offset(r,this._size,L.id.Rounded,4,this._offsetFlattenError);_&&e.push(_)}if(e.length)return{rings:e}}if((0,B.l9)(i)&&this._size>0){const e=[];for(const r of i.paths)if(r&&r.length>1){const _=this._curveHelper.offset(r,this._size,L.id.Rounded,4,this._offsetFlattenError),c=this._curveHelper.offset(r,-this._size,L.id.Rounded,4,this._offsetFlattenError);if(_&&c){for(let l=c.length-1;l>=0;l--)_.push(c[l]);_.push([_[0][0],_[0][1]]),e.push(_)}}if(e.length)return{rings:e}}(0,B.wp)(i),i=this._inputGeometries.next()}return null}}let gt=(()=>{class a{static local(){return null===a.instance&&(a.instance=new a),a.instance}execute(e,r,_,c){return new Lt(e,r,_)}}return a.instance=null,a})();class Lt{constructor(i,e,r){this._default_point_size=20,this._inputGeometries=i,this._geomUnitsPerPoint=r,this._rule=e.rule??L.Em.FullGeometry,this._default_size=this._default_point_size*r}next(){let i;for(;i=this._inputGeometries.next();){let e;if((0,B.wp)(i)?e=this._processGeom([[[i.x,i.y]]]):(0,B.aW)(i)?e=this._processGeom([i.points]):(0,B.l9)(i)?e=this._processGeom(i.paths):(0,B.oU)(i)&&(e=this._processGeom(i.rings)),e&&e.length)return{paths:e}}return null}_clone(i){return[i[0],i[1]]}_mid(i,e){return[(i[0]+e[0])/2,(i[1]+e[1])/2]}_mix(i,e,r,_){return[i[0]*e+r[0]*_,i[1]*e+r[1]*_]}_add(i,e){return[i[0]+e[0],i[1]+e[1]]}_add2(i,e,r){return[i[0]+e,i[1]+r]}_sub(i,e){return[i[0]-e[0],i[1]-e[1]]}_dist(i,e){return Math.sqrt((i[0]-e[0])*(i[0]-e[0])+(i[1]-e[1])*(i[1]-e[1]))}_norm(i){return Math.sqrt(i[0]*i[0]+i[1]*i[1])}_normalize(i,e=1){const r=e/this._norm(i);i[0]*=r,i[1]*=r}_leftPerpendicular(i){const r=i[0];i[0]=-i[1],i[1]=r}_leftPerp(i){return[-i[1],i[0]]}_rightPerpendicular(i){const r=-i[0];i[0]=i[1],i[1]=r}_rightPerp(i){return[i[1],-i[0]]}_dotProduct(i,e){return i[0]*e[0]+i[1]*e[1]}_crossProduct(i,e){return i[0]*e[1]-i[1]*e[0]}_rotateDirect(i,e,r){const c=i[0]*r+i[1]*e;i[0]=i[0]*e-i[1]*r,i[1]=c}_makeCtrlPt(i){const e=[i[0],i[1]];return(0,Q.qh)(e,1),e}_addAngledTicks(i,e,r,_){const c=this._sub(r,e);this._normalize(c);const l=this._crossProduct(c,this._sub(_,e));let g;g=l>0?this._rightPerp(c):this._leftPerp(c);const d=Math.abs(l)/2,P=[];P.push([e[0]+(g[0]-c[0])*d,e[1]+(g[1]-c[1])*d]),P.push(e),P.push(r),P.push([r[0]+(g[0]+c[0])*d,r[1]+(g[1]+c[1])*d]),i.push(P)}_addBezier2(i,e,r,_,c){if(0==c--)return void i.push(_);const l=this._mid(e,r),g=this._mid(r,_),d=this._mid(l,g);this._addBezier2(i,e,l,d,c),this._addBezier2(i,d,g,_,c)}_addBezier3(i,e,r,_,c,l){if(0==l--)return void i.push(c);const g=this._mid(e,r),d=this._mid(r,_),P=this._mid(_,c),x=this._mid(g,d),M=this._mid(d,P),w=this._mid(x,M);this._addBezier3(i,e,g,x,w,l),this._addBezier3(i,w,M,P,c,l)}_add90DegArc(i,e,r,_,c){const l=c??this._crossProduct(this._sub(r,e),this._sub(_,e))>0,g=this._mid(e,r),d=this._sub(g,e);l?this._leftPerpendicular(d):this._rightPerpendicular(d),g[0]+=d[0],g[1]+=d[1],this._addBezier3(i,e,this._mix(e,.33333,g,.66667),this._mix(r,.33333,g,.66667),r,4)}_addArrow(i,e,r){const _=e[0],c=e[1],l=e[e.length-1],g=this._sub(_,c);this._normalize(g);const d=this._crossProduct(g,this._sub(l,c)),P=.5*d,x=this._leftPerp(g),M=[l[0]-x[0]*d,l[1]-x[1]*d],w=e.length-1,b=[];b.push(r?[-x[0],-x[1]]:x);let v=[-g[0],-g[1]];for(let A=1;A<w-1;A++){const H=this._sub(e[A+1],e[A]);this._normalize(H);const nt=this._dotProduct(H,v),lt=this._crossProduct(H,v),rt=Math.sqrt((1+nt)/2),ct=this._sub(H,v);this._normalize(ct),ct[0]/=rt,ct[1]/=rt,b.push(lt<0?[-ct[0],-ct[1]]:ct),v=H}b.push(this._rightPerp(v));for(let A=b.length-1;A>0;A--)i.push([e[A][0]+b[A][0]*P,e[A][1]+b[A][1]*P]);i.push([M[0]+b[0][0]*P,M[1]+b[0][1]*P]),i.push([M[0]+b[0][0]*d,M[1]+b[0][1]*d]),i.push(_),i.push([M[0]-b[0][0]*d,M[1]-b[0][1]*d]),i.push([M[0]-b[0][0]*P,M[1]-b[0][1]*P]);for(let A=1;A<b.length;A++)i.push([e[A][0]-b[A][0]*P,e[A][1]-b[A][1]*P])}_cp2(i,e,r){return i.length>=2?i[1]:this._add2(i[0],e*this._default_size,r*this._default_size)}_cp3(i,e,r,_){if(i.length>=3)return i[2];const c=this._mix(i[0],1-r,e,r),l=this._sub(e,i[0]);return this._normalize(l),this._rightPerpendicular(l),[c[0]+l[0]*_*this._default_size,c[1]+l[1]*_*this._default_size]}_arrowPath(i){if(i.length>2)return i;const e=i[0],r=this._cp2(i,-4,0),_=this._sub(e,r);this._normalize(_);const c=this._rightPerp(_);return[e,r,[e[0]+(c[0]-_[0])*this._default_size,e[1]+(c[1]-_[1])*this._default_size]]}_arrowLastSeg(i){const e=i[0],r=this._cp2(i,-4,0);let _;if(i.length>=3)_=i[i.length-1];else{const c=this._sub(e,r);this._normalize(c);const l=this._rightPerp(c);_=[e[0]+(l[0]-c[0])*this._default_size,e[1]+(l[1]-c[1])*this._default_size]}return[r,_]}_processGeom(i){if(!i)return null;const e=[];for(const r of i){if(!r||0===r.length)continue;const _=r.length;let c=r[0];switch(this._rule){case L.Em.PerpendicularFromFirstSegment:{const l=this._cp2(r,0,-1),g=this._cp3(r,l,.5,4),d=[];d.push(g),d.push(this._mid(c,l)),e.push(d);break}case L.Em.ReversedFirstSegment:{const l=this._cp2(r,0,-1);e.push([l,c]);break}case L.Em.PerpendicularToSecondSegment:{const l=this._cp2(r,-4,1),g=this._cp3(r,l,.882353,-1.94),d=[];d.push(this._mid(l,g)),d.push(c),e.push(d);break}case L.Em.SecondSegmentWithTicks:{const l=this._cp2(r,-4,1),g=this._cp3(r,l,.882353,-1.94),d=this._sub(g,l);let P;P=this._crossProduct(d,this._sub(c,l))>0?this._rightPerp(P):this._leftPerp(d);const x=[];x.push([l[0]+(P[0]-d[0])/3,l[1]+(P[1]-d[1])/3]),x.push(l),x.push(g),x.push([g[0]+(P[0]+d[0])/3,g[1]+(P[1]+d[1])/3]),e.push(x);break}case L.Em.DoublePerpendicular:{const l=this._cp2(r,0,-1),g=this._cp3(r,l,.5,3),d=this._mid(c,l),P=this._sub(d,g);this._normalize(P);const x=this._crossProduct(P,this._sub(c,g));this._leftPerpendicular(P);const M=[];M.push(c),M.push([g[0]+P[0]*x,g[1]+P[1]*x]),e.push(M);const w=[];w.push([g[0]-P[0]*x,g[1]-P[1]*x]),w.push(l),e.push(w);break}case L.Em.OppositeToFirstSegment:{const l=this._cp2(r,0,-1),g=this._cp3(r,l,.5,3),d=this._mid(c,l),P=this._sub(d,g);this._normalize(P);const x=this._crossProduct(P,this._sub(c,g));this._leftPerpendicular(P);const M=[];M.push([g[0]+P[0]*x,g[1]+P[1]*x]),M.push([g[0]-P[0]*x,g[1]-P[1]*x]),e.push(M);break}case L.Em.TriplePerpendicular:{const l=this._cp2(r,0,-1),g=this._cp3(r,l,.5,4),d=this._mid(c,l),P=this._sub(d,g);this._normalize(P);const x=this._crossProduct(P,this._sub(c,g));this._leftPerpendicular(P);const M=[];M.push([g[0]+P[0]*x*.8,g[1]+P[1]*x*.8]),M.push([d[0]+.8*(c[0]-d[0]),d[1]+.8*(c[1]-d[1])]),e.push(M),e.push([g,d]);const w=[];w.push([g[0]-P[0]*x*.8,g[1]-P[1]*x*.8]),w.push([d[0]+.8*(l[0]-d[0]),d[1]+.8*(l[1]-d[1])]),e.push(w);break}case L.Em.HalfCircleFirstSegment:{const l=this._cp2(r,0,-1),g=this._cp3(r,l,.5,4),d=this._mid(c,l);let P=this._sub(l,c);const x=Math.cos(Math.PI/18),M=Math.sin(Math.PI/18),w=Math.sqrt((1+x)/2),b=Math.sqrt((1-x)/2),v=[];let A;this._crossProduct(P,this._sub(g,c))>0?(v.push(c),P=this._sub(c,d),A=l):(v.push(l),P=this._sub(l,d),A=c),this._rotateDirect(P,w,b),P[0]/=w,P[1]/=w;for(let H=1;H<=18;H++)v.push(this._add(d,P)),this._rotateDirect(P,x,M);v.push(A),e.push(v);break}case L.Em.HalfCircleSecondSegment:{const l=this._cp2(r,0,-1),g=this._cp3(r,l,1,-1);let d=this._sub(c,l);this._normalize(d);const P=this._crossProduct(d,this._sub(g,l))/2;this._leftPerpendicular(d);const x=[l[0]+d[0]*P,l[1]+d[1]*P];d=this._sub(l,x);const M=Math.cos(Math.PI/18);let w=Math.sin(Math.PI/18);P>0&&(w=-w);const b=[l];for(let v=1;v<=18;v++)this._rotateDirect(d,M,w),b.push(this._add(x,d));e.push(b);break}case L.Em.HalfCircleExtended:{const l=this._cp2(r,0,-2),g=this._cp3(r,l,1,-1);let d;if(_>=4)d=r[3];else{const v=this._sub(c,l);d=this._add(g,v)}const P=this._dist(l,g)/2/.75,x=this._sub(l,c);this._normalize(x,P);const M=this._sub(g,d);this._normalize(M,P),e.push([d,g]);const b=[this._clone(g)];this._addBezier3(b,g,this._add(g,M),this._add(l,x),l,4),b.push(c),e.push(b);break}case L.Em.OpenCircle:{const l=this._cp2(r,-2,0),g=this._sub(l,c),d=Math.cos(Math.PI/18),P=-Math.sin(Math.PI/18),x=[l];for(let M=1;M<=33;M++)this._rotateDirect(g,d,P),x.push(this._add(c,g));e.push(x);break}case L.Em.CoverageEdgesWithTicks:{const l=this._cp2(r,0,-1);let g,d;if(_>=3)g=r[2];else{const w=this._sub(l,c),b=this._leftPerp(w);g=[c[0]+b[0]-.25*w[0],c[1]+b[1]-.25*w[1]]}if(_>=4)d=r[3];else{const w=this._mid(c,l),b=this._sub(c,l);this._normalize(b),this._leftPerpendicular(b);const v=this._crossProduct(b,this._sub(g,w));this._rightPerpendicular(b),d=[g[0]+b[0]*v*2,g[1]+b[1]*v*2]}const P=this._sub(l,c);let x,M;x=this._crossProduct(P,this._sub(g,c))>0?this._rightPerp(P):this._leftPerp(P),M=[],M.push(g),M.push(c),M.push([c[0]+(x[0]-P[0])/3,c[1]+(x[1]-P[1])/3]),e.push(M),x=this._crossProduct(P,this._sub(d,l))>0?this._rightPerp(x):this._leftPerp(P),M=[],M.push([l[0]+(x[0]+P[0])/3,l[1]+(x[1]+P[1])/3]),M.push(l),M.push(d),e.push(M);break}case L.Em.GapExtentWithDoubleTicks:{const l=this._cp2(r,0,2),g=this._cp3(r,l,0,1);let d;if(_>=4)d=r[3];else{const P=this._sub(l,c);d=this._add(g,P)}this._addAngledTicks(e,c,l,this._mid(g,d)),this._addAngledTicks(e,g,d,this._mid(c,l));break}case L.Em.GapExtentMidline:{const l=this._cp2(r,2,0),g=this._cp3(r,l,0,1);let d;if(_>=4)d=r[3];else{const x=this._sub(l,c);d=this._add(g,x)}const P=[];P.push(this._mid(c,g)),P.push(this._mid(l,d)),e.push(P);break}case L.Em.Chevron:{const l=this._cp2(r,-1,-1);let g;if(_>=3)g=r[2];else{const d=this._sub(l,c);this._leftPerpendicular(d),g=this._add(c,d)}e.push([l,this._makeCtrlPt(c),g]);break}case L.Em.PerpendicularWithArc:{const l=this._cp2(r,0,-2),g=this._cp3(r,l,.5,-1);let d=this._sub(l,c);const P=this._norm(d);d[0]/=P,d[1]/=P;const x=this._crossProduct(d,this._sub(g,c));let M=this._dotProduct(d,this._sub(g,c));M<.05*P?M=.05*P:M>.95*P&&(M=.95*P);const w=[c[0]+d[0]*M,c[1]+d[1]*M];this._leftPerpendicular(d);let b=[];b.push([w[0]-d[0]*x,w[1]-d[1]*x]),b.push([w[0]+d[0]*x,w[1]+d[1]*x]),e.push(b);const v=[l[0]+d[0]*x,l[1]+d[1]*x];d=this._sub(l,v);const A=Math.cos(Math.PI/18);let H=Math.sin(Math.PI/18);x<0&&(H=-H),b=[c,l];for(let nt=1;nt<=9;nt++)this._rotateDirect(d,A,H),b.push(this._add(v,d));e.push(b);break}case L.Em.ClosedHalfCircle:{const l=this._cp2(r,2,0),g=this._mid(c,l),d=this._sub(l,g),P=Math.cos(Math.PI/18),x=Math.sin(Math.PI/18),M=[c,l];for(let w=1;w<=18;w++)this._rotateDirect(d,P,x),M.push(this._add(g,d));e.push(M);break}case L.Em.TripleParallelExtended:{const l=this._cp2(r,0,-2),g=this._cp3(r,l,1,-2),d=this._mid(c,l),P=this._sub(g,l);this._normalize(P);const x=Math.abs(this._crossProduct(P,this._sub(d,l)))/2,M=this._dist(l,g),w=[l,c];w.push([c[0]+P[0]*M*.5,c[1]+P[1]*M*.5]),e.push(w);const b=[];b.push([d[0]-P[0]*x,d[1]-P[1]*x]),b.push([d[0]+P[0]*M*.375,d[1]+P[1]*M*.375]),(0,Q.qh)(b[b.length-1],1),b.push([d[0]+P[0]*M*.75,d[1]+P[1]*M*.75]),e.push(b),e.push([l,g]);break}case L.Em.ParallelWithTicks:{const l=this._cp2(r,3,0),g=this._cp3(r,l,.5,-1),d=this._sub(g,l);this._normalize(d);const P=this._crossProduct(d,this._sub(g,c));this._leftPerpendicular(d),this._addAngledTicks(e,c,l,g),this._addAngledTicks(e,this._mix(c,1,d,P),this._mix(l,1,d,P),this._mid(c,l));break}case L.Em.Parallel:{const l=this._cp2(r,3,0),g=this._cp3(r,l,.5,-1),d=this._sub(l,c);this._normalize(d);const P=this._leftPerp(d),x=this._crossProduct(d,this._sub(g,c));let M=[c,l];e.push(M),M=[],M.push([c[0]+P[0]*x,c[1]+P[1]*x]),M.push([l[0]+P[0]*x,l[1]+P[1]*x]),e.push(M);break}case L.Em.PerpendicularToFirstSegment:{const l=this._cp2(r,3,0),g=this._cp3(r,l,.5,-1),d=this._mid(c,l),P=this._sub(l,c);this._normalize(P);const x=this._crossProduct(P,this._sub(g,c));this._leftPerpendicular(P);const M=[];M.push([d[0]-P[0]*x*.25,d[1]-P[1]*x*.25]),M.push([d[0]+P[0]*x*1.25,d[1]+P[1]*x*1.25]),e.push(M);break}case L.Em.ParallelOffset:{const l=this._cp2(r,3,0),g=this._cp3(r,l,.5,-1),d=this._sub(l,c);this._normalize(d);const P=this._crossProduct(d,this._sub(g,c));this._leftPerpendicular(d);const x=[];x.push([c[0]-d[0]*P,c[1]-d[1]*P]),x.push([l[0]-d[0]*P,l[1]-d[1]*P]),e.push(x);const M=[];M.push([c[0]+d[0]*P,c[1]+d[1]*P]),M.push([l[0]+d[0]*P,l[1]+d[1]*P]),e.push(M);break}case L.Em.OffsetOpposite:{const l=this._cp2(r,3,0),g=this._cp3(r,l,.5,-1),d=this._sub(l,c);this._normalize(d);const P=this._crossProduct(d,this._sub(g,c));this._leftPerpendicular(d);const x=[];x.push([c[0]-d[0]*P,c[1]-d[1]*P]),x.push([l[0]-d[0]*P,l[1]-d[1]*P]),e.push(x);break}case L.Em.OffsetSame:{const l=this._cp2(r,3,0),g=this._cp3(r,l,.5,-1),d=this._sub(l,c);this._normalize(d);const P=this._crossProduct(d,this._sub(g,c));this._leftPerpendicular(d);const x=[];x.push([c[0]+d[0]*P,c[1]+d[1]*P]),x.push([l[0]+d[0]*P,l[1]+d[1]*P]),e.push(x);break}case L.Em.CircleWithArc:{let l=this._cp2(r,3,0);const g=this._cp3(r,l,.5,-1);let d,P;if(_>=4)d=r[3],P=this._crossProduct(this._sub(d,l),this._sub(g,l))>0;else{d=l,P=this._crossProduct(this._sub(d,c),this._sub(g,c))>0;const v=24*this._geomUnitsPerPoint,A=this._sub(d,c);this._normalize(A,v);const H=Math.sqrt(2)/2;this._rotateDirect(A,H,P?H:-H),l=this._add(c,A)}const x=this._sub(l,c),M=Math.cos(Math.PI/18),w=Math.sin(Math.PI/18),b=[l];for(let v=1;v<=36;v++)this._rotateDirect(x,M,w),b.push(this._add(c,x));this._add90DegArc(b,l,d,g,P),(0,Q.qh)(b[b.length-8],1),e.push(b);break}case L.Em.DoubleJog:{let l,g,d=this._cp2(r,-3,1);if(l=_>=3?r[2]:this._add(c,this._sub(c,d)),_>=4)g=r[3];else{const nt=c;c=d,g=l;const lt=this._dist(c,nt),rt=this._dist(g,nt);let ct=30*this._geomUnitsPerPoint;.5*lt<ct&&(ct=.5*lt),.5*rt<ct&&(ct=.5*rt),d=this._mix(c,ct/lt,nt,(lt-ct)/lt),l=this._mix(g,ct/rt,nt,(rt-ct)/rt)}const P=this._mid(c,d),x=this._mid(g,l),M=this._dist(c,d),w=this._dist(l,g);let b=Math.min(M,w)/8;b=Math.min(b,24*this._geomUnitsPerPoint);const v=Math.cos(Math.PI/4);let A=this._sub(c,d);this._normalize(A,b),this._crossProduct(A,this._sub(g,d))>0?this._rotateDirect(A,v,-v):this._rotateDirect(A,v,v);let H=[];H.push(d),H.push(this._add(P,A)),H.push(this._sub(P,A)),H.push(c),e.push(H),A=this._sub(g,l),this._normalize(A,b),this._crossProduct(A,this._sub(c,l))<0?this._rotateDirect(A,v,v):this._rotateDirect(A,v,-v),H=[],H.push(l),H.push(this._add(x,A)),H.push(this._sub(x,A)),H.push(g),e.push(H);break}case L.Em.PerpendicularOffset:{const l=this._cp2(r,-4,1),g=this._cp3(r,l,.882353,-1.94),d=this._sub(g,l);this._crossProduct(d,this._sub(c,l))>0?this._rightPerpendicular(d):this._leftPerpendicular(d);const P=[d[0]/8,d[1]/8],x=this._sub(this._mid(l,g),P);e.push([x,c]);break}case L.Em.LineExcludingLastSegment:{const l=this._arrowPath(r),g=[];let d=l.length-2;for(;d--;)g.push(l[d]);e.push(g);break}case L.Em.MultivertexArrow:{const l=this._arrowPath(r),g=[];this._addArrow(g,l,!1),e.push(g);break}case L.Em.CrossedArrow:{const l=this._arrowPath(r),g=[];this._addArrow(g,l,!0),e.push(g);break}case L.Em.ChevronArrow:{const[l,g]=this._arrowLastSeg(r),d=10*this._geomUnitsPerPoint,P=this._sub(c,l);this._normalize(P);const x=this._crossProduct(P,this._sub(g,l)),M=this._leftPerp(P),w=[g[0]-M[0]*x*2,g[1]-M[1]*x*2],b=[];b.push([g[0]+P[0]*d,g[1]+P[1]*d]),b.push(c),b.push([w[0]+P[0]*d,w[1]+P[1]*d]),e.push(b);break}case L.Em.ChevronArrowOffset:{const[l,g]=this._arrowLastSeg(r),d=this._sub(c,l);this._normalize(d);const P=this._crossProduct(d,this._sub(g,l));this._leftPerpendicular(d);const x=[g[0]-d[0]*P,g[1]-d[1]*P],M=[];M.push([x[0]+d[0]*P*.5,x[1]+d[1]*P*.5]),M.push(this._mid(x,c)),M.push([x[0]-d[0]*P*.5,x[1]-d[1]*P*.5]),e.push(M);break}case L.Em.PartialFirstSegment:{const[l,g]=this._arrowLastSeg(r),d=this._sub(c,l);this._normalize(d);const P=this._crossProduct(d,this._sub(g,l));this._leftPerpendicular(d),e.push([l,[g[0]-d[0]*P,g[1]-d[1]*P]]);break}case L.Em.Arch:{const l=this._cp2(r,0,-1),g=this._cp3(r,l,.5,1),d=this._sub(c,l),P=this._mix(g,1,d,.55),x=this._mix(g,1,d,-.55),M=[c];this._addBezier2(M,c,P,g,4),this._addBezier2(M,g,x,l,4),e.push(M);break}case L.Em.CurvedParallelTicks:{const l=this._cp2(r,-4,1),g=this._cp3(r,l,.882353,-1.94),d=this._sub(g,l);this._crossProduct(d,this._sub(c,l))>0?this._rightPerpendicular(d):this._leftPerpendicular(d);const P=[d[0]/8,d[1]/8],x=this._sub(this._mid(l,g),P),M=this._sub(this._mix(l,.75,g,.25),P),w=this._sub(this._mix(l,.25,g,.75),P),b=[l];this._addBezier2(b,l,M,x,3),this._addBezier2(b,x,w,g,3),e.push(b);for(let v=0;v<8;v++){const A=b[2*v+1],H=[this._clone(A)];H.push(this._add(A,[d[0]/4,d[1]/4])),e.push(H)}break}case L.Em.Arc90Degrees:{const l=this._cp2(r,0,-1),g=this._cp3(r,l,.5,1),d=[l];this._add90DegArc(d,l,c,g),e.push(d);break}default:e.push(r)}}return e}}let et=(()=>{class a{static local(){return null===a.instance&&(a.instance=new a),a.instance}execute(e,r,_,c){return new Tt(e,r,_)}}return a.instance=null,a})();class Tt extends Q.zY{constructor(i,e,r){super(i,!0,!0),this._curveHelper=new Y,this._beginCut=(void 0!==e.beginCut?e.beginCut:1)*r,this._endCut=(void 0!==e.endCut?e.endCut:1)*r,this._middleCut=(void 0!==e.middleCut?e.middleCut:0)*r,this._invert=void 0!==e.invert&&e.invert,this._beginCut<0&&(this._beginCut=0),this._endCut<0&&(this._endCut=0),this._middleCut<0&&(this._middleCut=0)}processPath(i){const e=this._beginCut,r=this._endCut,_=this._middleCut,c=this._curveHelper.calculatePathLength(i),l=[];if(this._invert){if(0!==e||0!==r||0!==_)if(e+r+_>=c)l.push(i);else{let g=this._curveHelper.getSubCurve(i,0,e);g&&l.push(g),g=this._curveHelper.getSubCurve(i,.5*(c-_),.5*(c+_)),g&&l.push(g),g=this._curveHelper.getSubCurve(i,c-r,r),g&&l.push(g)}}else if(0===e&&0===r&&0===_)l.push(i);else if(!(e+r+_>=c))if(0===_){const g=this._curveHelper.getSubCurve(i,e,c-r);g&&l.push(g)}else{let g=this._curveHelper.getSubCurve(i,e,.5*(c-_));g&&l.push(g),g=this._curveHelper.getSubCurve(i,.5*(c+_),c-r),g&&l.push(g)}return 0===l.length?null:{paths:l}}}class kt{constructor(){this._values=[],this.extPtGap=0,this.ctrlPtGap=0,this._length=0,this._currentValue=0}isEmpty(){return 0===this._values.length}size(){return this._values.length}init(i,e,r=!0){if(this._setEmpty(),!i||0===i.length)return!1;for(let _=0;_<i.length;_++){let c=Math.abs(i[_]);r&&c<1e-7&&(c=1e-7),this._values.push(c),this._length+=c}return e&&1&i.length&&(this._length*=2),0!==this._length&&(this.ctrlPtGap=this.extPtGap=0,this._currentValue=-1,!0)}scale(i){const e=this._values?this._values.length:0;for(let r=0;r<e;++r)this._values[r]*=i;this._length*=i,this.extPtGap*=i,this.ctrlPtGap*=i}addValue(i){this._length+=i,this._values.push(i)}firstValue(){return this._values[0]}lastValue(){return this._values[this._values.length-1]}nextValue(){return this._currentValue++,this._currentValue===this._values.length&&(this._currentValue=0),this._values[this._currentValue]}reset(){this._currentValue=-1}length(){return this._length}_setEmpty(){this.extPtGap=this.ctrlPtGap=this._length=0,this._currentValue=-1,this._values.length=0}}var z,a;(a=z||(z={}))[a.FAIL=0]="FAIL",a[a.END=1]="END",a[a.CONTINUE=2]="CONTINUE";class Z{constructor(){this.reset()}reset(){this.segment=-1,this.segmentLength=0,this.abscissa=0,this.isPathEnd=!1,this.isPartEnd=!1}isValid(){return-1!==this.segment}copyTo(i){i.segment=this.segment,i.segmentLength=this.segmentLength,i.abscissa=this.abscissa,i.isPathEnd=this.isPathEnd,i.isPartEnd=this.isPartEnd}}class $ extends Y{constructor(i=0,e=!1){super(i,e),this._tolerance=mt,this._currentPosition=new Z}updateTolerance(i){this._tolerance=mt*i}init(i,e,r=!0){return r?(this._patternLength=e.length(),this._partExtPtGap=e.extPtGap,this._partCtrlPtGap=e.ctrlPtGap):(this._patternLength=0,this._partExtPtGap=0,this._partCtrlPtGap=0),this._currentPosition.reset(),this._partSegCount=0,this._path=i,this._seg=-1,this._setPosAtNextPart()}curPositionIsValid(){return this._currentPosition.isValid()}nextPosition(i,e=z.FAIL){const r=new Z;return!!this._nextPosition(i,r,null,e)&&(r.copyTo(this._currentPosition),!0)}curPointAndAngle(i){i.pt=this._getPoint(this._currentPosition);const[e,r]=this._getAngle(this._currentPosition);i.ca=e,i.sa=r}nextPointAndAngle(i,e,r=z.FAIL){const _=new Z;if(!this._nextPosition(i,_,null,r))return!1;_.copyTo(this._currentPosition),e.pt=this._getPoint(_);const[c,l]=this._getAngle(_);return e.ca=c,e.sa=l,!0}nextCurve(i){if(0===i)return null;const e=[],r=new Z;return this._nextPosition(i,r,e,z.END)?(r.copyTo(this._currentPosition),e):null}isPathEnd(){return this._currentPosition.isPathEnd}getPathEnd(){if(-1===this._currentPosition.segment)throw new Error("missing segment");return this._path[this._currentPosition.segment+1]}_nextPosition(i,e,r,_){if(this._currentPosition.isPathEnd)return!1;let c=this._currentPosition.abscissa;for(this._currentPosition.segmentLength>0&&(c/=this._currentPosition.segmentLength),this._currentPosition.copyTo(e);e.abscissa+i*this._partLengthRatio>e.segmentLength+this._tolerance;){if(r){if(0===r.length)if(0===c){const g=this._path[e.segment];r.push([g[0],g[1]])}else r.push(this.getSegCoord2D(this._path,e.segment,c));const l=this._path[e.segment+1];r.push([l[0],l[1]])}if(c=0,i-=(e.segmentLength-e.abscissa)/this._partLengthRatio,this._partSegCount)e.segment=this._nextSegment(),e.segmentLength=this.calculateSegLength(this._path,e.segment),e.abscissa=0,this._partSegCount--;else{if(!this._setPosAtNextPart())return _!==z.FAIL&&(e.segmentLength=this.calculateSegLength(this._path,e.segment),e.isPartEnd=!0,_===z.END?(e.abscissa=e.segmentLength,e.isPathEnd=!0):e.abscissa=e.segmentLength+i,!0);this._currentPosition.copyTo(e)}}if(e.abscissa+=i*this._partLengthRatio,r){if(0===r.length)if(0===c){const g=this._path[e.segment];r.push([g[0],g[1]])}else r.push(this.getSegCoord2D(this._path,e.segment,c));const l=e.abscissa/e.segmentLength;if(1===l){const g=this._path[e.segment+1];r.push([g[0],g[1]])}else r.push(this.getSegCoord2D(this._path,e.segment,l))}return this._partSegCount||Math.abs(e.abscissa-e.segmentLength)<this._tolerance&&(e.isPathEnd=this._partIsLast,e.isPartEnd=!0),!0}_getPoint(i){if(-1===i.segment)throw new Error("missing segment");return this.getSegCoord2D(this._path,i.segment,i.segmentLength<=0?0:i.abscissa/i.segmentLength)}_getAngle(i){if(-1===i.segment)throw new Error("missing segment");return this.getSegAngleCS(this._path,i.segment,i.segmentLength<=0?0:i.abscissa/i.segmentLength)}_setPosAtNextPart(){for(;this._partSegCount;)this._hasNextSegment()&&this._nextSegment(),this._partSegCount--;if(!this._hasNextSegment())return!1;for(this._partLength=0,this._partIsLast=!0,this._partSegCount=0;this._hasNextSegment();)if(this._partLength+=this.calculateSegLength(this._path,this._nextSegment()),this._partSegCount++,1===(0,Q.zv)(this._path[this._getEndPointIndex()])){this._partIsLast=!this._hasNextSegment();break}let i=this._partSegCount;for(;i;)this._previousSegment(),--i;this._currentPosition.segment=this._nextSegment(),this._currentPosition.segmentLength=this.calculateSegLength(this._path,this._currentPosition.segment),this._currentPosition.abscissa=0,this._currentPosition.isPathEnd=this._currentPosition.isPartEnd=!1,--this._partSegCount;const e=this._getStartPointIndex();this._ctrlPtBegin=1===(0,Q.zv)(this._path[e]);let r=e+this._partSegCount+1;if(r>=this._path.length&&(r=0),this._ctrlPtEnd=1===(0,Q.zv)(this._path[r]),this._patternLength>0){const _=this._ctrlPtBegin?this._partCtrlPtGap:this._partExtPtGap,c=this._ctrlPtEnd?this._partCtrlPtGap:this._partExtPtGap;let l=Math.round((this._partLength-(_+c))/this._patternLength);l<=0&&(l=_+c>0?0:1),this._partLengthRatio=this._partLength/(_+c+l*this._patternLength),this._partLengthRatio<.01&&(this._partLengthRatio=1)}else this._partLengthRatio=1;return!0}_hasNextSegment(){return this._seg<this._path.length-2}_previousSegment(){return--this._seg}_nextSegment(){return++this._seg}_getStartPointIndex(){return this._seg}_getEndPointIndex(){return this._seg+1}}let F=(()=>{class a{static local(){return null===a.instance&&(a.instance=new a),a.instance}execute(e,r,_,c){return new W(e,r,_)}}return a.instance=null,a})();class W extends Q.zY{constructor(i,e,r){super(i,!0,!0),this._walker=new $,this._walker.updateTolerance(r),this._endings=e.lineDashEnding,this._customDashPos=-(e.offsetAlongLine??0)*r,this._offsetAtEnd=(e.customEndingOffset??0)*r,this._pattern=new kt,this._pattern.init(e.dashTemplate,!0),this._pattern.scale(r)}processPath(i){if(0===this._pattern.length())return this.iteratePath=!1,{paths:[i]};if(!this.iteratePath){let _=!0;switch(this._endings){case L.sj.HalfPattern:case L.sj.HalfGap:default:this._pattern.extPtGap=0;break;case L.sj.FullPattern:this.isClosed||(this._pattern.extPtGap=.5*this._pattern.firstValue());break;case L.sj.FullGap:this.isClosed||(this._pattern.extPtGap=.5*this._pattern.lastValue());break;case L.sj.NoConstraint:this.isClosed||(_=!1);break;case L.sj.Custom:this.isClosed||(this._pattern.extPtGap=.5*this._offsetAtEnd)}const c=this._walker.calculatePathLength(i);if(this._pattern.isEmpty()||c<.1*this._pattern.length())return{paths:[i]};if(!this._walker.init(i,this._pattern,_))return{paths:[i]}}let e;if(this.iteratePath)e=this._pattern.nextValue();else{let _;switch(this._endings){case L.sj.HalfPattern:default:_=.5*this._pattern.firstValue();break;case L.sj.HalfGap:_=.5*-this._pattern.lastValue();break;case L.sj.FullGap:_=-this._pattern.lastValue();break;case L.sj.FullPattern:_=0;break;case L.sj.NoConstraint:case L.sj.Custom:_=-this._customDashPos}let c=_/this._pattern.length();c-=Math.floor(c),_=c*this._pattern.length(),this._pattern.reset(),e=this._pattern.nextValue();let l=!1;for(;_>=e;)_-=e,e=this._pattern.nextValue(),l=!l;e-=_,l?(this._walker.nextPosition(e),e=this._pattern.nextValue()):this.isClosed&&(this._firstCurve=this._walker.nextCurve(e),e=this._pattern.nextValue(),this._walker.nextPosition(e),e=this._pattern.nextValue())}let r=this._walker.nextCurve(e);return r?this._walker.isPathEnd()?(this.iteratePath=!1,this._firstCurve&&(this._firstCurve.splice(0,1),V.mergePath(r,this._firstCurve),this._firstCurve=null)):(e=this._pattern.nextValue(),!this._walker.nextPosition(e)||this._walker.isPathEnd()?(this.iteratePath=!1,this._firstCurve&&(r=this._firstCurve,this._firstCurve=null)):this.iteratePath=!0):(this.iteratePath=!1,r=this._firstCurve,this._firstCurve=null),{paths:[r]}}}let U=(()=>{class a{static local(){return null===a.instance&&(a.instance=new a),a.instance}execute(e,r,_,c){return new J(e,r,_)}}return a.instance=null,a})();class J{constructor(i,e,r){switch(this._inputGeometries=i,this._curveHelper=new Y,this._width=(void 0!==e.width?e.width:2)*r,e.method){case L.$y.Mitered:default:this._method=L.id.Mitered;break;case L.$y.Bevelled:this._method=L.id.Bevelled;break;case L.$y.Rounded:case L.$y.TrueBuffer:this._method=L.id.Rounded;break;case L.$y.Square:this._method=L.id.Square}this._option=e.option,this._offsetFlattenError=mt*r}next(){let i=this._inputGeometries.next();for(;i;){if((0,B.YX)(i)&&this._width>0){if(Math.min(i.xmax-i.xmin,i.ymax-i.ymin)-2*this._width<0)return i;const e=[];return e.push([[i.xmin,i.ymin],[i.xmin,i.ymax],[i.xmax,i.ymax],[i.xmax,i.ymin],[i.xmin,i.ymin]]),e.push([[i.xmin+this._width,i.ymin+this._width],[i.xmax-this._width,i.ymin+this._width],[i.xmax-this._width,i.ymax-this._width],[i.xmin+this._width,i.ymax-this._width],[i.xmin+this._width,i.ymin+this._width]]),{rings:e}}if((0,B.oU)(i)&&this._width>0){const e=[];for(const r of i.rings){const _=this._curveHelper.calculatePathLength(r),c=this._curveHelper.offset(r,this._width,this._method,4,this._offsetFlattenError);c&&(_<0&&c.reverse(),e.push(c))}if(e.length)return{rings:e}}i=this._inputGeometries.next()}return null}}let tt=(()=>{class a{static local(){return null===a.instance&&(a.instance=new a),a.instance}execute(e,r,_,c){return new ft(e,r,_)}}return a.instance=null,a})();class ft extends Q.zY{constructor(i,e,r){super(i,!1,!0),this._curveHelper=new Y,this._length=(void 0!==e.length?e.length:20)*r,this._angle=void 0!==e.angle?e.angle:225,this._position=void 0!==e.position?e.position:50,this._length<0&&(this._length=-this._length),this._position<20&&(this._position=20),this._position>80&&(this._position=80),this._mirror=!1}processPath(i){if(this._curveHelper.isEmpty(i,!1))return null;const e=i[0],r=i[i.length-1];this._curveHelper.normalize([r[0]-e[0],r[1]-e[1]]);const c=[e[0]+(r[0]-e[0])*this._position/100,e[1]+(r[1]-e[1])*this._position/100],l=Math.cos((90-this._angle)/180*Math.PI);let g=Math.sin((90-this._angle)/180*Math.PI);return this._mirror&&(g=-g),this._mirror=!this._mirror,{paths:[[e,[c[0]-this._length/2*l,c[1]-this._length/2*g],[c[0]+this._length/2*l,c[1]+this._length/2*g],r]]}}}let pt=(()=>{class a{static local(){return null===a.instance&&(a.instance=new a),a.instance}execute(e,r,_,c){return new ht(e,r,_)}}return a.instance=null,a})();class ht{constructor(i,e,r){this._inputGeometries=i,this._offsetX=void 0!==e.offsetX?e.offsetX*r:0,this._offsetY=void 0!==e.offsetY?-e.offsetY*r:0}next(){let i=this._inputGeometries.next();for(;i;){if((0,B.YX)(i))return{xmin:i.xmin+this._offsetX,xmax:i.xmax+this._offsetX,ymin:i.ymin+this._offsetY,ymax:i.ymax+this._offsetY};if((0,B.oU)(i)){const e=(0,K.d9)(i);return this._moveMultipath(e.rings,this._offsetX,this._offsetY),e}if((0,B.l9)(i)){const e=(0,K.d9)(i);return this._moveMultipath(e.paths,this._offsetX,this._offsetY),e}if((0,B.aW)(i)){const e=(0,K.d9)(i);return this._movePath(e.points,this._offsetX,this._offsetY),e}if((0,B.wp)(i))return{x:i.x+this._offsetX,y:i.y+this._offsetY};i=this._inputGeometries.next()}return null}_moveMultipath(i,e,r){if(i)for(const _ of i)this._movePath(_,e,r)}_movePath(i,e,r){if(i)for(const _ of i)_[0]+=e,_[1]+=r}}let yt=(()=>{class a{static local(){return null===a.instance&&(a.instance=new a),a.instance}execute(e,r,_,c){return new Pt(e,r,_)}}return a.instance=null,a})();class Pt{constructor(i,e,r){this._inputGeometries=i,this._curveHelper=new Y,this._offset=(e.offset??1)*r,this._method=e.method,this._option=e.option,this._offsetFlattenError=mt*r}next(){let i=this._inputGeometries.next();for(;i;){if(0===this._offset)return i;if((0,B.YX)(i)){if(this._method===L.id.Rounded&&this._offset>0){const r=this._curveHelper.offset([[i.xmin,i.ymin],[i.xmin,i.ymax],[i.xmax,i.ymax],[i.xmax,i.ymin],[i.xmin,i.ymin]],-this._offset,this._method,4,this._offsetFlattenError);return r?{rings:[r]}:null}if(Math.min(i.xmax-i.xmin,i.ymax-i.ymin)+2*this._offset>0)return{xmin:i.xmin-this._offset,xmax:i.xmax+this._offset,ymin:i.ymin-this._offset,ymax:i.ymax+this._offset}}if((0,B.oU)(i)){const e=[];for(const r of i.rings){const _=this._curveHelper.offset(r,-this._offset,this._method,4,this._offsetFlattenError);_&&e.push(_)}if(e.length)return{rings:e}}if((0,B.l9)(i)){const e=[];for(const r of i.paths){const _=this._curveHelper.offset(r,-this._offset,this._method,4,this._offsetFlattenError);_&&e.push(_)}if(e.length)return{paths:e}}i=this._inputGeometries.next()}return null}}let At=(()=>{class a{static local(){return null===a.instance&&(a.instance=new a),a.instance}execute(e,r,_,c){return new ot(e,r,_)}}return a.instance=null,a})();class ot{constructor(i,e,r){this._inputGeometries=i,this._reverse=void 0===e.reverse||e.reverse}next(){let i=this._inputGeometries.next();for(;i;){if(!this._reverse)return i;if((0,B.l9)(i)){const e=(0,K.d9)(i);return(0,Q.ov)(e.paths),e}i=this._inputGeometries.next()}return null}}var zt=j(65401),Ft=j(32442);let Ct=(()=>{class a{static local(){return null===a.instance&&(a.instance=new a),a.instance}execute(e,r,_,c){return new St(e,r,_)}}return a.instance=null,a})();class St{constructor(i,e,r){this._inputGeometries=i,this._rotateAngle=void 0!==e.angle?e.angle*Math.PI/180:0}next(){let i=this._inputGeometries.next();for(;i;){if(0===this._rotateAngle)return i;const e=(0,zt.Ue)();(0,Ft.$P)(e,i);const r=(e[2]+e[0])/2,_=(e[3]+e[1])/2;if((0,B.YX)(i)){const c={rings:[[[i.xmin,i.ymin],[i.xmin,i.ymax],[i.xmax,i.ymax],[i.xmax,i.ymin],[i.xmin,i.ymin]]]};return this._rotateMultipath(c.rings,r,_),c}if((0,B.oU)(i)){const c=(0,K.d9)(i);return this._rotateMultipath(c.rings,r,_),c}if((0,B.l9)(i)){const c=(0,K.d9)(i);return this._rotateMultipath(c.paths,r,_),c}if((0,B.aW)(i)){const c=(0,K.d9)(i);return this._rotatePath(c.points,r,_),c}if((0,B.wp)(i))return i;i=this._inputGeometries.next()}return null}_rotateMultipath(i,e,r){if(i)for(const _ of i)this._rotatePath(_,e,r)}_rotatePath(i,e,r){if(i){const _=Math.cos(this._rotateAngle),c=Math.sin(this._rotateAngle);for(const l of i){const g=l[0]-e,d=l[1]-r;l[0]=e+g*_-d*c,l[1]=r+g*c+d*_}}}}let Gt=(()=>{class a{static local(){return null===a.instance&&(a.instance=new a),a.instance}execute(e,r,_,c){return new bt(e,r,_)}}return a.instance=null,a})();class bt{constructor(i,e,r){this._inputGeometries=i,this._xFactor=void 0!==e.xScaleFactor?e.xScaleFactor:1.15,this._yFactor=void 0!==e.yScaleFactor?e.yScaleFactor:1.15}next(){let i=this._inputGeometries.next();for(;i;){if(1===this._xFactor&&1===this._yFactor)return i;const e=(0,zt.Ue)();(0,Ft.$P)(e,i);const r=(e[2]+e[0])/2,_=(e[3]+e[1])/2;if((0,B.YX)(i)){const c={rings:[[[i.xmin,i.ymin],[i.xmin,i.ymax],[i.xmax,i.ymax],[i.xmax,i.ymin],[i.xmin,i.ymin]]]};return this._scaleMultipath(c.rings,r,_),c}if((0,B.oU)(i)){const c=(0,K.d9)(i);return this._scaleMultipath(c.rings,r,_),c}if((0,B.l9)(i)){const c=(0,K.d9)(i);return this._scaleMultipath(c.paths,r,_),c}if((0,B.aW)(i)){const c=(0,K.d9)(i);return this._scalePath(c.points,r,_),c}if((0,B.wp)(i))return i;i=this._inputGeometries.next()}return null}_scaleMultipath(i,e,r){if(i)for(const _ of i)this._scalePath(_,e,r)}_scalePath(i,e,r){if(i)for(const _ of i){const l=(_[1]-r)*this._yFactor;_[0]=e+(_[0]-e)*this._xFactor,_[1]=r+l}}}let wt=(()=>{class a{static local(){return null===a.instance&&(a.instance=new a),a.instance}execute(e,r,_,c){return new Ot(e,r,_)}}return a.instance=null,a})();class Ot{constructor(i,e,r){this._inputGeometries=i,this._height=(void 0!==e.amplitude?e.amplitude:2)*r,this._period=(void 0!==e.period?e.period:3)*r,this._style=e.waveform,this._height<=0&&(this._height=Math.abs(this._height)),this._period<=0&&(this._period=Math.abs(this._period)),this._pattern=new kt,this._pattern.addValue(this._period),this._pattern.addValue(this._period),this._walker=new $,this._walker.updateTolerance(r)}next(){let i=this._inputGeometries.next();for(;i;){if(0===this._height||0===this._period)return i;if((0,B.l9)(i)){const e=this._processGeom(i.paths);if(e.length)return{paths:e}}if((0,B.oU)(i)){const e=this._processGeom(i.rings);if(e.length)return{rings:e}}i=this._inputGeometries.next()}return null}_processGeom(i){const e=[];for(const r of i)if(this._walker.init(r,this._pattern))switch(this._style){case L.zQ.Sinus:default:e.push(this._constructCurve(r,!1));break;case L.zQ.Square:e.push(this._constructSquare(r));break;case L.zQ.Triangle:e.push(this._constructTriangle(r));break;case L.zQ.Random:e.push(this._constructCurve(r,!0))}else e.push(r);return e}_constructCurve(i,e){const r=new V,_=this._walker.calculatePathLength(i);let c=Math.round(_/this._period);0===c&&(c=1);const d=this._period/16,P=1/(16*c+1),x=2*Math.PI*_/(_/c),M=2*Math.PI*Math.random(),w=2*Math.PI*Math.random(),b=2*Math.PI*Math.random(),v=.75-Math.random()/2,A=.75-Math.random()/2,H={};this._walker.curPointAndAngle(H),r.startPath(H.pt);let nt=0;for(;;){if(!this._walker.nextPointAndAngle(d,H)){r.lineTo(i[i.length-1]);break}{const lt=nt;let rt;if(nt+=P,e){const ct=this._height/2*(1+.3*Math.sin(v*x*lt+M));rt=ct*Math.sin(x*lt+w),rt+=ct*Math.sin(A*x*lt+b),rt/=2}else rt=.5*this._height*Math.sin(.5*x*lt);r.lineTo([H.pt[0]-rt*H.sa,H.pt[1]+rt*H.ca])}}return r.path()}_constructSquare(i){const e=new V,r=this._walker.calculatePathLength(i);Math.round(r/this._period);let _=!0;for(;;){let c=!1;if(this._walker.curPositionIsValid()){const l={};this._walker.curPointAndAngle(l);const g={};if(this._walker.nextPointAndAngle(this._period,g)){const d={};this._walker.nextPointAndAngle(this._period,d)&&(_?(e.startPath(l.pt),_=!1):e.lineTo(l.pt),e.lineTo([l.pt[0]-this._height/2*l.sa,l.pt[1]+this._height/2*l.ca]),e.lineTo([g.pt[0]-this._height/2*g.sa,g.pt[1]+this._height/2*g.ca]),e.lineTo([g.pt[0]+this._height/2*g.sa,g.pt[1]-this._height/2*g.ca]),e.lineTo([d.pt[0]+this._height/2*d.sa,d.pt[1]-this._height/2*d.ca]),c=!0)}}if(!c){e.lineTo(this._walker.getPathEnd());break}}return e.path()}_constructTriangle(i){const e=new V,r=this._walker.calculatePathLength(i);Math.round(r/this._period);let _=!0;for(;;){let c=!1;if(this._walker.curPositionIsValid()){const l={};this._walker.curPointAndAngle(l);const g={};if(this._walker.nextPointAndAngle(this._period/2,g)){const d={};this._walker.nextPointAndAngle(this._period,d)&&(this._walker.nextPosition(this._period/2)&&(_?(e.startPath(l.pt),_=!1):e.lineTo(l.pt),e.lineTo([g.pt[0]-this._height/2*g.sa,g.pt[1]+this._height/2*g.ca]),e.lineTo([d.pt[0]+this._height/2*d.sa,d.pt[1]-this._height/2*d.ca])),c=!0)}}if(!c){e.lineTo(this._walker.getPathEnd());break}}return e.path()}}let Nt=(()=>{class a{static local(){return null===a.instance&&(a.instance=new a),a.instance}execute(e,r,_,c){return new Bt(e,r,_)}}return a.instance=null,a})();class Bt extends Q.v1{constructor(i,e,r){super(i,!0,!0),this._geometryWalker=new $,this._geometryWalker.updateTolerance(r),this._angleToLine=e.angleToLine??!0,this._offset=(e.offset?e.offset:0)*r,this._originalEndings=e.endings,this._offsetAtEnd=(e.customEndingOffset?e.customEndingOffset:0)*r,this._position=-(e.offsetAlongLine?e.offsetAlongLine:0)*r,this._pattern=new kt,this._pattern.init(e.placementTemplate,!1),this._pattern.scale(r),this._endings=this._originalEndings}processPath(i){if(this._pattern.isEmpty())return null;let e;if(this.iteratePath)e=this._pattern.nextValue();else{this._endings=this._originalEndings===L.JS.WithFullGap&&this.isClosed?L.JS.WithMarkers:this._originalEndings,this._pattern.extPtGap=0;let _,c=!0;switch(this._endings){case L.JS.NoConstraint:_=-this._position,_=this._adjustPosition(_),c=!1;break;case L.JS.WithHalfGap:default:_=-this._pattern.lastValue()/2;break;case L.JS.WithFullGap:_=-this._pattern.lastValue(),this._pattern.extPtGap=this._pattern.lastValue();break;case L.JS.WithMarkers:_=0;break;case L.JS.Custom:_=-this._position,_=this._adjustPosition(_),this._pattern.extPtGap=.5*this._offsetAtEnd}if(!this._geometryWalker.init(i,this._pattern,c))return null;this._pattern.reset();let l=0;for(;_>l;)_-=l,l=this._pattern.nextValue();l-=_,e=l,this.iteratePath=!0}const r={};return this._geometryWalker.nextPointAndAngle(e,r)?this._endings===L.JS.WithFullGap&&this._geometryWalker.isPathEnd()?(this.iteratePath=!1,null):this._endings===L.JS.WithMarkers&&this._geometryWalker.isPathEnd()&&(this.iteratePath=!1,this.isClosed)?null:(this.internalPlacement.setTranslate(r.pt[0]-this._offset*r.sa,r.pt[1]+this._offset*r.ca),this._angleToLine&&this.internalPlacement.setRotateCS(r.ca,r.sa),this.internalPlacement):(this.iteratePath=!1,null)}_adjustPosition(i){let e=i/this._pattern.length();return e-=Math.floor(e),e*this._pattern.length()}}let Zt=(()=>{class a{static local(){return null===a.instance&&(a.instance=new a),a.instance}execute(e,r,_,c){return new Kt(e,r,_)}}return a.instance=null,a})();class Kt extends Q.v1{constructor(i,e,r){super(i,!1,!0),this._curveHelper=new Y,this._angleToLine=void 0===e.angleToLine||e.angleToLine,this._offset=void 0!==e.offset?e.offset*r:0,this._type=e.extremityPlacement,this._position=void 0!==e.offsetAlongLine?e.offsetAlongLine*r:0,this._beginProcessed=!1}processPath(i){let e;switch(this._type){case L.Tx.Both:default:this._beginProcessed?(e=this._atExtremities(i,this._position,!1),this._beginProcessed=!1,this.iteratePath=!1):(e=this._atExtremities(i,this._position,!0),this._beginProcessed=!0,this.iteratePath=!0);break;case L.Tx.JustBegin:e=this._atExtremities(i,this._position,!0);break;case L.Tx.JustEnd:e=this._atExtremities(i,this._position,!1);case L.Tx.None:}return e}_atExtremities(i,e,r){const _=i.length;if(_<2)return null;const l=r?_:-1,g=r?1:-1;let d,P=0,x=r?i[0]:i[_-1];for(let M=r?1:_-2;M!==l;M+=g){d=x,x=i[M];const w=this._curveHelper.calculateLength(d,x);if(P+w>e){const b=(e-P)/w,[v,A]=this._curveHelper.getAngleCS(d,x,b),H=(0,Q.XV)(d,x,b);return this.internalPlacement.setTranslate(H[0]-this._offset*A,H[1]+this._offset*v),this._angleToLine&&this.internalPlacement.setRotateCS(-v,-A),this.internalPlacement}P+=w}return null}}let Vt=(()=>{class a{static local(){return null===a.instance&&(a.instance=new a),a.instance}execute(e,r,_,c){return new re(e,r,_)}}return a.instance=null,a})();class re extends Q.v1{constructor(i,e,r){super(i,!0,!0),this._walker=new $,this._walker.updateTolerance(r),this._angleToLine=void 0===e.angleToLine||e.angleToLine,this._offset=void 0!==e.offset?e.offset*r:0,this._beginGap=void 0!==e.beginPosition?e.beginPosition*r:0,this._endGap=void 0!==e.endPosition?e.endPosition*r:0,this._flipFirst=void 0===e.flipFirst||e.flipFirst,this._pattern=new kt,this._pattern.init(e.positionArray,!1,!1),this._subPathLen=0,this._posCount=this._pattern.size(),this._isFirst=!0,this._prevPos=0}processPath(i){if(this._pattern.isEmpty())return null;let e;if(this.iteratePath){const g=this._pattern.nextValue()*this._subPathLen,d=this._beginGap+g;e=d-this._prevPos,this._prevPos=d}else{if(this._posCount=this._pattern.size(),this._isFirst=!0,this._prevPos=0,this._subPathLen=this._walker.calculatePathLength(i)-this._beginGap-this._endGap,this._subPathLen<0)return this.iteratePath=!1,null;if(!this._walker.init(i,this._pattern,!1))return null;this._pattern.reset();const g=this._pattern.nextValue()*this._subPathLen,d=this._beginGap+g;e=d-this._prevPos,this._prevPos=d,this.iteratePath=!0}const r={};if(!this._walker.nextPointAndAngle(e,r,z.END))return this.iteratePath=!1,null;let c,l;return this.internalPlacement.setTranslate(r.pt[0]-this._offset*r.sa,r.pt[1]+this._offset*r.ca),this._angleToLine?(c=r.ca,l=r.sa):(c=1,l=0),this._isFirst&&this._flipFirst&&(c=-c,l=-l),this.internalPlacement.setRotateCS(c,l),this._isFirst=!1,this._posCount--,0===this._posCount&&(this.iteratePath=!1),this.internalPlacement}}var It=j(4619),jt=j(97373);let Xt=(()=>{class a{static local(){return null===a.instance&&(a.instance=new a),a.instance}execute(e,r,_,c){return new Wt(e,r,_,c)}}return a.instance=null,a})();class Wt{constructor(i,e,r,_){if(this._xMin=0,this._xMax=0,this._yMin=0,this._yMax=0,this._currentX=0,this._currentY=0,this._stepX=Math.abs(e.stepX??16)*r,this._stepY=Math.abs(e.stepY??16)*r,0!==this._stepX&&0!==this._stepY&&i&&function vt(a){return void 0!==a.rings}(i)&&i.rings){if(this._gridType=e.gridType??L.bj.Fixed,this._gridType===L.bj.Random)this._randomLCG=new It.Z(1*(e.seed??13)),this._randomness=(e.randomness??100)/100,this._gridAngle=0,this._shiftOddRows=!1,this._cosAngle=1,this._sinAngle=0,this._offsetX=0,this._offsetY=0;else{if(this._randomness=0,this._gridAngle=e.gridAngle??0,this._shiftOddRows=e.shiftOddRows??!1,this._offsetX=(e.offsetX??0)*r,this._offsetY=(e.offsetY??0)*r,this._cosAngle=Math.cos(this._gridAngle/180*Math.PI),this._sinAngle=-Math.sin(this._gridAngle/180*Math.PI),this._stepX)if(this._offsetX<0)for(;this._offsetX<-.5*this._stepX;)this._offsetX+=this._stepX;else for(;this._offsetX>=.5*this._stepX;)this._offsetX-=this._stepX;if(this._stepY)if(this._offsetY<0)for(;this._offsetY<-.5*this._stepY;)this._offsetY+=this._stepY;else for(;this._offsetY>=.5*this._stepY;)this._offsetY-=this._stepY}this._graphicOriginX=0,this._graphicOriginY=0,this._internalPlacement=new jt.u,this._calculateMinMax(i),this._geometry=i}}next(){return this._geometry?this._nextInside():null}_calculateMinMax(i){let e,r,_,c,l,g,d,P;this._xMin=0,this._xMax=0,this._yMin=0,this._yMax=0,l=g=Number.MAX_VALUE,d=P=-Number.MAX_VALUE;for(const x of i.rings){const M=x?x.length:0;for(let w=0;w<M;++w)e=x[w][0]-this._graphicOriginX-this._offsetX,r=x[w][1]-this._graphicOriginY-this._offsetY,_=this._cosAngle*e-this._sinAngle*r,c=this._sinAngle*e+this._cosAngle*r,l=Math.min(l,_),d=Math.max(d,_),g=Math.min(g,c),P=Math.max(P,c)}l+=this._graphicOriginX,d+=this._graphicOriginX,g+=this._graphicOriginY,P+=this._graphicOriginY,this._xMin=Math.round(l/this._stepX),this._xMax=Math.round(d/this._stepX),this._yMin=Math.round(g/this._stepY),this._yMax=Math.round(P/this._stepY),this._currentX=this._xMax+1,this._currentY=this._yMin-1}_nextInside(){for(;;){if(this._currentX>this._xMax){if(this._currentY++,this._currentY>this._yMax)return null;this._currentX=this._xMin,this._shiftOddRows&&this._currentY%2&&this._currentX--}let i=this._currentX*this._stepX+this._offsetX;this._shiftOddRows&&this._currentY%2&&(i+=.5*this._stepX);const e=this._currentY*this._stepY+this._offsetY;let r,_;return this._currentX++,this._gridType===L.bj.Random?(r=this._graphicOriginX+i+this._stepX*this._randomness*(.5-this._randomLCG.getFloat())*2/3,_=this._graphicOriginY+e+this._stepY*this._randomness*(.5-this._randomLCG.getFloat())*2/3):(r=this._graphicOriginX+this._cosAngle*i+this._sinAngle*e,_=this._graphicOriginY-this._sinAngle*i+this._cosAngle*e),this._internalPlacement.setTranslate(r,_),this._internalPlacement}}}let qt=(()=>{class a{static local(){return null===a.instance&&(a.instance=new a),a.instance}execute(e,r,_,c){return new Rt(e,r,_)}}return a.instance=null,a})();class Rt extends Q.v1{constructor(i,e,r){super(i,!0,!0),this._curveHelper=new Y,this._angleToLine=void 0===e.angleToLine||e.angleToLine,this._offset=void 0!==e.offset?e.offset*r:0,this._relativeTo=e.relativeTo,this._position=void 0!==e.startPointOffset?e.startPointOffset*r:0,this._epsilon=.001*r}processPath(i){const e=this._position;if(this._relativeTo===L.CS.SegmentMidpoint){for(this.iteratePath||(this._segmentCount=i.length,this._curSegment=1,this.iteratePath=!0);this._curSegment<this._segmentCount;){const _=this._curSegment;this._curSegment++;const c=i[_-1],l=i[_],g=this._curveHelper.calculateLength(c,l);if(g<this._epsilon)continue;const d=.5+this._position/g,[P,x]=this._curveHelper.getAngleCS(c,l,d),M=(0,Q.XV)(c,l,d);return this.internalPlacement.setTranslate(M[0]-this._offset*x,M[1]+this._offset*P),this._angleToLine&&this.internalPlacement.setRotateCS(P,x),this.internalPlacement}return this.iteratePath=!1,null}this._relativeTo===L.CS.LineEnd&&(0,Q.hh)(i);const r=this.onLine(i,e);return this._relativeTo===L.CS.LineEnd&&(0,Q.hh)(i),r}onLine(i,e){let r,_=!1;switch(this._relativeTo){case L.CS.LineMiddle:default:r=this._curveHelper.calculatePathLength(i)/2+e;break;case L.CS.LineBeginning:r=e;break;case L.CS.LineEnd:r=e,_=!0}const c=i.length;let l,g=0,d=i[0];for(let P=1;P<c;++P){l=d,d=i[P];const x=this._curveHelper.calculateLength(l,d);if(g+x>r){const M=(r-g)/x,[w,b]=this._curveHelper.getAngleCS(l,d,M),v=(0,Q.XV)(l,d,M),A=_?-this._offset:this._offset;return this.internalPlacement.setTranslate(v[0]-A*b,v[1]+A*w),this._angleToLine&&(_?this.internalPlacement.setRotateCS(-w,-b):this.internalPlacement.setRotateCS(w,b)),this.internalPlacement}g+=x}return null}}let te=(()=>{class a{static local(){return null===a.instance&&(a.instance=new a),a.instance}execute(e,r,_,c){return new se(e,r,_)}}return a.instance=null,a})();class se extends Q.v1{constructor(i,e,r){super(i,!0,!0),this._curveHelper=new Y,this._angleToLine=void 0===e.angleToLine||e.angleToLine,this._offset=void 0!==e.offset?e.offset*r:0,this._endPoints=void 0===e.placeOnEndPoints||e.placeOnEndPoints,this._controlPoints=void 0===e.placeOnControlPoints||e.placeOnControlPoints,this._regularVertices=void 0===e.placeOnRegularVertices||e.placeOnRegularVertices,this._tags=[],this._tagIterator=0}processPath(i){if(this.iteratePath||(this._preparePath(i),this.iteratePath=!0),this._tagIterator>=this._tags.length)return this._tags.length=0,this._tagIterator=0,this.iteratePath=!1,null;const e=this._tags[this._tagIterator];this._angleToLine&&this.internalPlacement.setRotate(e[2]);let r=e[0],_=e[1];if(0!==this._offset){const c=Math.cos(e[2]),l=Math.sin(e[2]);r-=this._offset*l,_+=this._offset*c}return this.internalPlacement.setTranslate(r,_),this._tagIterator++,this.internalPlacement}_preparePath(i){this._tags.length=0,this._tagIterator=0;const e=(0,Q.QK)(i),r=i.length-1;let _,c,l=0,g=0,d=0,P=0,x=0;for(;l<r;){l++,_=i[l-1],c=i[l];const M=(0,Q.zv)(_),w=(0,Q.zv)(c);(this._angleToLine||0!==this._offset)&&(P=this._curveHelper.getAngle(_,c,0)),1===l?e?(g=P,d=M):(this._endPoints||this._controlPoints&&1===M)&&this._tags.push([_[0],_[1],P]):1===M?this._controlPoints&&this._tags.push([_[0],_[1],Ut(x,P)]):this._regularVertices&&this._tags.push([_[0],_[1],Ut(x,P)]),(this._angleToLine||0!==this._offset)&&(x=this._curveHelper.getAngle(_,c,1)),l===r&&(e?1===w||1===d?this._controlPoints&&this._tags.push([c[0],c[1],Ut(x,g)]):this._regularVertices&&this._tags.push([c[0],c[1],Ut(x,g)]):(this._endPoints||this._controlPoints&&1===w)&&this._tags.push([c[0],c[1],x]))}this._tagIterator=0}}function Ut(a,i){const e=Math.PI;for(;Math.abs(i-a)>e+2e-15;)i-a>e?i-=2*e:i+=2*e;return(a+i)/2}let Jt=(()=>{class a{static local(){return null===a.instance&&(a.instance=new a),a.instance}execute(e,r,_,c){return new $t(e,r,_)}}return a.instance=null,a})();class $t{constructor(i,e,r){this._geometry=i,this._offsetX=void 0!==e.offsetX?e.offsetX*r:0,this._offsetY=void 0!==e.offsetY?e.offsetY*r:0,this._method=void 0!==e.method?e.method:L.Lh.OnPolygon,this._internalPlacement=new jt.u}next(){const i=this._geometry;return this._geometry=null,i&&function ie(a){return void 0!==a.rings}(i)?this._polygonCenter(i):null}_polygonCenter(i){let e=!1;switch(this._method){default:{const r=(0,zt.Ue)();(0,Ft.$P)(r,i),this._internalPlacement.setTranslate((r[2]+r[0])/2+this._offsetX,(r[3]+r[1])/2+this._offsetY),e=!0;break}}return e?this._internalPlacement:null}}function D(a){if(!a)return null;switch(a.type){case"CIMGeometricEffectAddControlPoints":return it.local();case"CIMGeometricEffectArrow":return ut.local();case"CIMGeometricEffectBuffer":return st.local();case"CIMGeometricEffectControlMeasureLine":return gt.local();case"CIMGeometricEffectCut":return et.local();case"CIMGeometricEffectDashes":return F.local();case"CIMGeometricEffectDonut":return U.local();case"CIMGeometricEffectJog":return tt.local();case"CIMGeometricEffectMove":return pt.local();case"CIMGeometricEffectOffset":return yt.local();case"CIMGeometricEffectReverse":return At.local();case"CIMGeometricEffectRotate":return Ct.local();case"CIMGeometricEffectScale":return Gt.local();case"CIMGeometricEffectWave":return wt.local()}return null}function o(a){if(!a)return null;switch(a.type){case"CIMMarkerPlacementAlongLineSameSize":return Nt.local();case"CIMMarkerPlacementAtExtremities":return Zt.local();case"CIMMarkerPlacementAtRatioPositions":return Vt.local();case"CIMMarkerPlacementInsidePolygon":return Xt.local();case"CIMMarkerPlacementOnLine":return qt.local();case"CIMMarkerPlacementOnVertices":return te.local();case"CIMMarkerPlacementPolygonCenter":return Jt.local()}return null}},97373:(Dt,xt,j)=>{j.d(xt,{u:()=>K});class K{constructor(){this.setIdentity()}getAngle(){return(null==this.rz||0===this.rz&&1!==this.rz_c&&0!==this.rz_s)&&(this.rz=Math.atan2(this.rz_s,this.rz_c)),this.rz}setIdentity(){this.tx=0,this.ty=0,this.tz=0,this.s=1,this.rx=0,this.ry=0,this.rz=0,this.rz_c=1,this.rz_s=0}setTranslate(it,dt){this.tx=it,this.ty=dt}setTranslateZ(it){this.tz=it}setRotateCS(it,dt){this.rz=void 0,this.rz_c=it,this.rz_s=dt}setRotate(it){this.rz=it,this.rz_c=void 0,this.rz_s=void 0}setRotateY(it){this.ry=it}setScale(it){this.s=it}setMeasure(it){this.m=it}}},57052:(Dt,xt,j)=>{j.d(xt,{Z:()=>L});var K=j(15861),B=j(84792),Q=j(26584),it=j(10699);class L{constructor(){this._resourceMap=new Map,this._inFlightResourceMap=new Map,this.geometryEngine=null}destroy(){this._inFlightResourceMap.clear(),this._resourceMap.clear()}getResource(Y){return this._resourceMap.get(Y)??null}fetchResource(Y,X){var q=this;return(0,K.Z)(function*(){const at={width:0,height:0},ut=q._resourceMap,_t=ut.get(Y);if(_t)return at.width=_t.width,at.height=_t.height,at;let st=q._inFlightResourceMap.get(Y);return st||(st=function mt(V,Y){if(V.includes(";base64,")){const X=new Image;return X.src=V,X.decode().then(()=>({ok:!0,value:X})).catch(q=>(0,it.D_)(q)?{ok:!1,error:q}:{ok:!1,error:new Q.Z("invalid-resource",`Could not fetch requested resource at ${V}`)})}return(0,B.default)(V,{responseType:"image",...Y}).then(X=>({ok:!0,value:X.data})).catch(X=>(0,it.D_)(X)?{ok:!1,error:X}:{ok:!1,error:new Q.Z("invalid-resource",`Could not fetch requested resource at ${V}`)})}(Y,X),q._inFlightResourceMap.set(Y,st),st=st.then(Mt=>{if(q._inFlightResourceMap.delete(Y),Mt.ok){ut.set(Y,Mt.value);const gt=Mt.value;return at.width=gt.width,at.height=gt.height,at}return at}),st)})()}deleteResource(Y){this._inFlightResourceMap.delete(Y),this._resourceMap.delete(Y)}}},44654:(Dt,xt,j)=>{j.d(xt,{B$:()=>It,E0:()=>vt,fN:()=>jt,U1:()=>Ut});var K=j(91558),B=j(986),Q=j(36161),it=j(58817),dt=j(63290),L=j(21286),mt=j(62208),V=j(4619),Y=j(23841),X=j(65401),q=j(32442),at=j(97373),ut=j(27899),_t=j(27105),st=j(91179),Mt=j(29214),gt=j(11004),Lt=j(57052),et=j(7547),Tt=j(31375),Et=j(68937),z=(j(40028),j(39351));j(25797);const $=Math.PI/180,W=dt.Z.getLogger("esri.symbols.cim.CIMSymbolDrawHelper");class U{constructor(o){this._t=o}static createIdentity(){return new U([1,0,0,0,1,0])}clone(){return new U(this._t.slice())}transform(o){const a=this._t;return[a[0]*o[0]+a[1]*o[1]+a[2],a[3]*o[0]+a[4]*o[1]+a[5]]}static createScale(o,a){return new U([o,0,0,0,a,0])}scale(o,a){const i=this._t;return i[0]*=o,i[1]*=o,i[2]*=o,i[3]*=a,i[4]*=a,i[5]*=a,this}scaleRatio(){return Math.sqrt(this._t[0]*this._t[0]+this._t[1]*this._t[1])}static createTranslate(o,a){return new U([0,0,o,0,0,a])}translate(o,a){const i=this._t;return i[2]+=o,i[5]+=a,this}static createRotate(o){const a=Math.cos(o),i=Math.sin(o);return new U([a,-i,0,i,a,0])}rotate(o){return U.multiply(this,U.createRotate(o),this)}static multiply(o,a,i){const e=o._t,r=a._t,c=e[1]*r[0]+e[4]*r[1],l=e[2]*r[0]+e[5]*r[1]+r[2],g=e[0]*r[3]+e[3]*r[4],d=e[1]*r[3]+e[4]*r[4],P=e[2]*r[3]+e[5]*r[4]+r[5],x=i._t;return x[0]=e[0]*r[0]+e[3]*r[1],x[1]=c,x[2]=l,x[3]=g,x[4]=d,x[5]=P,i}invert(){const o=this._t;let a=o[0]*o[4]-o[1]*o[3];return 0===a?new U([0,0,0,0,0,0]):(a=1/a,new U([o[4]*a,-o[1]*a,(o[1]*o[5]-o[2]*o[4])*a,-o[3]*a,o[0]*a,(o[2]*o[3]-o[0]*o[5])*a]))}}class J{constructor(o,a){this._transfos=[],this._sizeTransfos=[],this._geomUnitsPerPoint=1,this._placementPool=new ut.Z(at.u,null,null,100),this._earlyReturn=!1,this._mapRotation=0,this._resourceManager=o||new Lt.Z,this._transfos.push(a||U.createIdentity()),this._sizeTransfos.push(a?a.scaleRatio():1)}setTransform(o,a){this._transfos=[o||U.createIdentity()],this._sizeTransfos=[a||(o?o.scaleRatio():1)]}setGeomUnitsPerPoint(o){this._geomUnitsPerPoint=o}transformPt(o){return this._transfos[this._transfos.length-1].transform(o)}transformSize(o){return o*this._sizeTransfos[this._sizeTransfos.length-1]}reverseTransformPt(o){return this._transfos[this._transfos.length-1].invert().transform(o)}reverseTransformSize(o){return o/this._sizeTransfos[this._sizeTransfos.length-1]}geomUnitsPerPoint(){return this.isEmbedded()?1:this._geomUnitsPerPoint}isEmbedded(){return this._transfos.length>1}back(){return this._transfos[this._transfos.length-1]}push(o,a){const i=a?o.scaleRatio():1;U.multiply(o,this.back(),o),this._transfos.push(o),this._sizeTransfos.push(this._sizeTransfos[this._sizeTransfos.length-1]*i)}pop(){this._transfos.splice(-1,1),this._sizeTransfos.splice(-1,1)}drawSymbol(o,a){if(o)switch(o.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":this.drawMultiLayerSymbol(o,a);break;case"CIMTextSymbol":this.drawTextSymbol(o,a)}}drawMultiLayerSymbol(o,a){if(!o)return;const i=o.symbolLayers;if(!i)return;const e=o.effects;if(e&&e.length>0){const r=this.executeEffects(e,a);if(r){let _=r.next();for(;_;)this.drawSymbolLayers(i,_),_=r.next()}}else this.drawSymbolLayers(i,a)}executeEffects(o,a){const i=this._resourceManager.geometryEngine;let e=new Mt.M(a);for(const r of o){const _=(0,gt.h)(r);_&&(e=_.execute(e,r,this.geomUnitsPerPoint(),i))}return e}drawSymbolLayers(o,a){let i=o.length;for(;i--;){const e=o[i];if(!e||!1===e.enable)continue;const r=e.effects;if(r&&r.length>0){const _=this.executeEffects(r,a);if(_){let c=null;for(;(c=_.next())&&(this.drawSymbolLayer(e,c),!this._earlyReturn););}}else this.drawSymbolLayer(e,a);if(this._earlyReturn)return}}drawSymbolLayer(o,a){switch(o.type){case"CIMSolidFill":this.drawSolidFill(a,o.color);break;case"CIMHatchFill":this.drawHatchFill(a,o);break;case"CIMPictureFill":this.drawPictureFill(a,o);break;case"CIMGradientFill":this.drawGradientFill(a,o);break;case"CIMSolidStroke":this.drawSolidStroke(a,o.color,o.width,o.capStyle,o.joinStyle,o.miterLimit);break;case"CIMPictureStroke":this.drawPictureStroke(a,o);break;case"CIMGradientStroke":this.drawGradientStroke(a,o);break;case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":this.drawMarkerLayer(o,a)}}drawHatchFill(o,a){const i=this._buildHatchPolyline(a,o,this.geomUnitsPerPoint());i&&(this.pushClipPath(o),this.drawMultiLayerSymbol(a.lineSymbol,i),this.popClipPath())}drawPictureFill(o,a){}drawGradientFill(o,a){}drawPictureStroke(o,a){}drawGradientStroke(o,a){}drawMarkerLayer(o,a){const i=o.markerPlacement;if(i){const e=(0,gt.W)(i);if(e){const r="CIMMarkerPlacementInsidePolygon"===i.type;r&&this.pushClipPath(a);const _=e.execute(a,i,this.geomUnitsPerPoint(),this._resourceManager.geometryEngine);if(_){let c=null;for(;(c=_.next())&&(this.drawMarker(o,c),!this._earlyReturn););}r&&this.popClipPath()}}else{const e=this._placementPool.acquire();if((0,st.wp)(a))e.tx=a.x,e.ty=a.y,this.drawMarker(o,e);else if((0,st.oU)(a))[e.tx,e.ty]=(0,_t.tO)(a),this.drawMarker(o,e);else for(const r of a.points)if(e.tx=r[0],e.ty=r[1],this.drawMarker(o,e),this._earlyReturn)break;this._placementPool.release(e)}}drawMarker(o,a){switch(o.type){case"CIMCharacterMarker":case"CIMPictureMarker":this.drawPictureMarker(o,a);break;case"CIMVectorMarker":this.drawVectorMarker(o,a)}}drawPictureMarker(o,a){if(!o)return;const i=this._resourceManager.getResource(o.url),e=o.size??10;if((0,mt.Wi)(i)||e<=0)return;const r=i.width,_=i.height;if(!r||!_)return;const c=r/_,l=o.scaleX??1,g=U.createIdentity(),d=o.anchorPoint;if(d){let v=d.x,A=d.y;"Absolute"!==o.anchorPointUnits&&(v*=e*c*l,A*=e),g.translate(-v,-A)}let P=o.rotation??0;o.rotateClockwise&&(P=-P),this._mapRotation&&(P+=this._mapRotation),P&&g.rotate(P*$);let x=o.offsetX??0,M=o.offsetY??0;if(x||M){if(this._mapRotation){const v=$*this._mapRotation,A=Math.cos(v),H=Math.sin(v),nt=x*H+M*A;x=x*A-M*H,M=nt}g.translate(x,M)}const w=this.geomUnitsPerPoint();1!==w&&g.scale(w,w);const b=a.getAngle();b&&g.rotate(b),g.translate(a.tx,a.ty),this.push(g,!1),this.drawImage(o.url,e,o.scaleX),this.pop()}drawVectorMarker(o,a){if(!o)return;const i=o.markerGraphics;if(!i)return;const e=o.size??10,r=o.frame,_=r?r.ymax-r.ymin:0,c=e&&_?e/_:1,l=U.createIdentity();r&&l.translate(.5*-(r.xmax+r.xmin),.5*-(r.ymax+r.ymin));const g=o.anchorPoint;if(g){let b=g.x,v=g.y;"Absolute"!==o.anchorPointUnits?r&&(b*=r.xmax-r.xmin,v*=r.ymax-r.ymin):(b/=c,v/=c),l.translate(-b,-v)}1!==c&&l.scale(c,c);let d=o.rotation??0;o.rotateClockwise&&(d=-d),this._mapRotation&&(d+=this._mapRotation),d&&l.rotate(d*$);let P=o.offsetX??0,x=o.offsetY??0;if(P||x){if(this._mapRotation){const b=$*this._mapRotation,v=Math.cos(b),A=Math.sin(b),H=P*A+x*v;P=P*v-x*A,x=H}l.translate(P,x)}const M=this.geomUnitsPerPoint();1!==M&&l.scale(M,M);const w=a.getAngle();w&&l.rotate(w),l.translate(a.tx,a.ty),this.push(l,o.scaleSymbolsProportionally);for(const b of i)if(b&&b.symbol&&b.geometry||W.error("Invalid marker graphic",b),this.drawSymbol(b.symbol,b.geometry),this._earlyReturn)break;this.pop()}drawTextSymbol(o,a){if(!o||!(0,st.wp)(a)||(o.height??10)<=0)return;const i=U.createIdentity();let e=o.angle??0;e=-e,e&&i.rotate(e*$);const r=o.offsetX??0,_=o.offsetY??0;(r||_)&&i.translate(r,_);const c=this.geomUnitsPerPoint();1!==c&&i.scale(c,c),i.translate(a.x,a.y),this.push(i,!1),this.drawText(o),this.pop()}_buildHatchPolyline(o,a,i){let e=(void 0!==o.separation?o.separation:4)*i,r=void 0!==o.rotation?o.rotation:0;if(0===e)return null;e<0&&(e=-e);let _=0;const c=.5*e;for(;_>c;)_-=e;for(;_<-c;)_+=e;const l=(0,X.Ue)();(0,q.$P)(l,a),l[0]-=c,l[1]-=c,l[2]+=c,l[3]+=c;const g=[[l[0],l[1]],[l[0],l[3]],[l[2],l[3]],[l[2],l[1]]];for(;r>180;)r-=180;for(;r<0;)r+=180;const d=Math.cos(r*$),P=Math.sin(r*$),x=-e*P,M=e*d;let w,b,v,A;_=(void 0!==o.offsetX?o.offsetX*i:0)*P-(void 0!==o.offsetY?o.offsetY*i:0)*d,w=v=Number.MAX_VALUE,b=A=-Number.MAX_VALUE;for(const Ht of g){const ne=Ht[0],ae=Ht[1],oe=d*ne+P*ae,he=-P*ne+d*ae;w=Math.min(w,oe),v=Math.min(v,he),b=Math.max(b,oe),A=Math.max(A,he)}v=Math.floor(v/e)*e;let H=d*w-P*v-x*_/e,nt=P*w+d*v-M*_/e,lt=d*b-P*v-x*_/e,rt=P*b+d*v-M*_/e;const ct=1+Math.round((A-v)/e),Yt=[];for(let Ht=0;Ht<ct;Ht++)H+=x,nt+=M,lt+=x,rt+=M,Yt.push([[H,nt],[lt,rt]]);return{paths:Yt}}}class tt extends J{constructor(o,a){super(o,a),this.reset()}reset(){this._xmin=this._ymin=1/0,this._xmax=this._ymax=-1/0,this._clipCount=0}envelope(){return new Tt.Z(this._xmin,this._ymin,this._xmax-this._xmin,this._ymax-this._ymin)}bounds(){return(0,X.al)(this._xmin,this._ymin,this._xmax,this._ymax)}drawSolidFill(o){if(o&&!(this._clipCount>0))if((0,st.oU)(o))this._processPath(o.rings,0);else if((0,st.l9)(o))this._processPath(o.paths,0);else if((0,st.YX)(o)){const a=ht(o);a&&this._processPath(a.rings,0)}else console.error("drawSolidFill Unexpected geometry type!")}drawSolidStroke(o,a,i){if(!o||this._clipCount>0)return;const e=.5*this.transformSize(i);if((0,st.oU)(o))this._processPath(o.rings,e);else if((0,st.l9)(o))this._processPath(o.paths,e);else if((0,st.YX)(o)){const r=ht(o);r&&this._processPath(r.rings,e)}else console.error("drawSolidStroke unexpected geometry type!")}pushClipPath(o){this.drawSolidFill(o),++this._clipCount}popClipPath(){--this._clipCount}drawImage(o,a,i){let e=i*a,r=a;const _=this._resourceManager.getResource(o);!a&&(0,mt.pC)(_)&&(e=i*_.width,r=_.height),this._merge(this.transformPt([-e/2,-r/2]),0),this._merge(this.transformPt([-e/2,r/2]),0),this._merge(this.transformPt([e/2,-r/2]),0),this._merge(this.transformPt([e/2,r/2]),0)}drawText(o){this._textRasterizer||(this._textRasterizer=new Et.Z)}_processPath(o,a){if(o)for(const i of o){const e=i?i.length:0;if(e>1){this._merge(this.transformPt(i[0]),a);for(let r=1;r<e;++r)this._merge(this.transformPt(i[r]),a)}}}_merge(o,a){o[0]-a<this._xmin&&(this._xmin=o[0]-a),o[0]+a>this._xmax&&(this._xmax=o[0]+a),o[1]-a<this._ymin&&(this._ymin=o[1]-a),o[1]+a>this._ymax&&(this._ymax=o[1]+a)}}class pt extends J{constructor(o,a,i){super(a,i),this._ctx=o}drawSolidFill(o,a){if(!o)return;if((0,st.oU)(o))this._buildPath(o.rings,!0);else if((0,st.l9)(o))this._buildPath(o.paths,!0);else if((0,st.YX)(o))this._buildPath(ht(o).rings,!0);else{if(!(0,st.aW)(o))return;console.log("CanvasDrawHelper.drawSolidFill - No implementation!")}const i=this._ctx;i.fillStyle="string"==typeof a?a:"rgba("+Math.round(a[0])+","+Math.round(a[1])+","+Math.round(a[2])+","+a[3]/255+")",i.fill("evenodd")}drawSolidStroke(o,a,i,e,r,_){if(!o||!a||0===i)return;if((0,st.oU)(o))this._buildPath(o.rings,!0);else if((0,st.l9)(o))this._buildPath(o.paths,!1);else{if(!(0,st.YX)(o))return void console.log("CanvasDrawHelper.drawSolidStroke isn't implemented!");this._buildPath(ht(o).rings,!0)}const c=this._ctx;c.strokeStyle="string"==typeof a?a:"rgba("+Math.round(a[0])+","+Math.round(a[1])+","+Math.round(a[2])+","+a[3]/255+")",c.lineWidth=this.transformSize(i)+.5,this._setCapStyle(e),this._setJoinStyle(r),c.miterLimit=_,c.stroke()}pushClipPath(o){if(this._ctx.save(),(0,st.oU)(o))this._buildPath(o.rings,!0);else if((0,st.l9)(o))this._buildPath(o.paths,!0);else{if(!(0,st.YX)(o))return;this._buildPath(ht(o).rings,!0)}this._ctx.clip("evenodd")}popClipPath(){this._ctx.restore()}drawImage(o,a,i){const e=this._resourceManager.getResource(o);if((0,mt.Wi)(e))return;const r=this._ctx,_=r.canvas.width,c=r.canvas.height;let l=a*i*(e.width/e.height),g=i*a;a||(l=i*e.width,g=i*e.height);const d=this.transformPt([0,0]),P=this.transformSize(l),x=this.transformSize(g);this._ctx.drawImage(e,0,0,e.width,e.height,d[0]-P/2,d[1]-x/2,Math.min(P,_),Math.min(x,c))}drawText(o){this._textRasterizer||(this._textRasterizer=new Et.Z)}_buildPath(o,a){const i=this._ctx;if(i.beginPath(),o)for(const e of o){const r=e?e.length:0;if(r>1){let _=this.transformPt(e[0]);i.moveTo(_[0],_[1]);for(let c=1;c<r;++c)_=this.transformPt(e[c]),i.lineTo(_[0],_[1]);a&&i.closePath()}}}_setCapStyle(o){switch(o){case et.kP.Butt:this._ctx.lineCap="butt";break;case et.kP.Round:this._ctx.lineCap="round";break;case et.kP.Square:this._ctx.lineCap="square"}}_setJoinStyle(o){switch(o){case et.r4.Bevel:this._ctx.lineJoin="bevel";break;case et.r4.Round:this._ctx.lineJoin="round";break;case et.r4.Miter:this._ctx.lineJoin="miter"}}}const ht=D=>D?{spatialReference:D.spatialReference,rings:[[[D.xmin,D.ymin],[D.xmin,D.ymax],[D.xmax,D.ymax],[D.xmax,D.ymin],[D.xmin,D.ymin]]]}:null;var ot=j(80991);j(86575);const Ft=Math.PI,Ct=Ft/2,bt=96/72,Ot=(Math,dt.Z.getLogger("esri.symbols.cim.CIMSymbolHelper"));function Bt(D,o){switch(o.type){case"CIMSymbolReference":return Bt(D,o.symbol);case"CIMPointSymbol":case"CIMTextSymbol":D.drawSymbol(o,{x:0,y:0});break;case"CIMLineSymbol":D.drawSymbol(o,{paths:[[[0,0],[0,1]]]});break;case"CIMPolygonSymbol":D.drawSymbol(o,{rings:[[[0,0],[0,1],[0,0]]]});break;case"CIMVectorMarker":{const a=new at.u;D.drawMarker(o,a);break}}return D.envelope()}class It{static getEnvelope(o,a){const i=new tt(a);if(Array.isArray(o)){let e;for(const r of o)e?e.union(Bt(i,r)):e=Bt(i,r);return e}return Bt(i,o)}static getTextureAnchor(o,a){const i=this.getEnvelope(o,a);if(!i)return[0,0,0];const c=i.height*bt+2;return[(i.x+.5*i.width)*bt/(i.width*bt+2),-(i.y+.5*i.height)*bt/c,c]}static rasterize(o,a,i,e,r=!0){const _=i||this.getEnvelope(a,e);if(!_)return[null,0,0,0,0];const c=(_.x+.5*_.width)*bt,l=(_.y+.5*_.height)*bt;o.width=_.width*bt,o.height=_.height*bt,i||(o.width+=2,o.height+=2);const g=o.getContext("2d"),d=U.createScale(bt,-bt);d.translate(.5*o.width-c,.5*o.height+l);const P=new pt(g,e,d);switch(a.type){case"CIMPointSymbol":P.drawSymbol(a,{type:"point",x:0,y:0});break;case"CIMVectorMarker":{const w=new at.u;P.drawMarker(a,w);break}}const x=g.getImageData(0,0,o.width,o.height),M=new Uint8Array(x.data);if(r){let w;for(let b=0;b<M.length;b+=4)w=M[b+3]/255,M[b]=M[b]*w,M[b+1]=M[b+1]*w,M[b+2]=M[b+2]*w}return[M,o.width,o.height,-c/o.width,-l/o.height]}static fromTextSymbol(o){const{angle:a,color:i,font:e,haloColor:r,haloSize:_,horizontalAlignment:c,kerning:l,text:g,verticalAlignment:d,xoffset:P,yoffset:x}=o;let M,w,b,v,A;e&&(M=e.family,w=e.style,b=e.weight,v=e.size,A=e.decoration);let H=!1;return g&&(H=(0,B.E)(g)[1]),{type:"CIMPointSymbol",symbolLayers:[{type:"CIMVectorMarker",enable:!0,anchorPointUnits:"Relative",dominantSizeAxis3D:"Y",size:10,billboardMode3D:"FaceNearPlane",frame:{xmin:-5,ymin:-5,xmax:5,ymax:5},markerGraphics:[{type:"CIMMarkerGraphic",geometry:{x:0,y:0},symbol:{type:"CIMTextSymbol",angle:a,blockProgression:et.zV.BTT,depth3D:1,extrapolateBaselines:!0,fontEffects:et.eZ.Normal,fontEncoding:et.DD.Unicode,fontFamilyName:M||"Arial",fontStyleName:te(w,b),fontType:et.Ky.Unspecified,haloSize:_,height:v,hinting:et.Dd.Default,horizontalAlignment:Qt(c??"center"),kerning:l,letterWidth:100,ligatures:!0,lineGapType:"Multiple",offsetX:(0,ot.NA)(P),offsetY:(0,ot.NA)(x),strikethrough:"line-through"===A,underline:"underline"===A,symbol:{type:"CIMPolygonSymbol",symbolLayers:[{type:"CIMSolidFill",enable:!0,color:Rt(i)}]},haloSymbol:{type:"CIMPolygonSymbol",symbolLayers:[{type:"CIMSolidFill",enable:!0,color:Rt(r)}]},shadowColor:[0,0,0,255],shadowOffsetX:1,shadowOffsetY:1,textCase:"Normal",textDirection:H?et.UX.RTL:et.UX.LTR,verticalAlignment:qt(d??"baseline"),verticalGlyphOrientation:et.RS.Right,wordSpacing:100,billboardMode3D:et.UR.FaceNearPlane},textString:g}],scaleSymbolsProportionally:!0,respectFrame:!0}],scaleX:1,angleAlignment:"Display"}}static fromPictureFillSymbol(o){const{height:a,outline:i,width:e,xoffset:r,xscale:_,yoffset:c,yscale:l}=o,g=[],d={type:"CIMPolygonSymbol",symbolLayers:g};if(i){const{cap:b,join:v,miterLimit:A,width:H}=i;g.push({type:"CIMSolidStroke",color:Rt(i.color),capStyle:Xt(b),joinStyle:Wt(v),miterLimit:A,width:H})}let P=o.url;"esriPFS"===o.type&&o.imageData&&(P=o.imageData);const x="angle"in o?o.angle:0;return g.push({type:"CIMPictureFill",invertBackfaceTexture:!1,scaleX:1,textureFilter:et.Qb.Picture,tintColor:null,url:P,height:a*(l||1),width:e*(_||1),offsetX:(0,ot.NA)(r),offsetY:(0,ot.NA)(c),rotation:(0,ot.NA)(-x),colorSubstitutions:null}),d}static fromSimpleFillSymbol(o){const{color:a,style:i,outline:e}=o,r=[],_={type:"CIMPolygonSymbol",symbolLayers:r};let c=null;if(e){const{cap:l,join:g,style:d}=e;"solid"!==d&&"none"!==d&&"esriSLSSolid"!==d&&"esriSLSNull"!==d&&(c=[{type:"CIMGeometricEffectDashes",dashTemplate:Ut(d,l),lineDashEnding:"NoConstraint",scaleDash:!0,offsetAlongLine:null}]),r.push({type:"CIMSolidStroke",color:Rt(e.color),capStyle:Xt(l),joinStyle:Wt(g),miterLimit:e.miterLimit,width:e.width,effects:c})}if(i&&"solid"!==i&&"none"!==i&&"esriSFSSolid"!==i&&"esriSFSNull"!==i){const l={type:"CIMLineSymbol",symbolLayers:[{type:"CIMSolidStroke",color:Rt(a),capStyle:et.kP.Butt,joinStyle:et.r4.Miter,width:.75}]};let g=0;const d=(0,L.fp)(Math.ceil(window.devicePixelRatio)),P=$t(i)?8*d:10*d;switch(i){case"vertical":case"esriSFSVertical":g=90;break;case"forward-diagonal":case"esriSFSForwardDiagonal":case"diagonal-cross":case"esriSFSDiagonalCross":g=-45;break;case"backward-diagonal":case"esriSFSBackwardDiagonal":g=45;break;case"cross":case"esriSFSCross":g=0}r.push({type:"CIMHatchFill",lineSymbol:l,offsetX:0,offsetY:0,rotation:g,separation:P}),"cross"===i||"esriSFSCross"===i?r.push({type:"CIMHatchFill",lineSymbol:(0,it.d9)(l),offsetX:0,offsetY:0,rotation:90,separation:P}):"diagonal-cross"!==i&&"esriSFSDiagonalCross"!==i||r.push({type:"CIMHatchFill",lineSymbol:(0,it.d9)(l),offsetX:0,offsetY:0,rotation:45,separation:P})}else!i||"solid"!==i&&"esriSFSSolid"!==i||r.push({type:"CIMSolidFill",enable:!0,color:Rt(a)});return _}static fromSimpleLineSymbol(o){const{cap:a,color:i,join:e,marker:r,miterLimit:_,style:c,width:l}=o;let g=null;"solid"!==c&&"none"!==c&&"esriSLSSolid"!==c&&"esriSLSNull"!==c&&(g=[{type:"CIMGeometricEffectDashes",dashTemplate:Ut(c,a),lineDashEnding:"NoConstraint",scaleDash:!0,offsetAlongLine:null}]);const d=[];if(r){let P;switch(r.placement){case"begin-end":P=et.Tx.Both;break;case"begin":P=et.Tx.JustBegin;break;case"end":P=et.Tx.JustEnd;break;default:P=et.Tx.None}const x=It.fromSimpleMarker(r,l,i).symbolLayers[0];x.markerPlacement={type:"CIMMarkerPlacementAtExtremities",angleToLine:!0,offset:0,extremityPlacement:P,offsetAlongLine:0},d.push(x)}return"none"!==c&&"esriSLSNull"!==c&&d.push({type:"CIMSolidStroke",color:Rt(i),capStyle:Xt(a),joinStyle:Wt(e),miterLimit:_,width:l,effects:g}),{type:"CIMLineSymbol",symbolLayers:d}}static fromPictureMarker(o){const{angle:a,height:i,width:e,xoffset:r,yoffset:_}=o;let c=o.url;return"esriPMS"===o.type&&o.imageData&&(c=o.imageData),{type:"CIMPointSymbol",symbolLayers:[{type:"CIMPictureMarker",invertBackfaceTexture:!1,scaleX:1,textureFilter:et.Qb.Picture,tintColor:null,url:c,size:i,width:e,offsetX:(0,ot.NA)(r),offsetY:(0,ot.NA)(_),rotation:(0,ot.NA)(-a)}]}}static fromSimpleMarker(o,a,i){const{style:e}=o,r=o.color??i;if("path"===e){const g=[];if("outline"in o&&o.outline){const x=o.outline;g.push({type:"CIMSolidStroke",enable:!0,width:(0,Y.F2)(Math.round((0,Y.Wz)(x.width))),color:Rt(x.color)})}g.push({type:"CIMSolidFill",enable:!0,color:Rt(r),path:o.path});const[d,P]=Jt("square");return{type:"CIMPointSymbol",symbolLayers:[{type:"CIMVectorMarker",enable:!0,rotation:(0,ot.NA)(-o.angle),size:(0,ot.NA)(o.size||6),offsetX:(0,ot.NA)(o.xoffset),offsetY:(0,ot.NA)(o.yoffset),frame:d,markerGraphics:[{type:"CIMMarkerGraphic",geometry:P,symbol:{type:"CIMPolygonSymbol",symbolLayers:g}}]}]}}const[_,c]=Jt(e);let l;if(c&&_){const g=[];if("outline"in o&&o.outline){const P=o.outline;g.push({type:"CIMSolidStroke",enable:!0,width:P.width>.667?(0,Y.F2)(Math.round((0,Y.Wz)(P.width))):P.width,color:Rt(P.color)})}else!a||"line-marker"!==o.type||"cross"!==o.style&&"x"!==o.style||g.push({type:"CIMSolidStroke",enable:!0,width:a,color:Rt(r)});g.push({type:"CIMSolidFill",enable:!0,color:Rt(r)});const d={type:"CIMPolygonSymbol",symbolLayers:g};l={type:"CIMPointSymbol",symbolLayers:[{type:"CIMVectorMarker",enable:!0,rotation:(0,ot.NA)(-o.angle),size:(0,ot.NA)(o.size||6*a),offsetX:(0,ot.NA)(o.xoffset),offsetY:(0,ot.NA)(o.yoffset),frame:_,markerGraphics:[{type:"CIMMarkerGraphic",geometry:c,symbol:d}]}]}}return l}static fromCIMHatchFill(o){const a=o.separation??4,i=a/2,r=o.lineSymbol;let _=this._getLineSymbolPeriod(o.lineSymbol)||4;for(;_<4;)_*=2;const c=_/2;return{type:"CIMVectorMarker",frame:{xmin:-c,xmax:c,ymin:-i,ymax:i},markerGraphics:[{type:"CIMMarkerGraphic",geometry:{paths:[[[-c,0],[c,0]]]},symbol:r}],size:a}}static _getLineSymbolPeriod(o){if(o){const a=this._getEffectsRepeat(o.effects);if(a)return a;if(o.symbolLayers)for(const i of o.symbolLayers)if(i){const e=this._getEffectsRepeat(i.effects);if(e)return e;switch(i.type){case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":case"CIMObjectMarker3D":case"CIMglTFMarker3D":{const r=this._getPlacementRepeat(i.markerPlacement);if(r)return r}}}}return 0}static _getEffectsRepeat(o){if(o)for(const a of o)if(a)switch(a.type){case"CIMGeometricEffectDashes":{const i=a.dashTemplate;if(i&&i.length){let e=0;for(const r of i)e+=r;return 1&i.length&&(e*=2),e}break}case"CIMGeometricEffectWave":return a.period;default:Ot.error(`unsupported geometric effect type ${a.type}`)}return 0}static _getPlacementRepeat(o){if(o)switch(o.type){case"CIMMarkerPlacementAlongLineSameSize":case"CIMMarkerPlacementAlongLineRandomSize":case"CIMMarkerPlacementAlongLineVariableSize":{const a=o.placementTemplate;if(a&&a.length){let i=0;for(const e of a)i+=e;return 1&a.length&&(i*=2),i}break}}return 0}static fromCIMInsidePolygon(o){const a=o.markerPlacement,i={type:o.type,...o};i.markerPlacement=null,i.anchorPoint=null;const e=Math.abs(a.stepX),r=Math.abs(a.stepY),_=(a.randomness??100)/100;let c,l,g,d;if("Random"===a.gridType){const P=(0,Y.Wz)(z.C1),x=Math.max(Math.floor(P/e),1),M=Math.max(Math.floor(P/r),1);c=x*e/2,l=M*r/2,g=2*l;const w=new V.Z(a.seed),b=_*e/1.5,v=_*r/1.5;d=[];for(let A=0;A<x;A++)for(let H=0;H<M;H++){const nt=A*e-c+b*(.5-w.getFloat()),lt=H*r-l+v*(.5-w.getFloat());d.push({x:nt,y:lt}),0===A&&d.push({x:nt+2*c,y:lt}),0===H&&d.push({x:nt,y:lt+2*l})}}else!0===a.shiftOddRows?(c=e/2,l=r,g=2*r,d=[{x:-c,y:0},{x:c,y:0},{x:0,y:l},{x:0,y:-l}]):(c=e/2,l=r/2,g=r,d=[{x:0,y:0}]);return{type:"CIMVectorMarker",frame:{xmin:-c,xmax:c,ymin:-l,ymax:l},markerGraphics:d.map(P=>({type:"CIMMarkerGraphic",geometry:P,symbol:{type:"CIMPointSymbol",symbolLayers:[i]}})),size:g}}static getFillColor(o){if(!o)return null;switch(o.type){case"CIMPolygonSymbol":if(o.symbolLayers)for(const a of o.symbolLayers){const i=It.getFillColor(a);if(null!=i)return i}break;case"CIMTextSymbol":return It.getFillColor(o.symbol);case"CIMSolidFill":return o.color}}static getStrokeColor(o){if(o)switch(o.type){case"CIMPolygonSymbol":case"CIMLineSymbol":if(o.symbolLayers)for(const a of o.symbolLayers){const i=It.getStrokeColor(a);if(void 0!==i)return i}break;case"CIMTextSymbol":return It.getStrokeColor(o.symbol);case"CIMSolidStroke":return o.color}}static getStrokeWidth(o){if(o)switch(o.type){case"CIMPolygonSymbol":case"CIMLineSymbol":if(o.symbolLayers)for(const a of o.symbolLayers){const i=It.getStrokeWidth(a);if(void 0!==i)return i}break;case"CIMTextSymbol":return It.getStrokeWidth(o.symbol);case"CIMSolidStroke":case"CIMGradientStroke":case"CIMPictureStroke":return o.width}}static getSize(o){if(o)switch(o.type){case"CIMTextSymbol":return o.height;case"CIMPointSymbol":{let a=0;if(o.symbolLayers)for(const i of o.symbolLayers)if(i)switch(i.type){case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":case"CIMObjectMarker3D":case"CIMglTFMarker3D":{const e=i.size;e>a&&(a=e);break}}return a}case"CIMLineSymbol":case"CIMPolygonSymbol":{let a=0;if(o.symbolLayers)for(const i of o.symbolLayers)if(i)switch(i.type){case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":{const e=i.width;e>a&&(a=e);break}case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":case"CIMObjectMarker3D":case"CIMglTFMarker3D":if((0,ot.gJ)(i.markerPlacement)){const e=i.size;e>a&&(a=e)}}return a}}}static getMarkerScaleRatio(o){return o&&"CIMVectorMarker"===o.type&&!1!==o.scaleSymbolsProportionally&&o.frame?o.size/(o.frame.ymax-o.frame.ymin):1}}class jt{static rasterizeSimpleFill(o,a,i){"solid"!==a&&"none"!==a&&"esriSFSSolid"!==a&&"esriSFSNull"!==a||console.error("Unexpected: style does not require rasterization");const e=(0,L.fp)(Math.ceil(i)),r=$t(a)?8*e:16*e,_=2*e;o.width=r,o.height=r;const c=o.getContext("2d");c.strokeStyle="#FFFFFF",c.lineWidth=e,c.beginPath(),"vertical"!==a&&"cross"!==a&&"esriSFSCross"!==a&&"esriSFSVertical"!==a||(c.moveTo(r/2,-_),c.lineTo(r/2,r+_)),"horizontal"!==a&&"cross"!==a&&"esriSFSCross"!==a&&"esriSFSHorizontal"!==a||(c.moveTo(-_,r/2),c.lineTo(r+_,r/2)),"forward-diagonal"!==a&&"diagonal-cross"!==a&&"esriSFSDiagonalCross"!==a&&"esriSFSForwardDiagonal"!==a||(c.moveTo(-_,-_),c.lineTo(r+_,r+_),c.moveTo(r-_,-_),c.lineTo(r+_,_),c.moveTo(-_,r-_),c.lineTo(_,r+_)),"backward-diagonal"!==a&&"diagonal-cross"!==a&&"esriSFSBackwardDiagonal"!==a&&"esriSFSDiagonalCross"!==a||(c.moveTo(r+_,-_),c.lineTo(-_,r+_),c.moveTo(_,-_),c.lineTo(-_,_),c.moveTo(r+_,r-_),c.lineTo(r-_,r+_)),c.stroke();const l=c.getImageData(0,0,o.width,o.height),g=new Uint8Array(l.data);let d;for(let P=0;P<g.length;P+=4)d=g[P+3]/255,g[P]=g[P]*d,g[P+1]=g[P+1]*d,g[P+2]=g[P+2]*d;return[g,o.width,o.height]}static rasterizeSimpleLine(o,a){return this.rasterizeDash(o,a)}static rasterizeDash(o,a){const i="Butt"===a,e="Square"===a,r=!i&&!e;o.length%2==1&&(o=[...o,...o]);const _=15.5;let l=0;for(const H of o)l+=H;const g=Math.round(l*_),d=new Float32Array(31*g),P=7.75;let x=0,M=0,w=.5,b=!0;for(const H of o){for(x=M,M+=H*_;w<=M;){let nt=.5;for(;nt<31;){const lt=(nt-.5)*g+w-.5,rt=r?(nt-_)*(nt-_):Math.abs(nt-_);d[lt]=b?i?Math.max(Math.max(x+P-w,rt),Math.max(w-M+P,rt)):rt:r?Math.min((w-x)*(w-x)+rt,(w-M)*(w-M)+rt):e?Math.min(Math.max(w-x,rt),Math.max(M-w,rt)):Math.min(Math.max(w-x+P,rt),Math.max(M+P-w,rt)),nt++}w++}b=!b}const v=d.length,A=new Uint8Array(4*v);for(let H=0;H<v;++H){const nt=(r?Math.sqrt(d[H]):d[H])/_;(0,Q.I)(nt,A,4*H)}return[A,g,31]}}class vt{static findApplicableOverrides(o,a,i){if(o&&a){if(o.primitiveName){let e=!1;for(const r of i)if(r.primitiveName===o.primitiveName){e=!0;break}if(!e)for(const r of a)r.primitiveName===o.primitiveName&&i.push(r)}switch(o.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(o.effects)for(const e of o.effects)vt.findApplicableOverrides(e,a,i);if(o.symbolLayers)for(const e of o.symbolLayers)vt.findApplicableOverrides(e,a,i);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":case"CIMSolidFill":case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":case"CIMVectorMarker":case"CIMCharacterMarker":case"CIMPictureMarker":if(o.effects)for(const e of o.effects)vt.findApplicableOverrides(e,a,i);if(o.markerPlacement&&vt.findApplicableOverrides(o.markerPlacement,a,i),"CIMVectorMarker"===o.type){if(o.markerGraphics)for(const e of o.markerGraphics)vt.findApplicableOverrides(e,a,i),vt.findApplicableOverrides(e.symbol,a,i)}else"CIMCharacterMarker"===o.type?vt.findApplicableOverrides(o.symbol,a,i):"CIMHatchFill"===o.type?vt.findApplicableOverrides(o.lineSymbol,a,i):"CIMPictureMarker"===o.type&&vt.findApplicableOverrides(o.animatedSymbolProperties,a,i)}}}static findEffectOverrides(o,a,i){if(!a||!o)return;const e=o.length;for(let r=0;r<e;r++){const _=o[r]?.primitiveName;if(_){let c=!1;for(const l of i)if(l.primitiveName===_){c=!0;break}if(!c)for(const l of a)l.primitiveName===_&&i.push(l)}}}static applyOverrides(o,a,i,e){if(!a)return;const r=_=>_&&_.charAt(0).toLowerCase()+_.substr(1);if(o.primitiveName)for(const _ of a)if(_.primitiveName===o.primitiveName){const c=r(_.propertyName);if(e&&e.push({cim:o,nocapPropertyName:c,value:o[c]}),_.expression&&(_.value=vt.toValue(_.propertyName,_.expression)),i){let l=!1;for(const g of i)g.primitiveName===o.primitiveName&&(l=!0);l||i.push(_)}o[c]=_.value}switch(o.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(o.effects)for(const _ of o.effects)vt.applyOverrides(_,a,i,e);if(o.symbolLayers)for(const _ of o.symbolLayers)vt.applyOverrides(_,a,i,e);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMSolidFill":case"CIMVectorMarker":if(o.effects)for(const _ of o.effects)vt.applyOverrides(_,a,i,e);if("CIMVectorMarker"===o.type&&o.markerGraphics)for(const _ of o.markerGraphics)vt.applyOverrides(_,a,i,e),vt.applyOverrides(_.symbol,a,i,e)}}static restoreOverrides(o){for(const a of o)a.cim[a.nocapPropertyName]=a.value}static buildOverrideKey(o){let a="";for(const i of o)void 0!==i.value&&(a+=`${i.primitiveName}${i.propertyName}${JSON.stringify(i.value)}`);return a}static toValue(o,a){if("DashTemplate"===o)return a.split(" ").map(i=>Number(i));if("Color"===o){const i=new K.Z(a).toRgba();return i[3]*=255,i}return a}}const Xt=D=>{if(!D)return et.kP.Butt;switch(D){case"butt":return et.kP.Butt;case"square":return et.kP.Square;case"round":return et.kP.Round}},Wt=D=>{if(!D)return et.r4.Miter;switch(D){case"miter":return et.r4.Miter;case"round":return et.r4.Round;case"bevel":return et.r4.Bevel}},Qt=D=>{if((0,mt.Wi)(D))return"Center";switch(D){case"left":return"Left";case"right":return"Right";case"center":return"Center"}},qt=D=>{if((0,mt.Wi)(D))return"Center";switch(D){case"baseline":return"Baseline";case"top":return"Top";case"middle":return"Center";case"bottom":return"Bottom"}},Rt=D=>{if(!D)return[0,0,0,0];const{r:o,g:a,b:i,a:e}=D;return[o,a,i,255*e]},te=(D,o)=>{const a=ee(o),i=se(D);return a&&i?`${a}-${i}`:`${a}${i}`},ee=D=>{if(!D)return"";switch(D.toLowerCase()){case"bold":case"bolder":return"bold"}return""},se=D=>{if(!D)return"";switch(D.toLowerCase()){case"italic":case"oblique":return"italic"}return""},Ut=(D,o)=>{const a="butt"===o;switch(D){case"dash":case"esriSLSDash":return a?[4,3]:[3,4];case"dash-dot":case"esriSLSDashDot":return a?[4,3,1,3]:[3,4,0,4];case"dot":case"esriSLSDot":return a?[1,3]:[0,4];case"long-dash":case"esriSLSLongDash":return a?[8,3]:[7,4];case"long-dash-dot":case"esriSLSLongDashDot":return a?[8,3,1,3]:[7,4,0,4];case"long-dash-dot-dot":case"esriSLSDashDotDot":return a?[8,3,1,3,1,3]:[7,4,0,4,0,4];case"short-dash":case"esriSLSShortDash":return a?[4,1]:[3,2];case"short-dash-dot":case"esriSLSShortDashDot":return a?[4,1,1,1]:[3,2,0,2];case"short-dash-dot-dot":case"esriSLSShortDashDotDot":return a?[4,1,1,1,1,1]:[3,2,0,2,0,2];case"short-dot":case"esriSLSShortDot":return a?[1,1]:[0,2];case"solid":case"esriSLSSolid":case"none":return Ot.error("Unexpected: style does not require rasterization"),[0,0];default:return Ot.error(`Tried to rasterize SLS, but found an unexpected style: ${D}!`),[0,0]}},Jt=D=>{let i,e;const r=D;if("circle"===r||"esriSMSCircle"===r){let c=Math.acos(.995),l=Math.ceil(Ft/c/4);0===l&&(l=1),c=Ct/l,l*=4;const g=[];g.push([50,0]);for(let d=1;d<l;d++)g.push([50*Math.cos(d*c),-50*Math.sin(d*c)]);g.push([50,0]),i={rings:[g]},e={xmin:-50,ymin:-50,xmax:50,ymax:50}}else if("cross"===r||"esriSMSCross"===r)i={rings:[[[0,50],[0,0],[50,0],[50,-0],[0,-0],[0,-50],[-0,-50],[-0,-0],[-50,-0],[-50,0],[-0,0],[-0,50],[0,50]]]},e={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("diamond"===r||"esriSMSDiamond"===r)i={rings:[[[-50,0],[0,50],[50,0],[0,-50],[-50,0]]]},e={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("square"===r||"esriSMSSquare"===r)i={rings:[[[-50,-50],[-50,50],[50,50],[50,-50],[-50,-50]]]},e={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("x"===r||"esriSMSX"===r)i={rings:[[[0,0],[50,50],[50,50],[0,0],[50,-50],[50,-50],[0,-0],[-50,-50],[-50,-50],[-0,0],[-50,50],[-50,50],[0,0]]]},e={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("triangle"===r||"esriSMSTriangle"===r){const _=57.735026918962575,c=-_,l=2/3*100,g=l-100;i={rings:[[[c,g],[0,l],[_,g],[c,g]]]},e={xmin:c,ymin:g,xmax:_,ymax:l}}else"arrow"===r&&(i={rings:[[[-50,50],[50,0],[-50,-50],[-33,-20],[-33,20],[-50,50]]]},e={xmin:-50,ymin:-50,xmax:50,ymax:50});return[e,i]},$t=D=>"vertical"===D||"horizontal"===D||"cross"===D||"esriSFSCross"===D||"esriSFSVertical"===D||"esriSFSHorizontal"===D},31375:(Dt,xt,j)=>{j.d(xt,{Z:()=>K});class K{constructor(Q=0,it=0,dt=0,L=0){this.x=Q,this.y=it,this.width=dt,this.height=L}get isEmpty(){return this.width<=0||this.height<=0}union(Q){this.x=Math.min(this.x,Q.x),this.y=Math.min(this.y,Q.y),this.width=Math.max(this.width,Q.width),this.height=Math.max(this.height,Q.height)}}},68937:(Dt,xt,j)=>{j.d(xt,{Z:()=>it});var K=j(23841);class it{rasterizeText(V,Y){this._textRasterizationCanvas||(this._textRasterizationCanvas=document.createElement("canvas"));const X=this._textRasterizationCanvas,q=X.getContext("2d");this._setFontProperties(q,Y),this.parameters=Y,this.textLines=V.split(/\r?\n/),this.lineHeight=this._computeLineHeight();const at=this._computeTextWidth(q,Y),{decoration:ut,weight:_t}=Y.font;this.lineThroughWidthOffset=ut&&"line-through"===ut?.1*this.lineHeight:0;const st=this.lineHeight*this.textLines.length;X.width=at+2*this.lineThroughWidthOffset,X.height=st,this.renderedLineHeight=Math.round(this.lineHeight*Y.pixelRatio),this.renderedHaloSize=Y.halo.size*Y.pixelRatio,this.renderedWidth=at*Y.pixelRatio,this.renderedHeight=st*Y.pixelRatio,this.lineThroughWidthOffset*=Y.pixelRatio,this.fillStyle=function Q(mt){return`rgba(${mt.slice(0,3).toString()},${mt[3]})`}(Y.color),this.haloStyle=function B(mt){return`rgb(${mt.slice(0,3).toString()})`}(Y.halo.color);const Mt=this.renderedLineHeight,gt=this.renderedHaloSize;this._setFontProperties(q,Y);const Lt=function dt(mt,V){return"center"===mt?.5*V:"right"===mt?V:0}(q.textAlign,this.renderedWidth)+gt,et=gt;let Et=this.lineThroughWidthOffset,kt=0;gt>0&&this._renderHalo(q,Lt,et,Et,kt,Y),kt+=et,Et+=Lt;for(const W of this.textLines)q.globalCompositeOperation="destination-out",q.fillStyle="rgb(0, 0, 0)",q.fillText(W,Et,kt),q.globalCompositeOperation="source-over",q.fillStyle=this.fillStyle,q.fillText(W,Et,kt),ut&&"none"!==ut&&this._renderDecoration(q,Et,kt,ut,_t),kt+=Mt;const z=this.renderedWidth+2*this.lineThroughWidthOffset,Z=this.renderedHeight,$=q.getImageData(0,0,z,Z),F=new Uint8Array($.data);if(Y.premultiplyColors){let W;for(let U=0;U<F.length;U+=4)W=F[U+3]/255,F[U]=F[U]*W,F[U+1]=F[U+1]*W,F[U+2]=F[U+2]*W}return{size:[z,Z],image:new Uint32Array(F.buffer),sdf:!1,simplePattern:!1,anchorX:0,anchorY:0}}_renderHalo(V,Y,X,q,at,ut){const _t=this.renderedWidth,st=this.renderedHeight;this._haloRasterizationCanvas||(this._haloRasterizationCanvas=document.createElement("canvas")),this._haloRasterizationCanvas.width=_t,this._haloRasterizationCanvas.height=st;const Mt=this._haloRasterizationCanvas,gt=Mt.getContext("2d");gt.clearRect(0,0,_t,st),this._setFontProperties(gt,ut);const{decoration:Lt,weight:et}=ut.font;gt.fillStyle=this.haloStyle,gt.strokeStyle=this.haloStyle;const Tt=this.renderedHaloSize<3;gt.lineJoin=Tt?"miter":"round",Tt?this._renderHaloEmulated(gt,Y,X,Lt,et):this._renderHaloNative(gt,Y,X,Lt,et),V.globalAlpha=this.parameters.halo.color[3],V.drawImage(Mt,0,0,_t,st,q,at,_t,st),V.globalAlpha=1}_renderHaloEmulated(V,Y,X,q,at){const ut=this.renderedLineHeight,_t=this.renderedHaloSize;for(const st of this.textLines){for(const[Mt,gt]of L)V.fillText(st,Y+_t*Mt,X+_t*gt);q&&"none"!==q&&this._renderDecoration(V,Y,X,q,at),X+=ut}}_renderHaloNative(V,Y,X,q,at){const ut=this.renderedLineHeight,_t=this.renderedHaloSize;for(const st of this.textLines){const Mt=2*_t,gt=5,Lt=.1;for(let et=0;et<gt;et++)V.lineWidth=(1-(gt-1)*Lt+et*Lt)*Mt,V.strokeText(st,Y,X),q&&"none"!==q&&this._renderDecoration(V,Y,X,q,at);X+=ut}}_setFontProperties(V,Y){const X=Y.font,q=`${X.style} ${X.weight} ${(0,K.F2)(Y.size*Y.pixelRatio)}px ${X.family}, sans-serif`;let at;switch(V.font=q,V.textBaseline="top",Y.horizontalAlignment){case"left":default:at="left";break;case"right":at="right";break;case"center":at="center"}V.textAlign=at}computeTextSize(V,Y){this._textRasterizationCanvas||(this._textRasterizationCanvas=document.createElement("canvas"));const X=this._textRasterizationCanvas,q=X.getContext("2d");this._setFontProperties(q,Y),this.parameters=Y,this.textLines=V.split(/\r?\n/),this.lineHeight=this._computeLineHeight();const at=this._computeTextWidth(q,Y),ut=this.lineHeight*this.textLines.length;return X.width=at,X.height=ut,[at*Y.pixelRatio,ut*Y.pixelRatio]}_computeTextWidth(V,Y){let X=0;for(const at of this.textLines)X=Math.max(X,V.measureText(at).width);const q=Y.font;return("italic"===q.style||"oblique"===q.style||"string"==typeof q.weight&&("bold"===q.weight||"bolder"===q.weight)||"number"==typeof q.weight&&q.weight>600)&&(X+=.3*V.measureText("w").width),X+=2*this.parameters.halo.size,Math.round(X)}_computeLineHeight(){let V=1.275*this.parameters.size;const Y=this.parameters.font.decoration;return Y&&"underline"===Y&&(V*=1.3),Math.round(V+2*this.parameters.halo.size)}_renderDecoration(V,Y,X,q,at){const ut=.9*this.lineHeight,_t="bold"===at?.06:"bolder"===at?.09:.04;switch(V.textAlign){case"center":Y-=this.renderedWidth/2;break;case"right":Y-=this.renderedWidth}const st=V.textBaseline;if("underline"===q)switch(st){case"top":X+=ut;break;case"middle":X+=ut/2}else if("line-through"===q)switch(st){case"top":X+=ut/1.5;break;case"middle":X+=ut/3}V.save(),V.beginPath(),V.strokeStyle=V.fillStyle,V.lineWidth=Math.ceil(ut*_t),V.moveTo(Y-this.lineThroughWidthOffset,X),V.lineTo(Y+this.renderedWidth+2*this.lineThroughWidthOffset,X),V.stroke(),V.restore()}}const L=[];for(let V=0;V<360;V+=22.5)L.push([Math.cos(Math.PI*V/180),Math.sin(Math.PI*V/180)])},40028:(Dt,xt,j)=>{var K,B,X;function Q(X){switch(X){case"left":return K.Left;case"right":return K.Right;case"center":return K.Center}}function it(X){switch(X){case"top":return B.Top;case"middle":return B.Center;case"baseline":return B.Baseline;case"bottom":return B.Bottom}}function dt(X){switch(X){case"above-left":case"esriServerPointLabelPlacementAboveLeft":return[K.Right,B.Bottom];case"above-center":case"above-along":case"esriServerPointLabelPlacementAboveCenter":case"esriServerLinePlacementAboveAlong":return[K.Center,B.Bottom];case"above-right":case"esriServerPointLabelPlacementAboveRight":return[K.Left,B.Bottom];case"center-left":case"esriServerPointLabelPlacementCenterLeft":return[K.Right,B.Center];case"center-center":case"center-along":case"esriServerPointLabelPlacementCenterCenter":case"esriServerLinePlacementCenterAlong":case"always-horizontal":case"esriServerPolygonPlacementAlwaysHorizontal":return[K.Center,B.Center];case"center-right":case"esriServerPointLabelPlacementCenterRight":return[K.Left,B.Center];case"below-left":case"esriServerPointLabelPlacementBelowLeft":return[K.Right,B.Top];case"below-center":case"below-along":case"esriServerPointLabelPlacementBelowCenter":case"esriServerLinePlacementBelowAlong":return[K.Center,B.Top];case"below-right":case"esriServerPointLabelPlacementBelowRight":return[K.Left,B.Top];default:return console.debug(`Found invalid placement type ${X}`),[K.Center,B.Center]}}function L(X){switch(X){case K.Right:return-1;case K.Center:return 0;case K.Left:return 1;default:return console.debug(`Found invalid horizontal alignment ${X}`),0}}function mt(X){switch(X){case B.Top:return 1;case B.Center:return 0;case B.Bottom:case B.Baseline:return-1;default:return console.debug(`Found invalid vertical alignment ${X}`),0}}function V(X){switch(X){case"left":return K.Left;case"right":return K.Right;case"center":return K.Center}}function Y(X){switch(X){case"above-along":case"below-along":case"center-along":case"esriServerLinePlacementAboveAlong":case"esriServerLinePlacementBelowAlong":case"esriServerLinePlacementCenterAlong":return!0;default:return!1}}j.d(xt,{Hd:()=>V,NS:()=>Y,TR:()=>B,b7:()=>it,g:()=>L,kH:()=>Q,qv:()=>dt,tf:()=>mt}),(X=K||(K={}))[X.Left=-1]="Left",X[X.Center=0]="Center",X[X.Right=1]="Right",function(X){X[X.Top=1]="Top",X[X.Center=0]="Center",X[X.Bottom=-1]="Bottom",X[X.Baseline=2]="Baseline"}(B||(B={}))},25797:(Dt,xt,j)=>{j.d(xt,{Nr:()=>Z});var K=j(31478),B=j(12225),Q=j(67831),it=j(9545),dt=j(40028),L=j(5254),mt=j(84439);class V{constructor(F,W,U,J){this.center=(0,it.f)(F,W),this.centerT=(0,it.c)(),this.halfWidth=U/2,this.halfHeight=J/2,this.width=U,this.height=J}get x(){return this.center[0]}get y(){return this.center[1]}get blX(){return this.center[0]+this.halfWidth}get blY(){return this.center[1]+this.halfHeight}get trX(){return this.center[0]-this.halfWidth}get trY(){return this.center[1]-this.halfHeight}get xmin(){return this.x-this.halfWidth}get xmax(){return this.x+this.halfWidth}get ymin(){return this.y-this.halfHeight}get ymax(){return this.y+this.halfHeight}set x(F){this.center[0]=F}set y(F){this.center[1]=F}clone(){return new V(this.x,this.y,this.width,this.height)}serialize(F){return F.writeF32(this.center[0]),F.writeF32(this.center[1]),F.push(this.width),F.push(this.height),F}findCollisionDelta(F,W=4){const U=Math.abs(F.centerT[0]-this.centerT[0]),J=Math.abs(F.centerT[1]-this.centerT[1]),pt=Math.min((F.halfWidth+this.halfWidth+W)/U,(F.halfHeight+this.halfHeight+W)/J);return Math.log2(pt)}extend(F){const W=Math.min(this.xmin,F.xmin),U=Math.min(this.ymin,F.ymin),J=Math.max(this.xmax,F.xmax)-W,tt=Math.max(this.ymax,F.ymax)-U,ft=W+J/2,pt=U+tt/2;this.width=J,this.height=tt,this.halfWidth=J/2,this.halfHeight=tt/2,this.x=ft,this.y=pt}static deserialize(F){const W=F.readF32(),U=F.readF32(),J=F.readInt32(),tt=F.readInt32();return new V(W,U,J,tt)}}const st=Math.PI/180;class Mt{constructor(F,W,U,J){this._rotationT=(0,B.c)(),this._xBounds=0,this._yBounds=0,this.minZoom=0,this.maxZoom=255,this._bounds=null;const tt=U.rect,ft=new Float32Array(8);W*=J;const pt=U.code?tt.width*J:U.metrics.width,ht=U.code?tt.height*J:U.metrics.height;ft[0]=F*=J,ft[1]=W,ft[2]=F+pt,ft[3]=W,ft[4]=F,ft[5]=W+ht,ft[6]=F+pt,ft[7]=W+ht,this._data=ft,this._setTextureCoords(tt),this._scale=J,this._mosaic=U,this.x=F,this.y=W,this.maxOffset=Math.max(F+pt,W+ht)}get width(){return this._mosaic.metrics.width*this._scale}get mosaic(){return this._mosaic}set angle(F){this._angle=F,(0,K.c)(this._rotationT,-F),this._setOffsets(this._data)}get angle(){return this._angle}get xTopLeft(){return this._data[0]}get yTopLeft(){return this._data[1]}get xBottomRight(){return this._data[6]}get yBottomRight(){return this._data[7]}get texcoords(){return this._texcoords}get textureBinding(){return this._mosaic.textureBinding}get offsets(){return this._offsets||this._setOffsets(this._data),this._offsets}get char(){return String.fromCharCode(this._mosaic.code)}get code(){return this._mosaic.code}get bounds(){if(!this._bounds){const{height:F,width:W}=this._mosaic.metrics,U=W*this._scale,J=Math.abs(F)*this._scale,tt=new Float32Array(8);tt[0]=this.x,tt[1]=this.y,tt[2]=this.x+U,tt[3]=this.y,tt[4]=this.x,tt[5]=this.y+J,tt[6]=this.x+U,tt[7]=this.y+J;const ft=(0,K.m)((0,B.c)(),this._rotationT,this._T);(0,B.t)(tt,tt,ft);let pt=1/0,ht=1/0,yt=0,Pt=0;for(let Ct=0;Ct<4;Ct++){const St=tt[2*Ct],Gt=tt[2*Ct+1];pt=Math.min(pt,St),ht=Math.min(ht,Gt),yt=Math.max(yt,St),Pt=Math.max(Pt,Gt)}const At=yt-pt,ot=Pt-ht;this._bounds=new V(pt+At/2,ht+ot/2,At,ot)}return this._bounds}setTransform(F){this._T=F,this._offsets=null}_setOffsets(F){this._offsets||(this._offsets={upperLeft:0,upperRight:0,lowerLeft:0,lowerRight:0});const W=this._offsets,U=new Float32Array(8),J=(0,K.m)((0,B.c)(),this._rotationT,this._T);(0,B.t)(U,F,J),W.upperLeft=(0,L.UJ)(8*U[0],8*U[1]),W.upperRight=(0,L.UJ)(8*U[2],8*U[3]),W.lowerLeft=(0,L.UJ)(8*U[4],8*U[5]),W.lowerRight=(0,L.UJ)(8*U[6],8*U[7])}_setTextureCoords({x:F,y:W,width:U,height:J}){this._texcoords={upperLeft:(0,L.UJ)(F,W),upperRight:(0,L.UJ)(F+U,W),lowerLeft:(0,L.UJ)(F,W+J),lowerRight:(0,L.UJ)(F+U,W+J)}}}const gt=($,F)=>({code:0,page:0,sdf:!0,rect:new mt.Z(0,0,11,8),textureBinding:F,metrics:{advance:0,height:4,width:$,left:0,top:0}});class Lt{constructor(F,W,U){this._rotation=0,this._decorate(F,W,U),this.glyphs=F,this.bounds=this._createBounds(F),this.isMultiline=W.length>1,this._hasRotation=0!==U.angle,this._T=this._createGlyphTransform(this.bounds,U);for(const J of F)J.setTransform(this._T)}setRotation(F){if(0===F&&0===this._rotation)return;this._rotation=F;const W=this._T,U=(0,K.c)((0,B.c)(),F);(0,K.m)(W,U,W);for(const J of this.glyphs)J.setTransform(this._T)}_decorate(F,W,U){if(!U.decoration||"none"===U.decoration||!F.length)return;const J=U.scale,tt="underline"===U.decoration?30:20,ft=F[0].textureBinding;for(const pt of W)F.push(new Mt(pt.startX*J,pt.startY*J+tt*J,gt((pt.width+pt.glyphWidthEnd)*J,ft),1))}get boundsT(){const F=this.bounds,W=(0,Q.a)((0,it.c)(),F.x,F.y);if((0,Q.t)(W,W,this._T),this._hasRotation){const U=Math.max(F.width,F.height);return new V(W[0],W[1],U,U)}return new V(W[0],W[1],F.width,F.height)}_createBounds(F){let W=1/0,U=1/0,J=0,tt=0;for(const ht of F)W=Math.min(W,ht.xTopLeft),U=Math.min(U,ht.yTopLeft),J=Math.max(J,ht.xTopLeft+ht.width),tt=Math.max(tt,ht.yBottomRight);const ft=J-W,pt=tt-U;return new V(W+ft/2,U+pt/2,ft,pt)}_createGlyphTransform(F,W){const U=st*W.angle,J=(0,B.c)(),tt=(0,it.c)();return(0,K.t)(J,J,(0,Q.a)(tt,W.xOffset,-W.yOffset)),W.isCIM?(0,K.r)(J,J,U):((0,K.t)(J,J,(0,Q.a)(tt,F.x,F.y)),(0,K.r)(J,J,U),(0,K.t)(J,J,(0,Q.a)(tt,-F.x,-F.y))),J}}class et{constructor(F,W,U,J,tt,ft){this.glyphWidthEnd=0,this.startX=0,this.startY=0,this.start=Math.max(0,Math.min(W,U)),this.end=Math.max(0,Math.max(W,U)),this.end<F.length&&(this.glyphWidthEnd=F[this.end].metrics.width),this.width=J,this.yMin=tt,this.yMax=ft}}const Tt=$=>10===$,Et=$=>32===$;function Z($,F,W){const U=W.scale,J=new Array,tt=function kt($,F,W){const U=new Array,tt=W.maxLineWidth*(1/W.scale),ft=F?$.length-1:0,pt=F?-1:$.length,ht=F?-1:1;let yt=ft,Pt=0,At=0,ot=yt,zt=ot,Ft=0,Ct=1/0,St=0;for(;yt!==pt;){const{code:bt,metrics:wt}=$[yt],Ot=Math.abs(wt.top);Tt(bt)||Et(bt)||(Ct=Math.min(Ct,Ot),St=Math.max(St,Ot+wt.height)),Tt(bt)?(yt!==ft&&(U.push(new et($,ot,yt-ht,Pt,Ct,St)),Ct=1/0,St=0),Pt=0,ot=yt+ht,zt=yt+ht,At=0):Et(bt)?(zt=yt+ht,At=0,Ft=wt.advance,Pt+=wt.advance):Pt>tt?(zt!==ot?(Pt-=Ft,U.push(new et($,ot,zt-2*ht,Pt-At,Ct,St)),Ct=1/0,St=0,ot=zt,Pt=At):(U.push(new et($,ot,yt-ht,Pt,Ct,St)),Ct=1/0,St=0,ot=yt,zt=yt,Pt=0),Pt+=wt.advance,At+=wt.advance):(Pt+=wt.advance,At+=wt.advance),yt+=ht}const Gt=new et($,ot,yt-ht,Pt,Ct,St);return Gt.start>=0&&Gt.end<$.length&&U.push(Gt),U}($,F,W),ft=function z($,F){let W=0;for(let tt=0;tt<$.length;tt++){const{width:ft}=$[tt];W=Math.max(ft,W)}const J=$[0].yMin;return{x:0,y:J,height:$[$.length-1].yMax+F.lineHeight*($.length-1)+("underline"===F.decoration?4:0)-J,width:W}}(tt,W),{vAlign:pt,hAlign:ht}=W,yt=pt===dt.TR.Baseline?1:0,At=(1-yt)*-ft.y+ft.height/2*(yt?0:pt-1)+-26*(yt?1:0);for(let ot=0;ot<tt.length;ot++){const{start:zt,end:Ft,width:Ct}=tt[ot];let St=-1*(ht+1)*(Ct/2)-3;const Gt=ot*W.lineHeight+At-3;tt[ot].startX=St,tt[ot].startY=Gt;for(let bt=zt;bt<=Ft;bt++){const wt=$[bt];if(Tt(wt.code))continue;const Ot=new Mt(St+wt.metrics.left,Gt-wt.metrics.top,wt,U);St+=wt.metrics.advance,J.push(Ot)}}return new Lt(J,tt,W)}}}]);