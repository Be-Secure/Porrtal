/* tslint:disable */
/* eslint-disable */
/**
 * DOCUMENTATION
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: contact-email@something.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AuthChangePasswordPostRequest
 */
export interface AuthChangePasswordPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthChangePasswordPostRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof AuthChangePasswordPostRequest
     */
    'currentPassword': string;
    /**
     * 
     * @type {string}
     * @memberof AuthChangePasswordPostRequest
     */
    'passwordConfirmation': string;
}
/**
 * 
 * @export
 * @interface AuthForgotPasswordPost200Response
 */
export interface AuthForgotPasswordPost200Response {
    /**
     * 
     * @type {string}
     * @memberof AuthForgotPasswordPost200Response
     */
    'ok'?: AuthForgotPasswordPost200ResponseOkEnum;
}

export const AuthForgotPasswordPost200ResponseOkEnum = {
    True: 'true'
} as const;

export type AuthForgotPasswordPost200ResponseOkEnum = typeof AuthForgotPasswordPost200ResponseOkEnum[keyof typeof AuthForgotPasswordPost200ResponseOkEnum];

/**
 * 
 * @export
 * @interface AuthForgotPasswordPostRequest
 */
export interface AuthForgotPasswordPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthForgotPasswordPostRequest
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface AuthLocalPostRequest
 */
export interface AuthLocalPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthLocalPostRequest
     */
    'identifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthLocalPostRequest
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface AuthLocalRegisterPostRequest
 */
export interface AuthLocalRegisterPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthLocalRegisterPostRequest
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthLocalRegisterPostRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthLocalRegisterPostRequest
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface AuthResetPasswordPostRequest
 */
export interface AuthResetPasswordPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthResetPasswordPostRequest
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthResetPasswordPostRequest
     */
    'passwordConfirmation'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthResetPasswordPostRequest
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface AuthSendEmailConfirmationPost200Response
 */
export interface AuthSendEmailConfirmationPost200Response {
    /**
     * 
     * @type {string}
     * @memberof AuthSendEmailConfirmationPost200Response
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthSendEmailConfirmationPost200Response
     */
    'sent'?: AuthSendEmailConfirmationPost200ResponseSentEnum;
}

export const AuthSendEmailConfirmationPost200ResponseSentEnum = {
    True: 'true'
} as const;

export type AuthSendEmailConfirmationPost200ResponseSentEnum = typeof AuthSendEmailConfirmationPost200ResponseSentEnum[keyof typeof AuthSendEmailConfirmationPost200ResponseSentEnum];

/**
 * @type ErrorData
 * @export
 */
export type ErrorData = Array<object> | object;

/**
 * 
 * @export
 * @interface ErrorError
 */
export interface ErrorError {
    /**
     * 
     * @type {number}
     * @memberof ErrorError
     */
    'status'?: number;
    /**
     * 
     * @type {string}
     * @memberof ErrorError
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorError
     */
    'message'?: string;
    /**
     * 
     * @type {object}
     * @memberof ErrorError
     */
    'details'?: object;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {ErrorData}
     * @memberof ModelError
     */
    'data'?: ErrorData | null;
    /**
     * 
     * @type {ErrorError}
     * @memberof ModelError
     */
    'error': ErrorError;
}
/**
 * 
 * @export
 * @interface PorrtalRole
 */
export interface PorrtalRole {
    /**
     * 
     * @type {string}
     * @memberof PorrtalRole
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PorrtalRole
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PorrtalRole
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PorrtalRole
     */
    'publishedAt'?: string;
    /**
     * 
     * @type {PorrtalRoleCreatedBy}
     * @memberof PorrtalRole
     */
    'createdBy'?: PorrtalRoleCreatedBy;
    /**
     * 
     * @type {PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissionsDataInnerAttributesRole}
     * @memberof PorrtalRole
     */
    'updatedBy'?: PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissionsDataInnerAttributesRole;
}
/**
 * 
 * @export
 * @interface PorrtalRoleCreatedBy
 */
export interface PorrtalRoleCreatedBy {
    /**
     * 
     * @type {PorrtalRoleCreatedByData}
     * @memberof PorrtalRoleCreatedBy
     */
    'data'?: PorrtalRoleCreatedByData;
}
/**
 * 
 * @export
 * @interface PorrtalRoleCreatedByData
 */
export interface PorrtalRoleCreatedByData {
    /**
     * 
     * @type {number}
     * @memberof PorrtalRoleCreatedByData
     */
    'id'?: number;
    /**
     * 
     * @type {PorrtalRoleCreatedByDataAttributes}
     * @memberof PorrtalRoleCreatedByData
     */
    'attributes'?: PorrtalRoleCreatedByDataAttributes;
}
/**
 * 
 * @export
 * @interface PorrtalRoleCreatedByDataAttributes
 */
export interface PorrtalRoleCreatedByDataAttributes {
    /**
     * 
     * @type {string}
     * @memberof PorrtalRoleCreatedByDataAttributes
     */
    'firstname'?: string;
    /**
     * 
     * @type {string}
     * @memberof PorrtalRoleCreatedByDataAttributes
     */
    'lastname'?: string;
    /**
     * 
     * @type {string}
     * @memberof PorrtalRoleCreatedByDataAttributes
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof PorrtalRoleCreatedByDataAttributes
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof PorrtalRoleCreatedByDataAttributes
     */
    'resetPasswordToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof PorrtalRoleCreatedByDataAttributes
     */
    'registrationToken'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PorrtalRoleCreatedByDataAttributes
     */
    'isActive'?: boolean;
    /**
     * 
     * @type {PorrtalRoleCreatedByDataAttributesRoles}
     * @memberof PorrtalRoleCreatedByDataAttributes
     */
    'roles'?: PorrtalRoleCreatedByDataAttributesRoles;
    /**
     * 
     * @type {boolean}
     * @memberof PorrtalRoleCreatedByDataAttributes
     */
    'blocked'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PorrtalRoleCreatedByDataAttributes
     */
    'preferedLanguage'?: string;
    /**
     * 
     * @type {string}
     * @memberof PorrtalRoleCreatedByDataAttributes
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PorrtalRoleCreatedByDataAttributes
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissionsDataInnerAttributesRole}
     * @memberof PorrtalRoleCreatedByDataAttributes
     */
    'createdBy'?: PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissionsDataInnerAttributesRole;
    /**
     * 
     * @type {PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissionsDataInnerAttributesRole}
     * @memberof PorrtalRoleCreatedByDataAttributes
     */
    'updatedBy'?: PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissionsDataInnerAttributesRole;
}
/**
 * 
 * @export
 * @interface PorrtalRoleCreatedByDataAttributesRoles
 */
export interface PorrtalRoleCreatedByDataAttributesRoles {
    /**
     * 
     * @type {Array<PorrtalRoleCreatedByDataAttributesRolesDataInner>}
     * @memberof PorrtalRoleCreatedByDataAttributesRoles
     */
    'data'?: Array<PorrtalRoleCreatedByDataAttributesRolesDataInner>;
}
/**
 * 
 * @export
 * @interface PorrtalRoleCreatedByDataAttributesRolesDataInner
 */
export interface PorrtalRoleCreatedByDataAttributesRolesDataInner {
    /**
     * 
     * @type {number}
     * @memberof PorrtalRoleCreatedByDataAttributesRolesDataInner
     */
    'id'?: number;
    /**
     * 
     * @type {PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributes}
     * @memberof PorrtalRoleCreatedByDataAttributesRolesDataInner
     */
    'attributes'?: PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributes;
}
/**
 * 
 * @export
 * @interface PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributes
 */
export interface PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributes {
    /**
     * 
     * @type {string}
     * @memberof PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributes
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributes
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributes
     */
    'description'?: string;
    /**
     * 
     * @type {PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesUsers}
     * @memberof PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributes
     */
    'users'?: PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesUsers;
    /**
     * 
     * @type {PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissions}
     * @memberof PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributes
     */
    'permissions'?: PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissions;
    /**
     * 
     * @type {string}
     * @memberof PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributes
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributes
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissionsDataInnerAttributesRole}
     * @memberof PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributes
     */
    'createdBy'?: PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissionsDataInnerAttributesRole;
    /**
     * 
     * @type {PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissionsDataInnerAttributesRole}
     * @memberof PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributes
     */
    'updatedBy'?: PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissionsDataInnerAttributesRole;
}
/**
 * 
 * @export
 * @interface PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissions
 */
export interface PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissions {
    /**
     * 
     * @type {Array<PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissionsDataInner>}
     * @memberof PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissions
     */
    'data'?: Array<PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissionsDataInner>;
}
/**
 * 
 * @export
 * @interface PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissionsDataInner
 */
export interface PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissionsDataInner {
    /**
     * 
     * @type {number}
     * @memberof PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissionsDataInner
     */
    'id'?: number;
    /**
     * 
     * @type {PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissionsDataInnerAttributes}
     * @memberof PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissionsDataInner
     */
    'attributes'?: PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissionsDataInnerAttributes;
}
/**
 * 
 * @export
 * @interface PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissionsDataInnerAttributes
 */
export interface PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissionsDataInnerAttributes {
    /**
     * 
     * @type {string}
     * @memberof PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissionsDataInnerAttributes
     */
    'action'?: string;
    /**
     * 
     * @type {string}
     * @memberof PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissionsDataInnerAttributes
     */
    'subject'?: string;
    /**
     * 
     * @type {any}
     * @memberof PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissionsDataInnerAttributes
     */
    'properties'?: any;
    /**
     * 
     * @type {any}
     * @memberof PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissionsDataInnerAttributes
     */
    'conditions'?: any;
    /**
     * 
     * @type {PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissionsDataInnerAttributesRole}
     * @memberof PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissionsDataInnerAttributes
     */
    'role'?: PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissionsDataInnerAttributesRole;
    /**
     * 
     * @type {string}
     * @memberof PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissionsDataInnerAttributes
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissionsDataInnerAttributes
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissionsDataInnerAttributesRole}
     * @memberof PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissionsDataInnerAttributes
     */
    'createdBy'?: PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissionsDataInnerAttributesRole;
    /**
     * 
     * @type {PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissionsDataInnerAttributesRole}
     * @memberof PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissionsDataInnerAttributes
     */
    'updatedBy'?: PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissionsDataInnerAttributesRole;
}
/**
 * 
 * @export
 * @interface PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissionsDataInnerAttributesRole
 */
export interface PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissionsDataInnerAttributesRole {
    /**
     * 
     * @type {PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesUsersDataInner}
     * @memberof PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesPermissionsDataInnerAttributesRole
     */
    'data'?: PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesUsersDataInner;
}
/**
 * 
 * @export
 * @interface PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesUsers
 */
export interface PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesUsers {
    /**
     * 
     * @type {Array<PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesUsersDataInner>}
     * @memberof PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesUsers
     */
    'data'?: Array<PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesUsersDataInner>;
}
/**
 * 
 * @export
 * @interface PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesUsersDataInner
 */
export interface PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesUsersDataInner {
    /**
     * 
     * @type {number}
     * @memberof PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesUsersDataInner
     */
    'id'?: number;
    /**
     * 
     * @type {object}
     * @memberof PorrtalRoleCreatedByDataAttributesRolesDataInnerAttributesUsersDataInner
     */
    'attributes'?: object;
}
/**
 * 
 * @export
 * @interface PorrtalRoleListResponse
 */
export interface PorrtalRoleListResponse {
    /**
     * 
     * @type {Array<PorrtalRoleListResponseDataItem>}
     * @memberof PorrtalRoleListResponse
     */
    'data'?: Array<PorrtalRoleListResponseDataItem>;
    /**
     * 
     * @type {PorrtalRoleListResponseMeta}
     * @memberof PorrtalRoleListResponse
     */
    'meta'?: PorrtalRoleListResponseMeta;
}
/**
 * 
 * @export
 * @interface PorrtalRoleListResponseDataItem
 */
export interface PorrtalRoleListResponseDataItem {
    /**
     * 
     * @type {number}
     * @memberof PorrtalRoleListResponseDataItem
     */
    'id'?: number;
    /**
     * 
     * @type {PorrtalRole}
     * @memberof PorrtalRoleListResponseDataItem
     */
    'attributes'?: PorrtalRole;
}
/**
 * 
 * @export
 * @interface PorrtalRoleListResponseMeta
 */
export interface PorrtalRoleListResponseMeta {
    /**
     * 
     * @type {PorrtalRoleListResponseMetaPagination}
     * @memberof PorrtalRoleListResponseMeta
     */
    'pagination'?: PorrtalRoleListResponseMetaPagination;
}
/**
 * 
 * @export
 * @interface PorrtalRoleListResponseMetaPagination
 */
export interface PorrtalRoleListResponseMetaPagination {
    /**
     * 
     * @type {number}
     * @memberof PorrtalRoleListResponseMetaPagination
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof PorrtalRoleListResponseMetaPagination
     */
    'pageSize'?: number;
    /**
     * 
     * @type {number}
     * @memberof PorrtalRoleListResponseMetaPagination
     */
    'pageCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof PorrtalRoleListResponseMetaPagination
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface PorrtalRoleRequest
 */
export interface PorrtalRoleRequest {
    /**
     * 
     * @type {PorrtalRoleRequestData}
     * @memberof PorrtalRoleRequest
     */
    'data': PorrtalRoleRequestData;
}
/**
 * 
 * @export
 * @interface PorrtalRoleRequestData
 */
export interface PorrtalRoleRequestData {
    /**
     * 
     * @type {string}
     * @memberof PorrtalRoleRequestData
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface PorrtalRoleResponse
 */
export interface PorrtalRoleResponse {
    /**
     * 
     * @type {PorrtalRoleResponseDataObject}
     * @memberof PorrtalRoleResponse
     */
    'data'?: PorrtalRoleResponseDataObject;
    /**
     * 
     * @type {object}
     * @memberof PorrtalRoleResponse
     */
    'meta'?: object;
}
/**
 * 
 * @export
 * @interface PorrtalRoleResponseDataObject
 */
export interface PorrtalRoleResponseDataObject {
    /**
     * 
     * @type {number}
     * @memberof PorrtalRoleResponseDataObject
     */
    'id'?: number;
    /**
     * 
     * @type {PorrtalRole}
     * @memberof PorrtalRoleResponseDataObject
     */
    'attributes'?: PorrtalRole;
}
/**
 * 
 * @export
 * @interface UploadFile
 */
export interface UploadFile {
    /**
     * 
     * @type {number}
     * @memberof UploadFile
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UploadFile
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadFile
     */
    'alternativeText'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadFile
     */
    'caption'?: string;
    /**
     * 
     * @type {number}
     * @memberof UploadFile
     */
    'width'?: number;
    /**
     * 
     * @type {number}
     * @memberof UploadFile
     */
    'height'?: number;
    /**
     * 
     * @type {number}
     * @memberof UploadFile
     */
    'formats'?: number;
    /**
     * 
     * @type {string}
     * @memberof UploadFile
     */
    'hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadFile
     */
    'ext'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadFile
     */
    'mime'?: string;
    /**
     * 
     * @type {number}
     * @memberof UploadFile
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof UploadFile
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadFile
     */
    'previewUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadFile
     */
    'provider'?: string;
    /**
     * 
     * @type {object}
     * @memberof UploadFile
     */
    'provider_metadata'?: object;
    /**
     * 
     * @type {string}
     * @memberof UploadFile
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadFile
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface UsersIdDelete200Response
 */
export interface UsersIdDelete200Response {
    /**
     * 
     * @type {number}
     * @memberof UsersIdDelete200Response
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UsersIdDelete200Response
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersIdDelete200Response
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersIdDelete200Response
     */
    'provider'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UsersIdDelete200Response
     */
    'confirmed'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UsersIdDelete200Response
     */
    'blocked'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UsersIdDelete200Response
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersIdDelete200Response
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface UsersPermissionsPermissionsGet200Response
 */
export interface UsersPermissionsPermissionsGet200Response {
    /**
     * 
     * @type {{ [key: string]: UsersPermissionsPermissionsTreeValue; }}
     * @memberof UsersPermissionsPermissionsGet200Response
     */
    'permissions'?: { [key: string]: UsersPermissionsPermissionsTreeValue; };
}
/**
 * every api
 * @export
 * @interface UsersPermissionsPermissionsTreeValue
 */
export interface UsersPermissionsPermissionsTreeValue {
    /**
     * every controller of the api
     * @type {{ [key: string]: { [key: string]: UsersPermissionsPermissionsTreeValueControllersValueValue; }; }}
     * @memberof UsersPermissionsPermissionsTreeValue
     */
    'controllers'?: { [key: string]: { [key: string]: UsersPermissionsPermissionsTreeValueControllersValueValue; }; };
}
/**
 * every action of every controller
 * @export
 * @interface UsersPermissionsPermissionsTreeValueControllersValueValue
 */
export interface UsersPermissionsPermissionsTreeValueControllersValueValue {
    /**
     * 
     * @type {boolean}
     * @memberof UsersPermissionsPermissionsTreeValueControllersValueValue
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsPermissionsTreeValueControllersValueValue
     */
    'policy'?: string;
}
/**
 * 
 * @export
 * @interface UsersPermissionsRole
 */
export interface UsersPermissionsRole {
    /**
     * 
     * @type {number}
     * @memberof UsersPermissionsRole
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsRole
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsRole
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsRole
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsRole
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsRole
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface UsersPermissionsRolesGet200Response
 */
export interface UsersPermissionsRolesGet200Response {
    /**
     * 
     * @type {Array<UsersPermissionsRolesGet200ResponseRolesInner>}
     * @memberof UsersPermissionsRolesGet200Response
     */
    'roles'?: Array<UsersPermissionsRolesGet200ResponseRolesInner>;
}
/**
 * 
 * @export
 * @interface UsersPermissionsRolesGet200ResponseRolesInner
 */
export interface UsersPermissionsRolesGet200ResponseRolesInner {
    /**
     * 
     * @type {number}
     * @memberof UsersPermissionsRolesGet200ResponseRolesInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsRolesGet200ResponseRolesInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsRolesGet200ResponseRolesInner
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsRolesGet200ResponseRolesInner
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsRolesGet200ResponseRolesInner
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsRolesGet200ResponseRolesInner
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof UsersPermissionsRolesGet200ResponseRolesInner
     */
    'nb_users'?: number;
}
/**
 * 
 * @export
 * @interface UsersPermissionsRolesGet200ResponseRolesInnerAllOf
 */
export interface UsersPermissionsRolesGet200ResponseRolesInnerAllOf {
    /**
     * 
     * @type {number}
     * @memberof UsersPermissionsRolesGet200ResponseRolesInnerAllOf
     */
    'nb_users'?: number;
}
/**
 * 
 * @export
 * @interface UsersPermissionsRolesIdGet200Response
 */
export interface UsersPermissionsRolesIdGet200Response {
    /**
     * 
     * @type {UsersPermissionsRole}
     * @memberof UsersPermissionsRolesIdGet200Response
     */
    'role'?: UsersPermissionsRole;
}
/**
 * 
 * @export
 * @interface UsersPermissionsRolesPostRequest
 */
export interface UsersPermissionsRolesPostRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsRolesPostRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsRolesPostRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsRolesPostRequest
     */
    'type'?: string;
    /**
     * 
     * @type {{ [key: string]: UsersPermissionsPermissionsTreeValue; }}
     * @memberof UsersPermissionsRolesPostRequest
     */
    'permissions'?: { [key: string]: UsersPermissionsPermissionsTreeValue; };
}
/**
 * 
 * @export
 * @interface UsersPermissionsUser
 */
export interface UsersPermissionsUser {
    /**
     * 
     * @type {number}
     * @memberof UsersPermissionsUser
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsUser
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsUser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsUser
     */
    'provider'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UsersPermissionsUser
     */
    'confirmed'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UsersPermissionsUser
     */
    'blocked'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsUser
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsUser
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface UsersPermissionsUserRegistration
 */
export interface UsersPermissionsUserRegistration {
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsUserRegistration
     */
    'jwt'?: string;
    /**
     * 
     * @type {UsersPermissionsUser}
     * @memberof UsersPermissionsUserRegistration
     */
    'user'?: UsersPermissionsUser;
}
/**
 * 
 * @export
 * @interface UsersPost201Response
 */
export interface UsersPost201Response {
    /**
     * 
     * @type {number}
     * @memberof UsersPost201Response
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UsersPost201Response
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersPost201Response
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersPost201Response
     */
    'provider'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UsersPost201Response
     */
    'confirmed'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UsersPost201Response
     */
    'blocked'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UsersPost201Response
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersPost201Response
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {UsersPermissionsRole}
     * @memberof UsersPost201Response
     */
    'role'?: UsersPermissionsRole;
}
/**
 * 
 * @export
 * @interface UsersPostRequest
 */
export interface UsersPostRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersPostRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UsersPostRequest
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UsersPostRequest
     */
    'password': string;
}

/**
 * PorrtalRoleApi - axios parameter creator
 * @export
 */
export const PorrtalRoleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePorrtalRolesId: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePorrtalRolesId', 'id', id)
            const localVarPath = `/porrtal-roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [sort] Sort by attributes ascending (asc) or descending (desc)
         * @param {boolean} [paginationWithCount] Return page/pageSize (default: true)
         * @param {number} [paginationPage] Page number (default: 0)
         * @param {number} [paginationPageSize] Page size (default: 25)
         * @param {number} [paginationStart] Offset value (default: 0)
         * @param {number} [paginationLimit] Number of entities to return (default: 25)
         * @param {string} [fields] Fields to return (ex: title,author)
         * @param {string} [populate] Relations to return
         * @param {object} [filters] Filters to apply
         * @param {string} [locale] Locale to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPorrtalRoles: async (sort?: string, paginationWithCount?: boolean, paginationPage?: number, paginationPageSize?: number, paginationStart?: number, paginationLimit?: number, fields?: string, populate?: string, filters?: object, locale?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/porrtal-roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (paginationWithCount !== undefined) {
                localVarQueryParameter['pagination[withCount]'] = paginationWithCount;
            }

            if (paginationPage !== undefined) {
                localVarQueryParameter['pagination[page]'] = paginationPage;
            }

            if (paginationPageSize !== undefined) {
                localVarQueryParameter['pagination[pageSize]'] = paginationPageSize;
            }

            if (paginationStart !== undefined) {
                localVarQueryParameter['pagination[start]'] = paginationStart;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination[limit]'] = paginationLimit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (populate !== undefined) {
                localVarQueryParameter['populate'] = populate;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPorrtalRolesId: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPorrtalRolesId', 'id', id)
            const localVarPath = `/porrtal-roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PorrtalRoleRequest} porrtalRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPorrtalRoles: async (porrtalRoleRequest: PorrtalRoleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'porrtalRoleRequest' is not null or undefined
            assertParamExists('postPorrtalRoles', 'porrtalRoleRequest', porrtalRoleRequest)
            const localVarPath = `/porrtal-roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(porrtalRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {PorrtalRoleRequest} porrtalRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putPorrtalRolesId: async (id: number, porrtalRoleRequest: PorrtalRoleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putPorrtalRolesId', 'id', id)
            // verify required parameter 'porrtalRoleRequest' is not null or undefined
            assertParamExists('putPorrtalRolesId', 'porrtalRoleRequest', porrtalRoleRequest)
            const localVarPath = `/porrtal-roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(porrtalRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PorrtalRoleApi - functional programming interface
 * @export
 */
export const PorrtalRoleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PorrtalRoleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePorrtalRolesId(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePorrtalRolesId(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [sort] Sort by attributes ascending (asc) or descending (desc)
         * @param {boolean} [paginationWithCount] Return page/pageSize (default: true)
         * @param {number} [paginationPage] Page number (default: 0)
         * @param {number} [paginationPageSize] Page size (default: 25)
         * @param {number} [paginationStart] Offset value (default: 0)
         * @param {number} [paginationLimit] Number of entities to return (default: 25)
         * @param {string} [fields] Fields to return (ex: title,author)
         * @param {string} [populate] Relations to return
         * @param {object} [filters] Filters to apply
         * @param {string} [locale] Locale to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPorrtalRoles(sort?: string, paginationWithCount?: boolean, paginationPage?: number, paginationPageSize?: number, paginationStart?: number, paginationLimit?: number, fields?: string, populate?: string, filters?: object, locale?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PorrtalRoleListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPorrtalRoles(sort, paginationWithCount, paginationPage, paginationPageSize, paginationStart, paginationLimit, fields, populate, filters, locale, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPorrtalRolesId(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PorrtalRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPorrtalRolesId(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {PorrtalRoleRequest} porrtalRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPorrtalRoles(porrtalRoleRequest: PorrtalRoleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PorrtalRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postPorrtalRoles(porrtalRoleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {PorrtalRoleRequest} porrtalRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putPorrtalRolesId(id: number, porrtalRoleRequest: PorrtalRoleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PorrtalRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putPorrtalRolesId(id, porrtalRoleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PorrtalRoleApi - factory interface
 * @export
 */
export const PorrtalRoleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PorrtalRoleApiFp(configuration)
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePorrtalRolesId(id: number, options?: any): AxiosPromise<number> {
            return localVarFp.deletePorrtalRolesId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [sort] Sort by attributes ascending (asc) or descending (desc)
         * @param {boolean} [paginationWithCount] Return page/pageSize (default: true)
         * @param {number} [paginationPage] Page number (default: 0)
         * @param {number} [paginationPageSize] Page size (default: 25)
         * @param {number} [paginationStart] Offset value (default: 0)
         * @param {number} [paginationLimit] Number of entities to return (default: 25)
         * @param {string} [fields] Fields to return (ex: title,author)
         * @param {string} [populate] Relations to return
         * @param {object} [filters] Filters to apply
         * @param {string} [locale] Locale to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPorrtalRoles(sort?: string, paginationWithCount?: boolean, paginationPage?: number, paginationPageSize?: number, paginationStart?: number, paginationLimit?: number, fields?: string, populate?: string, filters?: object, locale?: string, options?: any): AxiosPromise<PorrtalRoleListResponse> {
            return localVarFp.getPorrtalRoles(sort, paginationWithCount, paginationPage, paginationPageSize, paginationStart, paginationLimit, fields, populate, filters, locale, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPorrtalRolesId(id: number, options?: any): AxiosPromise<PorrtalRoleResponse> {
            return localVarFp.getPorrtalRolesId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PorrtalRoleRequest} porrtalRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPorrtalRoles(porrtalRoleRequest: PorrtalRoleRequest, options?: any): AxiosPromise<PorrtalRoleResponse> {
            return localVarFp.postPorrtalRoles(porrtalRoleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {PorrtalRoleRequest} porrtalRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putPorrtalRolesId(id: number, porrtalRoleRequest: PorrtalRoleRequest, options?: any): AxiosPromise<PorrtalRoleResponse> {
            return localVarFp.putPorrtalRolesId(id, porrtalRoleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PorrtalRoleApi - object-oriented interface
 * @export
 * @class PorrtalRoleApi
 * @extends {BaseAPI}
 */
export class PorrtalRoleApi extends BaseAPI {
    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PorrtalRoleApi
     */
    public deletePorrtalRolesId(id: number, options?: AxiosRequestConfig) {
        return PorrtalRoleApiFp(this.configuration).deletePorrtalRolesId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [sort] Sort by attributes ascending (asc) or descending (desc)
     * @param {boolean} [paginationWithCount] Return page/pageSize (default: true)
     * @param {number} [paginationPage] Page number (default: 0)
     * @param {number} [paginationPageSize] Page size (default: 25)
     * @param {number} [paginationStart] Offset value (default: 0)
     * @param {number} [paginationLimit] Number of entities to return (default: 25)
     * @param {string} [fields] Fields to return (ex: title,author)
     * @param {string} [populate] Relations to return
     * @param {object} [filters] Filters to apply
     * @param {string} [locale] Locale to apply
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PorrtalRoleApi
     */
    public getPorrtalRoles(sort?: string, paginationWithCount?: boolean, paginationPage?: number, paginationPageSize?: number, paginationStart?: number, paginationLimit?: number, fields?: string, populate?: string, filters?: object, locale?: string, options?: AxiosRequestConfig) {
        return PorrtalRoleApiFp(this.configuration).getPorrtalRoles(sort, paginationWithCount, paginationPage, paginationPageSize, paginationStart, paginationLimit, fields, populate, filters, locale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PorrtalRoleApi
     */
    public getPorrtalRolesId(id: number, options?: AxiosRequestConfig) {
        return PorrtalRoleApiFp(this.configuration).getPorrtalRolesId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PorrtalRoleRequest} porrtalRoleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PorrtalRoleApi
     */
    public postPorrtalRoles(porrtalRoleRequest: PorrtalRoleRequest, options?: AxiosRequestConfig) {
        return PorrtalRoleApiFp(this.configuration).postPorrtalRoles(porrtalRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {PorrtalRoleRequest} porrtalRoleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PorrtalRoleApi
     */
    public putPorrtalRolesId(id: number, porrtalRoleRequest: PorrtalRoleRequest, options?: AxiosRequestConfig) {
        return PorrtalRoleApiFp(this.configuration).putPorrtalRolesId(id, porrtalRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UploadFileApi - axios parameter creator
 * @export
 */
export const UploadFileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFilesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/upload/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFilesIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadFilesIdDelete', 'id', id)
            const localVarPath = `/upload/files/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFilesIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadFilesIdGet', 'id', id)
            const localVarPath = `/upload/files/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload file information
         * @summary 
         * @param {string} id File id
         * @param {UploadIdPostRequestFileInfo} [fileInfo] 
         * @param {File} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadIdPost: async (id: string, fileInfo?: UploadIdPostRequestFileInfo, files?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadIdPost', 'id', id)
            const localVarPath = `/upload/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (fileInfo !== undefined) { 
                localVarFormParams.append('fileInfo', new Blob([JSON.stringify(fileInfo)], { type: "application/json", }));
            }
    
            if (files !== undefined) { 
                localVarFormParams.append('files', files as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload files
         * @summary 
         * @param {Array<File>} files 
         * @param {string} [path] The folder where the file(s) will be uploaded to (only supported on strapi-provider-upload-aws-s3).
         * @param {string} [refId] The ID of the entry which the file(s) will be linked to
         * @param {string} [ref] The unique ID (uid) of the model which the file(s) will be linked to (api::restaurant.restaurant).
         * @param {string} [field] The field of the entry which the file(s) will be precisely linked to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPost: async (files: Array<File>, path?: string, refId?: string, ref?: string, field?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'files' is not null or undefined
            assertParamExists('uploadPost', 'files', files)
            const localVarPath = `/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (path !== undefined) { 
                localVarFormParams.append('path', path as any);
            }
    
            if (refId !== undefined) { 
                localVarFormParams.append('refId', refId as any);
            }
    
            if (ref !== undefined) { 
                localVarFormParams.append('ref', ref as any);
            }
    
            if (field !== undefined) { 
                localVarFormParams.append('field', field as any);
            }
                if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UploadFileApi - functional programming interface
 * @export
 */
export const UploadFileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UploadFileApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFilesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UploadFile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFilesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFilesIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFilesIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFilesIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFilesIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upload file information
         * @summary 
         * @param {string} id File id
         * @param {UploadIdPostRequestFileInfo} [fileInfo] 
         * @param {File} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadIdPost(id: string, fileInfo?: UploadIdPostRequestFileInfo, files?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UploadFile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadIdPost(id, fileInfo, files, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upload files
         * @summary 
         * @param {Array<File>} files 
         * @param {string} [path] The folder where the file(s) will be uploaded to (only supported on strapi-provider-upload-aws-s3).
         * @param {string} [refId] The ID of the entry which the file(s) will be linked to
         * @param {string} [ref] The unique ID (uid) of the model which the file(s) will be linked to (api::restaurant.restaurant).
         * @param {string} [field] The field of the entry which the file(s) will be precisely linked to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadPost(files: Array<File>, path?: string, refId?: string, ref?: string, field?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UploadFile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadPost(files, path, refId, ref, field, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UploadFileApi - factory interface
 * @export
 */
export const UploadFileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UploadFileApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFilesGet(options?: any): AxiosPromise<Array<UploadFile>> {
            return localVarFp.uploadFilesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFilesIdDelete(id: string, options?: any): AxiosPromise<UploadFile> {
            return localVarFp.uploadFilesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFilesIdGet(id: string, options?: any): AxiosPromise<UploadFile> {
            return localVarFp.uploadFilesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload file information
         * @summary 
         * @param {string} id File id
         * @param {UploadIdPostRequestFileInfo} [fileInfo] 
         * @param {File} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadIdPost(id: string, fileInfo?: UploadIdPostRequestFileInfo, files?: File, options?: any): AxiosPromise<Array<UploadFile>> {
            return localVarFp.uploadIdPost(id, fileInfo, files, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload files
         * @summary 
         * @param {Array<File>} files 
         * @param {string} [path] The folder where the file(s) will be uploaded to (only supported on strapi-provider-upload-aws-s3).
         * @param {string} [refId] The ID of the entry which the file(s) will be linked to
         * @param {string} [ref] The unique ID (uid) of the model which the file(s) will be linked to (api::restaurant.restaurant).
         * @param {string} [field] The field of the entry which the file(s) will be precisely linked to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPost(files: Array<File>, path?: string, refId?: string, ref?: string, field?: string, options?: any): AxiosPromise<Array<UploadFile>> {
            return localVarFp.uploadPost(files, path, refId, ref, field, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UploadFileApi - object-oriented interface
 * @export
 * @class UploadFileApi
 * @extends {BaseAPI}
 */
export class UploadFileApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadFileApi
     */
    public uploadFilesGet(options?: AxiosRequestConfig) {
        return UploadFileApiFp(this.configuration).uploadFilesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadFileApi
     */
    public uploadFilesIdDelete(id: string, options?: AxiosRequestConfig) {
        return UploadFileApiFp(this.configuration).uploadFilesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadFileApi
     */
    public uploadFilesIdGet(id: string, options?: AxiosRequestConfig) {
        return UploadFileApiFp(this.configuration).uploadFilesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload file information
     * @summary 
     * @param {string} id File id
     * @param {UploadIdPostRequestFileInfo} [fileInfo] 
     * @param {File} [files] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadFileApi
     */
    public uploadIdPost(id: string, fileInfo?: UploadIdPostRequestFileInfo, files?: File, options?: AxiosRequestConfig) {
        return UploadFileApiFp(this.configuration).uploadIdPost(id, fileInfo, files, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload files
     * @summary 
     * @param {Array<File>} files 
     * @param {string} [path] The folder where the file(s) will be uploaded to (only supported on strapi-provider-upload-aws-s3).
     * @param {string} [refId] The ID of the entry which the file(s) will be linked to
     * @param {string} [ref] The unique ID (uid) of the model which the file(s) will be linked to (api::restaurant.restaurant).
     * @param {string} [field] The field of the entry which the file(s) will be precisely linked to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadFileApi
     */
    public uploadPost(files: Array<File>, path?: string, refId?: string, ref?: string, field?: string, options?: AxiosRequestConfig) {
        return UploadFileApiFp(this.configuration).uploadPost(files, path, refId, ref, field, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersPermissionsAuthApi - axios parameter creator
 * @export
 */
export const UsersPermissionsAuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Update user\'s own password
         * @param {AuthChangePasswordPostRequest} authChangePasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authChangePasswordPost: async (authChangePasswordPostRequest: AuthChangePasswordPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authChangePasswordPostRequest' is not null or undefined
            assertParamExists('authChangePasswordPost', 'authChangePasswordPostRequest', authChangePasswordPostRequest)
            const localVarPath = `/auth/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authChangePasswordPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Confirm user email
         * @param {string} [confirmation] confirmation token received by email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authEmailConfirmationGet: async (confirmation?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/email-confirmation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (confirmation !== undefined) {
                localVarQueryParameter['confirmation'] = confirmation;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send rest password email
         * @param {AuthForgotPasswordPostRequest} authForgotPasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authForgotPasswordPost: async (authForgotPasswordPostRequest: AuthForgotPasswordPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authForgotPasswordPostRequest' is not null or undefined
            assertParamExists('authForgotPasswordPost', 'authForgotPasswordPostRequest', authForgotPasswordPostRequest)
            const localVarPath = `/auth/forgot-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authForgotPasswordPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a jwt token and user info
         * @summary Local login
         * @param {AuthLocalPostRequest} authLocalPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLocalPost: async (authLocalPostRequest: AuthLocalPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authLocalPostRequest' is not null or undefined
            assertParamExists('authLocalPost', 'authLocalPostRequest', authLocalPostRequest)
            const localVarPath = `/auth/local`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authLocalPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a jwt token and user info
         * @summary Register a user
         * @param {AuthLocalRegisterPostRequest} authLocalRegisterPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLocalRegisterPost: async (authLocalRegisterPostRequest: AuthLocalRegisterPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authLocalRegisterPostRequest' is not null or undefined
            assertParamExists('authLocalRegisterPost', 'authLocalRegisterPostRequest', authLocalRegisterPostRequest)
            const localVarPath = `/auth/local/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authLocalRegisterPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Default Callback from provider auth
         * @param {string} provider Provider name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authProviderCallbackGet: async (provider: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('authProviderCallbackGet', 'provider', provider)
            const localVarPath = `/auth/{provider}/callback`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Rest user password
         * @param {AuthResetPasswordPostRequest} authResetPasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authResetPasswordPost: async (authResetPasswordPostRequest: AuthResetPasswordPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authResetPasswordPostRequest' is not null or undefined
            assertParamExists('authResetPasswordPost', 'authResetPasswordPostRequest', authResetPasswordPostRequest)
            const localVarPath = `/auth/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authResetPasswordPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send confirmation email
         * @param {AuthForgotPasswordPostRequest} authForgotPasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSendEmailConfirmationPost: async (authForgotPasswordPostRequest: AuthForgotPasswordPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authForgotPasswordPostRequest' is not null or undefined
            assertParamExists('authSendEmailConfirmationPost', 'authForgotPasswordPostRequest', authForgotPasswordPostRequest)
            const localVarPath = `/auth/send-email-confirmation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authForgotPasswordPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Redirects to provider login before being redirect to /auth/{provider}/callback
         * @summary Login with a provider
         * @param {string} provider Provider name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectProviderGet: async (provider: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('connectProviderGet', 'provider', provider)
            const localVarPath = `/connect/{provider}`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersPermissionsAuthApi - functional programming interface
 * @export
 */
export const UsersPermissionsAuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersPermissionsAuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Update user\'s own password
         * @param {AuthChangePasswordPostRequest} authChangePasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authChangePasswordPost(authChangePasswordPostRequest: AuthChangePasswordPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersPermissionsUserRegistration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authChangePasswordPost(authChangePasswordPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Confirm user email
         * @param {string} [confirmation] confirmation token received by email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authEmailConfirmationGet(confirmation?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Error>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authEmailConfirmationGet(confirmation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Send rest password email
         * @param {AuthForgotPasswordPostRequest} authForgotPasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authForgotPasswordPost(authForgotPasswordPostRequest: AuthForgotPasswordPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthForgotPasswordPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authForgotPasswordPost(authForgotPasswordPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a jwt token and user info
         * @summary Local login
         * @param {AuthLocalPostRequest} authLocalPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLocalPost(authLocalPostRequest: AuthLocalPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersPermissionsUserRegistration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLocalPost(authLocalPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a jwt token and user info
         * @summary Register a user
         * @param {AuthLocalRegisterPostRequest} authLocalRegisterPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLocalRegisterPost(authLocalRegisterPostRequest: AuthLocalRegisterPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersPermissionsUserRegistration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLocalRegisterPost(authLocalRegisterPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Default Callback from provider auth
         * @param {string} provider Provider name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authProviderCallbackGet(provider: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersPermissionsUserRegistration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authProviderCallbackGet(provider, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Rest user password
         * @param {AuthResetPasswordPostRequest} authResetPasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authResetPasswordPost(authResetPasswordPostRequest: AuthResetPasswordPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersPermissionsUserRegistration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authResetPasswordPost(authResetPasswordPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Send confirmation email
         * @param {AuthForgotPasswordPostRequest} authForgotPasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authSendEmailConfirmationPost(authForgotPasswordPostRequest: AuthForgotPasswordPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthSendEmailConfirmationPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authSendEmailConfirmationPost(authForgotPasswordPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Redirects to provider login before being redirect to /auth/{provider}/callback
         * @summary Login with a provider
         * @param {string} provider Provider name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectProviderGet(provider: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Error>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectProviderGet(provider, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersPermissionsAuthApi - factory interface
 * @export
 */
export const UsersPermissionsAuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersPermissionsAuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Update user\'s own password
         * @param {AuthChangePasswordPostRequest} authChangePasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authChangePasswordPost(authChangePasswordPostRequest: AuthChangePasswordPostRequest, options?: any): AxiosPromise<UsersPermissionsUserRegistration> {
            return localVarFp.authChangePasswordPost(authChangePasswordPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Confirm user email
         * @param {string} [confirmation] confirmation token received by email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authEmailConfirmationGet(confirmation?: string, options?: any): AxiosPromise<Error> {
            return localVarFp.authEmailConfirmationGet(confirmation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send rest password email
         * @param {AuthForgotPasswordPostRequest} authForgotPasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authForgotPasswordPost(authForgotPasswordPostRequest: AuthForgotPasswordPostRequest, options?: any): AxiosPromise<AuthForgotPasswordPost200Response> {
            return localVarFp.authForgotPasswordPost(authForgotPasswordPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a jwt token and user info
         * @summary Local login
         * @param {AuthLocalPostRequest} authLocalPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLocalPost(authLocalPostRequest: AuthLocalPostRequest, options?: any): AxiosPromise<UsersPermissionsUserRegistration> {
            return localVarFp.authLocalPost(authLocalPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a jwt token and user info
         * @summary Register a user
         * @param {AuthLocalRegisterPostRequest} authLocalRegisterPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLocalRegisterPost(authLocalRegisterPostRequest: AuthLocalRegisterPostRequest, options?: any): AxiosPromise<UsersPermissionsUserRegistration> {
            return localVarFp.authLocalRegisterPost(authLocalRegisterPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Default Callback from provider auth
         * @param {string} provider Provider name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authProviderCallbackGet(provider: string, options?: any): AxiosPromise<UsersPermissionsUserRegistration> {
            return localVarFp.authProviderCallbackGet(provider, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Rest user password
         * @param {AuthResetPasswordPostRequest} authResetPasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authResetPasswordPost(authResetPasswordPostRequest: AuthResetPasswordPostRequest, options?: any): AxiosPromise<UsersPermissionsUserRegistration> {
            return localVarFp.authResetPasswordPost(authResetPasswordPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send confirmation email
         * @param {AuthForgotPasswordPostRequest} authForgotPasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSendEmailConfirmationPost(authForgotPasswordPostRequest: AuthForgotPasswordPostRequest, options?: any): AxiosPromise<AuthSendEmailConfirmationPost200Response> {
            return localVarFp.authSendEmailConfirmationPost(authForgotPasswordPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Redirects to provider login before being redirect to /auth/{provider}/callback
         * @summary Login with a provider
         * @param {string} provider Provider name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectProviderGet(provider: string, options?: any): AxiosPromise<Error> {
            return localVarFp.connectProviderGet(provider, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersPermissionsAuthApi - object-oriented interface
 * @export
 * @class UsersPermissionsAuthApi
 * @extends {BaseAPI}
 */
export class UsersPermissionsAuthApi extends BaseAPI {
    /**
     * 
     * @summary Update user\'s own password
     * @param {AuthChangePasswordPostRequest} authChangePasswordPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsAuthApi
     */
    public authChangePasswordPost(authChangePasswordPostRequest: AuthChangePasswordPostRequest, options?: AxiosRequestConfig) {
        return UsersPermissionsAuthApiFp(this.configuration).authChangePasswordPost(authChangePasswordPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Confirm user email
     * @param {string} [confirmation] confirmation token received by email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsAuthApi
     */
    public authEmailConfirmationGet(confirmation?: string, options?: AxiosRequestConfig) {
        return UsersPermissionsAuthApiFp(this.configuration).authEmailConfirmationGet(confirmation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send rest password email
     * @param {AuthForgotPasswordPostRequest} authForgotPasswordPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsAuthApi
     */
    public authForgotPasswordPost(authForgotPasswordPostRequest: AuthForgotPasswordPostRequest, options?: AxiosRequestConfig) {
        return UsersPermissionsAuthApiFp(this.configuration).authForgotPasswordPost(authForgotPasswordPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a jwt token and user info
     * @summary Local login
     * @param {AuthLocalPostRequest} authLocalPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsAuthApi
     */
    public authLocalPost(authLocalPostRequest: AuthLocalPostRequest, options?: AxiosRequestConfig) {
        return UsersPermissionsAuthApiFp(this.configuration).authLocalPost(authLocalPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a jwt token and user info
     * @summary Register a user
     * @param {AuthLocalRegisterPostRequest} authLocalRegisterPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsAuthApi
     */
    public authLocalRegisterPost(authLocalRegisterPostRequest: AuthLocalRegisterPostRequest, options?: AxiosRequestConfig) {
        return UsersPermissionsAuthApiFp(this.configuration).authLocalRegisterPost(authLocalRegisterPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Default Callback from provider auth
     * @param {string} provider Provider name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsAuthApi
     */
    public authProviderCallbackGet(provider: string, options?: AxiosRequestConfig) {
        return UsersPermissionsAuthApiFp(this.configuration).authProviderCallbackGet(provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Rest user password
     * @param {AuthResetPasswordPostRequest} authResetPasswordPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsAuthApi
     */
    public authResetPasswordPost(authResetPasswordPostRequest: AuthResetPasswordPostRequest, options?: AxiosRequestConfig) {
        return UsersPermissionsAuthApiFp(this.configuration).authResetPasswordPost(authResetPasswordPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send confirmation email
     * @param {AuthForgotPasswordPostRequest} authForgotPasswordPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsAuthApi
     */
    public authSendEmailConfirmationPost(authForgotPasswordPostRequest: AuthForgotPasswordPostRequest, options?: AxiosRequestConfig) {
        return UsersPermissionsAuthApiFp(this.configuration).authSendEmailConfirmationPost(authForgotPasswordPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Redirects to provider login before being redirect to /auth/{provider}/callback
     * @summary Login with a provider
     * @param {string} provider Provider name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsAuthApi
     */
    public connectProviderGet(provider: string, options?: AxiosRequestConfig) {
        return UsersPermissionsAuthApiFp(this.configuration).connectProviderGet(provider, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersPermissionsUsersRolesApi - axios parameter creator
 * @export
 */
export const UsersPermissionsUsersRolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get user count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCountGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a user
         * @param {string} id user Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdDelete', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user
         * @param {string} id user Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdGet', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a user
         * @param {string} id user Id
         * @param {UsersPostRequest} usersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdPut: async (id: string, usersPostRequest: UsersPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdPut', 'id', id)
            // verify required parameter 'usersPostRequest' is not null or undefined
            assertParamExists('usersIdPut', 'usersPostRequest', usersPostRequest)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get authenticated user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get default generated permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsPermissionsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users-permissions/permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsRolesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users-permissions/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a role
         * @param {string} id role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsRolesIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersPermissionsRolesIdGet', 'id', id)
            const localVarPath = `/users-permissions/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a role
         * @param {UsersPermissionsRolesPostRequest} usersPermissionsRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsRolesPost: async (usersPermissionsRolesPostRequest: UsersPermissionsRolesPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usersPermissionsRolesPostRequest' is not null or undefined
            assertParamExists('usersPermissionsRolesPost', 'usersPermissionsRolesPostRequest', usersPermissionsRolesPostRequest)
            const localVarPath = `/users-permissions/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersPermissionsRolesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a role
         * @param {string} role role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsRolesRoleDelete: async (role: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'role' is not null or undefined
            assertParamExists('usersPermissionsRolesRoleDelete', 'role', role)
            const localVarPath = `/users-permissions/roles/{role}`
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a role
         * @param {string} role role Id
         * @param {UsersPermissionsRolesPostRequest} usersPermissionsRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsRolesRolePut: async (role: string, usersPermissionsRolesPostRequest: UsersPermissionsRolesPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'role' is not null or undefined
            assertParamExists('usersPermissionsRolesRolePut', 'role', role)
            // verify required parameter 'usersPermissionsRolesPostRequest' is not null or undefined
            assertParamExists('usersPermissionsRolesRolePut', 'usersPermissionsRolesPostRequest', usersPermissionsRolesPostRequest)
            const localVarPath = `/users-permissions/roles/{role}`
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersPermissionsRolesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a user
         * @param {UsersPostRequest} usersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost: async (usersPostRequest: UsersPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usersPostRequest' is not null or undefined
            assertParamExists('usersPost', 'usersPostRequest', usersPostRequest)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersPermissionsUsersRolesApi - functional programming interface
 * @export
 */
export const UsersPermissionsUsersRolesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersPermissionsUsersRolesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get user count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersCountGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersCountGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get list of users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UsersPermissionsUser>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a user
         * @param {string} id user Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersIdDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a user
         * @param {string} id user Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersPermissionsUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a user
         * @param {string} id user Id
         * @param {UsersPostRequest} usersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdPut(id: string, usersPostRequest: UsersPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdPut(id, usersPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get authenticated user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersMeGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersPermissionsUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersMeGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get default generated permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPermissionsPermissionsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersPermissionsPermissionsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPermissionsPermissionsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPermissionsRolesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersPermissionsRolesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPermissionsRolesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a role
         * @param {string} id role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPermissionsRolesIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersPermissionsRolesIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPermissionsRolesIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a role
         * @param {UsersPermissionsRolesPostRequest} usersPermissionsRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPermissionsRolesPost(usersPermissionsRolesPostRequest: UsersPermissionsRolesPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthForgotPasswordPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPermissionsRolesPost(usersPermissionsRolesPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a role
         * @param {string} role role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPermissionsRolesRoleDelete(role: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthForgotPasswordPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPermissionsRolesRoleDelete(role, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a role
         * @param {string} role role Id
         * @param {UsersPermissionsRolesPostRequest} usersPermissionsRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPermissionsRolesRolePut(role: string, usersPermissionsRolesPostRequest: UsersPermissionsRolesPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthForgotPasswordPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPermissionsRolesRolePut(role, usersPermissionsRolesPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a user
         * @param {UsersPostRequest} usersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPost(usersPostRequest: UsersPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPost(usersPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersPermissionsUsersRolesApi - factory interface
 * @export
 */
export const UsersPermissionsUsersRolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersPermissionsUsersRolesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get user count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCountGet(options?: any): AxiosPromise<number> {
            return localVarFp.usersCountGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get list of users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(options?: any): AxiosPromise<Array<UsersPermissionsUser>> {
            return localVarFp.usersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a user
         * @param {string} id user Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdDelete(id: string, options?: any): AxiosPromise<UsersIdDelete200Response> {
            return localVarFp.usersIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user
         * @param {string} id user Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdGet(id: string, options?: any): AxiosPromise<UsersPermissionsUser> {
            return localVarFp.usersIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a user
         * @param {string} id user Id
         * @param {UsersPostRequest} usersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdPut(id: string, usersPostRequest: UsersPostRequest, options?: any): AxiosPromise<UsersPost201Response> {
            return localVarFp.usersIdPut(id, usersPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get authenticated user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeGet(options?: any): AxiosPromise<UsersPermissionsUser> {
            return localVarFp.usersMeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get default generated permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsPermissionsGet(options?: any): AxiosPromise<UsersPermissionsPermissionsGet200Response> {
            return localVarFp.usersPermissionsPermissionsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsRolesGet(options?: any): AxiosPromise<UsersPermissionsRolesGet200Response> {
            return localVarFp.usersPermissionsRolesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a role
         * @param {string} id role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsRolesIdGet(id: string, options?: any): AxiosPromise<UsersPermissionsRolesIdGet200Response> {
            return localVarFp.usersPermissionsRolesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a role
         * @param {UsersPermissionsRolesPostRequest} usersPermissionsRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsRolesPost(usersPermissionsRolesPostRequest: UsersPermissionsRolesPostRequest, options?: any): AxiosPromise<AuthForgotPasswordPost200Response> {
            return localVarFp.usersPermissionsRolesPost(usersPermissionsRolesPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a role
         * @param {string} role role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsRolesRoleDelete(role: string, options?: any): AxiosPromise<AuthForgotPasswordPost200Response> {
            return localVarFp.usersPermissionsRolesRoleDelete(role, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a role
         * @param {string} role role Id
         * @param {UsersPermissionsRolesPostRequest} usersPermissionsRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsRolesRolePut(role: string, usersPermissionsRolesPostRequest: UsersPermissionsRolesPostRequest, options?: any): AxiosPromise<AuthForgotPasswordPost200Response> {
            return localVarFp.usersPermissionsRolesRolePut(role, usersPermissionsRolesPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a user
         * @param {UsersPostRequest} usersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost(usersPostRequest: UsersPostRequest, options?: any): AxiosPromise<UsersPost201Response> {
            return localVarFp.usersPost(usersPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersPermissionsUsersRolesApi - object-oriented interface
 * @export
 * @class UsersPermissionsUsersRolesApi
 * @extends {BaseAPI}
 */
export class UsersPermissionsUsersRolesApi extends BaseAPI {
    /**
     * 
     * @summary Get user count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsUsersRolesApi
     */
    public usersCountGet(options?: AxiosRequestConfig) {
        return UsersPermissionsUsersRolesApiFp(this.configuration).usersCountGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get list of users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsUsersRolesApi
     */
    public usersGet(options?: AxiosRequestConfig) {
        return UsersPermissionsUsersRolesApiFp(this.configuration).usersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a user
     * @param {string} id user Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsUsersRolesApi
     */
    public usersIdDelete(id: string, options?: AxiosRequestConfig) {
        return UsersPermissionsUsersRolesApiFp(this.configuration).usersIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user
     * @param {string} id user Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsUsersRolesApi
     */
    public usersIdGet(id: string, options?: AxiosRequestConfig) {
        return UsersPermissionsUsersRolesApiFp(this.configuration).usersIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a user
     * @param {string} id user Id
     * @param {UsersPostRequest} usersPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsUsersRolesApi
     */
    public usersIdPut(id: string, usersPostRequest: UsersPostRequest, options?: AxiosRequestConfig) {
        return UsersPermissionsUsersRolesApiFp(this.configuration).usersIdPut(id, usersPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get authenticated user info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsUsersRolesApi
     */
    public usersMeGet(options?: AxiosRequestConfig) {
        return UsersPermissionsUsersRolesApiFp(this.configuration).usersMeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get default generated permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsUsersRolesApi
     */
    public usersPermissionsPermissionsGet(options?: AxiosRequestConfig) {
        return UsersPermissionsUsersRolesApiFp(this.configuration).usersPermissionsPermissionsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsUsersRolesApi
     */
    public usersPermissionsRolesGet(options?: AxiosRequestConfig) {
        return UsersPermissionsUsersRolesApiFp(this.configuration).usersPermissionsRolesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a role
     * @param {string} id role Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsUsersRolesApi
     */
    public usersPermissionsRolesIdGet(id: string, options?: AxiosRequestConfig) {
        return UsersPermissionsUsersRolesApiFp(this.configuration).usersPermissionsRolesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a role
     * @param {UsersPermissionsRolesPostRequest} usersPermissionsRolesPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsUsersRolesApi
     */
    public usersPermissionsRolesPost(usersPermissionsRolesPostRequest: UsersPermissionsRolesPostRequest, options?: AxiosRequestConfig) {
        return UsersPermissionsUsersRolesApiFp(this.configuration).usersPermissionsRolesPost(usersPermissionsRolesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a role
     * @param {string} role role Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsUsersRolesApi
     */
    public usersPermissionsRolesRoleDelete(role: string, options?: AxiosRequestConfig) {
        return UsersPermissionsUsersRolesApiFp(this.configuration).usersPermissionsRolesRoleDelete(role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a role
     * @param {string} role role Id
     * @param {UsersPermissionsRolesPostRequest} usersPermissionsRolesPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsUsersRolesApi
     */
    public usersPermissionsRolesRolePut(role: string, usersPermissionsRolesPostRequest: UsersPermissionsRolesPostRequest, options?: AxiosRequestConfig) {
        return UsersPermissionsUsersRolesApiFp(this.configuration).usersPermissionsRolesRolePut(role, usersPermissionsRolesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a user
     * @param {UsersPostRequest} usersPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsUsersRolesApi
     */
    public usersPost(usersPostRequest: UsersPostRequest, options?: AxiosRequestConfig) {
        return UsersPermissionsUsersRolesApiFp(this.configuration).usersPost(usersPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


